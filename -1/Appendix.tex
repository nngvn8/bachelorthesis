\documentclass[preview]{standalone}
\input{prelude}
\begin{document}
\section{Appendix}
\subsection[]{Java Code of Distance Views} \label{apx:distancejava}



\begin{lstlisting}[style=javaStyle, caption={grp Function java}]
protected List<String> groupingFunction() throws Exception {
	List<String> toExecute = new ArrayList<>();
	
	// Compute reachability score
	Set<Long> visited = new HashSet<>();
	Set<Long> visiting = new HashSet<>();
	long distance = 0;
	
	// initialise states with expression
	if (identifierExpression.equals("init")){
		Set<Long> subsetInitStates = model.getInitialStates()
		.stream()
		.filter(stateId -> relevantStates.contains(stateId))
		.collect(Collectors.toSet());
		visiting.addAll(subsetInitStates);
	} else {
		Set<Long> subsetStates = model.getStatesByExpression(model.parseSingleExpressionString(identifierExpression).toString())
		.stream()
		.filter(stateId -> relevantStates.contains(stateId))
		.collect(Collectors.toSet());
		visiting.addAll(subsetStates);
	}
	MdpGraph mdpGraph = model.getMdpGraph();

// BFS: determine distance from states given by (PRISM) expression
while(!visiting.isEmpty()){
	Set<Long> toVisit = new HashSet<>();
	
	for (Long stateID : visiting){
		long curr = distance - Math.floorMod(distance, granularity);
		
		// create SQL statement
		toExecute.add(String.format("UPDATE %s SET %s = '%s' WHERE %s = '%s'", model.getStateTableName(), getCollumn(), curr, ENTRY_S_ID, stateID));
		
		Set<Long> reachableStates;
		
		// see all outgoing (depending Direction Mode)
		switch (direction) {
			case BACKWARD:
			reachableStates = mdpGraph.incomingEdgesOf(stateID)
			.stream()
			.map(mdpGraph::getEdgeSource)
			.filter(stateId -> relevantStates.contains(stateId))
			.collect(Collectors.toSet());
			break;
						
			case DIRECTIONLESS:
			reachableStates =
			mdpGraph.outgoingEdgesOf(stateID)
			.stream()
			.map(mdpGraph::getEdgeTarget)
			.filter(stateId -> relevantStates.contains(stateId))
			.collect(Collectors.toSet());
			reachableStates.addAll(
			mdpGraph.incomingEdgesOf(stateID)
			.stream()
			.map(mdpGraph::getEdgeSource)
			.filter(stateId -> relevantStates.contains(stateId))
			.collect(Collectors.toSet())
			);
			break;
			
			case FORWARD: default:
			reachableStates = mdpGraph.outgoingEdgesOf(stateID)
			.stream()
			.map(mdpGraph::getEdgeTarget)
			.filter(stateId -> relevantStates.contains(stateId))
			.collect(Collectors.toSet());
		}
		
		for (Long idReachableState : reachableStates) {
			if (!(visited.contains(idReachableState) ||
			   visiting.contains(idReachableState))){
				toVisit.add(idReachableState);
			}
		}
	}
	
	visited.addAll(visiting);
	visiting = toVisit;
	distance++;
	}
	
	// compute not reachable states
	Set<Long> not_reachable = new HashSet<>(model.getAllStates())
	.stream()
	.filter(stateId -> relevantStates.contains(stateId))
	.collect(Collectors.toSet());
	not_reachable.removeAll(visited);
	
	// compute SQL statements for not reachable states
	for (long stateID : not_reachable){
		String reachability = semiGrouping ? ENTRY_C_BLANK : "inf";
		toExecute.add(String.format("UPDATE %s SET %s = '%s' WHERE %s = '%s'", model.getStateTableName(), getCollumn(), reachability, ENTRY_S_ID, stateID));
	}
	return toExecute;
}
\end{lstlisting}


\subsection[\prism-File Dining Philosophers]{\prism-File for \mdpN of Dining Philosophers} \label{lst:0601diningphilosophersfull}
%\begin{figure}
\begin{lstlisting}[language=prism, caption={PRISM model file for \mdpN of Dining Philosophers}]
	formula lfree = (p2>=0&p2<=4)|p2=6|p2=10;
	formula rfree = (p3>=0&p3<=3)|p3=5|p3=7|p3=11;
	
	module phil1
	
	p1: [0..11];
	
	[] p1=0 -> (p1'=0); // stay thinking
	[] p1=0 -> (p1'=1); // trying
	[] p1=1 -> 0.5 : (p1'=2) + 0.5 : (p1'=3); // draw randomly
	[] p1=2 &  lfree -> (p1'=4); // pick up left
	[] p1=2 &  !lfree -> (p1'=2); // left not free
	[] p1=3 &  rfree -> (p1'=5); // pick up right
	[] p1=3 &  !rfree -> (p1'=3); // right not free
	[] p1=4 &  rfree -> (p1'=8); // pick up right (got left)
	[] p1=4 & !rfree -> (p1'=6); // right not free (got left)
	[] p1=5 &  lfree -> (p1'=8); // pick up left (got right)
	[] p1=5 & !lfree -> (p1'=7); // left not free (got right)
	[] p1=6  -> (p1'=1); // put down left
	[] p1=7  -> (p1'=1); // put down right
	[] p1=8  -> (p1'=9); // move to eating (got forks)
	[] p1=9  -> (p1'=10); // finished eating and put down left 
	[] p1=9  -> (p1'=11); // finished eating and put down right
	[] p1=10 -> (p1'=0); // put down right and return to think
	[] p1=11 -> (p1'=0); // put down left and return to think
	
	endmodule
	
	// construct further modules through renaming
	module phil2 = phil1 [ p1=p2, p2=p3, p3=p1 ] endmodule
	module phil3 = phil1 [ p1=p3, p2=p1, p3=p2 ] endmodule	
			
\end{lstlisting}
%\end{figure}
	
%	// labels
%	label "hungry" = ((p1>0)&(p1<8))|((p2>0)&(p2<8))|((p3>0)&(p3<8));
%	label "eat" = ((p1>=8)&(p1<=9))|((p2>=8)&(p2<=9))|((p3>=8)&(p3<=9));
%	// randomized dining philosophers [LR81]
%// dxp/gxn 12/12/99
%// atomic formulae 
%// left fork free and right fork free resp.
\pagebreak

\subsection[Figures Large]{Large Figures from Figure \ref{fig:0603timeandphases} in Chapter \ref{ch:eval}}

\begin{figure}[!htb]
	\includegraphics[width=\textwidth]{./06/images/06_03_time.png}
\end{figure}

\begin{figure}[!htb]
	\includegraphics[width=\textwidth]{./06/images/06_03_phases.png}
\end{figure}

\pagebreak

\subsection[Classes Time Measuring and Usage Example]{Timer Class and TimeSaver Class with Usage Example}\label{apx:timerandexmp}
\begin{figure}[!htb]
\begin{lstlisting}[style=javaStyle, caption={Timer.java}]
package prism.misc;

import java.time.LocalTime;

public class Timer implements AutoCloseable {
	TimeSaver timeSaver;
	
	public Timer(TimeSaver timeSaver){
		this.timeSaver = timeSaver;
		timeSaver.storeStartTime(LocalTime.now());
	}
	
	@Override
	public void close() {
		timeSaver.storeEndTime(LocalTime.now());
	}
}

}
\end{lstlisting}
\end{figure}

\begin{figure}[!htb]
	\begin{lstlisting}[style=javaStyle, caption={Example for measuring time with Timer}]
		import prism.misc.Timer;
		import prism.misc.TimeSaver;
		
		class Testtimer {
			public static void main(String[] args) {				
				TimeSaver timeSaver = new TimeSaver();				
				for (int i = 0; i < 100; i++) {
					try(Timer timer = new Timer(timeSaver)) {
						testFunction();
					}
				}			
				System.out.println(timeSaver.getAverageDuration());				
			}
			
			private void testFunction(){
				// do something
			}
		}
	\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[style=javaStyle, caption={TimeSaver.java}]		
package prism.misc;

import java.util.*;
import java.time.LocalTime;
import java.time.Duration;

public class TimeSaver {
	
	private List<LocalTime> startTimes = new ArrayList<>();
	
	private List<LocalTime> endTimes = new ArrayList<>();
	
	public double getAvgDurationInMs() {
		long amountSamples;
		if (startTimes.size() != endTimes.size()) {
			throw new RuntimeException("startTimes.size() != endTimes.size()");
		} else {
			amountSamples = startTimes.size();
		}
		long durationAccLong = 0;
		for (int i = 0; i < amountSamples; i++) {
			durationAccLong += getDurationInMsAt(i);
		}
		return ((double)durationAccLong) / ((double)amountSamples);
	}
	
	public long getDurationInMsAt(int i) {
		return Duration.between(startTimes.get(i), endTimes.get(i)).toMillis();
	}
	
	public void storeStartTime(LocalTime startTime) {
		this.startTimes.add(startTime);
	}
	
	public void storeEndTime(LocalTime endTime) {
		this.endTimes.add(endTime);
	}

}
\end{lstlisting}
\end{figure}


\end{document}