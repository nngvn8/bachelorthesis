\documentclass[preview]{standalone}
\input{prelude}


\begin{document}
\section{View Examples}
In this chapter we will introduce and discuss some \viewN examples created by the author. Their purpose is to understand the idea and concept of a \viewN and get to know some views that might be useful in real world applications. \\
When considering \viewsN we only want into account those that utilize properties of MDPs or that do computations that are also feasible on normal graphs but are of explicit relevance MDPs.
\subsection{Utilizing MDP components}
\redcomment{\viewsNC based on MDP components}
\subsubsection{Atomic Propositions}
The \emph{Atomic Propositions \viewNC} groups all states to a new state that have the same set of atomic propositions.

\begin{definition}	
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN. The view \viewatomicprops is defined by its grouping function \gfctatomicprops \grpfctN with $\gfctatomicprops : \states \to \imggrp, {\state}\mapsto{\labelingfct(\state)}$.
\end{definition}

The grouping function is exactly the labeling function i.e. for all $\state \in \states$ it is $\gfctatomicprops(\state) = \labelingfct(\state)$. So it is $\gfctatomicprops(\state_1) = \gfctatomicprops(\state_2) \iff \labelingfct(\state_1) = \labelingfct(\state_2)$. According to definition \ref{def:eqrelview} for $\smstate \in \states$ it is $\eqclassv{\smstate} = \{\state \in \states \mid \labelingfct(\state) = \labelingfct(\smstate)\}$.
%$\forall \state_1, \state_2 \in \states :

By this we obtain the \viewN $\viewatomicprops$ for a given transition system \ts where: $\states' = \bigcup_{\state \in \states} \{\eqclassv{\state}\} =  \bigcup_{a \in \atomicprops} \{\{\state \in \states \mid \labelingfct(\state) = a\}\}$. All other components are constructed as in definition \ref{def:view}.

\redcomment{tikz example}

\redcomment{example from the database of max}

\subsubsection{Initial States}
The \emph{Initial State \viewNC}  groups all initial states into one single state. All other states are left untouched.

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN. The view \viewinitstates is defined by its grouping function \gfctinitstates \grpfctN with $\gfctinitstates : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
		\emptyset,				& \text{if } \state \in \initstates \\
		\{\state\},          	& \text{otherwise}
	\end{cases}
	\]
	
	and $\imggrp := \{\emptyset\} \cup \{\{\state\} \mid \state \in \states\}$.
\end{definition}

For $\state_1,\state_2 \in \states$ it is $\gfctinitstates(\state_1) = \gfctinitstates(\state_2)$ \iffN $\state_1, \state_2 \in \initstates$ or $\state_1 = \state_2$. According to definition \ref{def:eqrelview} it is 
\begin{align*}
	\eqclassv{\state} &= \{\state \in \states \mid \grpfct(\state) = \emptyset\} &\text{for } \state \in \initstates \text{ and} \\
	\eqclassv{\state} &= \{\state \in \states \mid \grpfct(\state) = \{\state\} \} = \{\state\} &\text{for } \state \notin \initstates.
\end{align*}


By this we obtain the \viewN $\viewinitstates$ for a given \chosengraphtypeN \ts where: $\states' = \bigcup_{\state \in \states} \{\eqclassv{\state}\} = \{\state \in \states \mid \state \in \initstates\}\cup \bigcup_{\state \in \states \setminus \initstates}\{\{\state\}\}$.

All other components are constructed as in definition \ref{def:view}.

\subsubsection{Outgoing Actions}
\redcomment{define outgoing transition and outgoing action}
The \emph{OutAction View} groups states that share some property regarding their actions  of the outgoing transitions. Several variants are feasible. In the following we will use the expression "outgoing action \action" equivalent with "transition with outgoing action \action".

The most obvious variant to group states is to group states that \emph{have} a given outgoing action. 

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The view \viewhasoutaction is defined by its \grpfctN $\gfcthasoutaction : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state' \in \states: (\state, \action, \state') \in \redcomment{\transitionrel} \\
		\state,          	& \text{otherwise}
	\end{cases}
	\]
	
	and $\imggrp := \setoutact$.	
\end{definition}


For $\state_1,\state_2 \in \states$ it is $\gfcthasoutaction(\state_1) = \gfcthasoutaction(\state_2)$ \iffN 
there exist $\state_{a},\state_{b} \in \states$ with 
$(\state_1, \action, \state_{a}), (\state_2, \action, \state_{b}) \in \transitionrel$ (i.e. they have the same outgoing action \action) or $\state_1 = \state_2$. 
In accordance with definition \ref{def:eqrelview} it is
\begin{align*}
	\eqclassv{\state} &= \{\state \in \states \mid \gfcthasoutaction(\state) = \action\} &\exists\state' \in \states : (\state, \action, \state') \in \transitionrel \\
	\eqclassv{\state} &= \{\state \in \states \mid \gfcthasoutaction(\state) = \state\} = \{s\} &\text{ otherwise}
\end{align*}
 %if for all $\state' \in \states : (\state,\action,\state') \notin \transitionrel$.

Thereby we obtain the \viewN \viewhasoutaction for a given transition system \ts where $\states' = \bigcup_{\state \in \states} \{\eqclassv{\state}\} =: \states_1 \cup \states_2$ where
\begin{align*}
	 \states_1 &:= \{\state \in \states \mid \exists \state' \in \states: (\state, \action, \state') \in \transitionrel\} = \{\state \in \states \mid \state \text{ has outgoing action \action }\} \\
	\states_2 &:= \remstates.
\end{align*}


Since actions are a very important part of transition systems as well as of its more powerful siblings MDPs and MCs it seems useful to further enhance this view and look at variants of it. Instead of only grouping states that only \emph{have} outgoing actions we could also quantify the amount of times that action should be outgoing.

For example we could require that a given action has to be outgoing a minimum amount of times. 

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The view \viewminoutaction is defined by its \grpfctN $\gfctminoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state_1, \dots, \state_\numoutact \in \states:  \predminoutact\\
		\state,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \setoutact$, $\numoutact \in \natnums$ is the minimum amount of times a transition with action \action has to be outgoing in order to be grouped with the other states and
	\[
	\predminoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_\numoutact) \in \redcomment{\transitionrel}) \land |\{\state_1, \dots, \state_\numoutact\}| = \numoutact
	\]
	
	is a first order logic predicate.
	\label{def:minoutaction}
\end{definition}

The number  and  
The predicate \predminoutact requires that there are transitions with action \action to \numoutact distinct states.

For $\state_1,\state_2 \in \states$ it is $\gfctminoutaction(\state_1) = \gfctminoutaction(\state_2)$ \iffN there exist distinct $\state_{a_1}, \dots, \state_{a_\numoutact} \in \states$ and distinct $\state_{b_1}, \dots, \state_{b_\numoutact} \in \states$ so that $(\state_1, \action, \state_{a_1}), \dots, (\state_1, \action, \state_{a_\numoutact}) \in \redcomment{\transitionrel}$ and $(\state_2, \action, \state_{b_1}), \dots, (\state_2, \action, \state_{b_\numoutact}) \in \redcomment{\transitionrel}$ or $\state_1 = \state_2$. According to definition \ref{def:eqrelview} it is 
\begin{align*}
	\eqclassv{\state} &= \{\state \in \states \mid \gfctminoutaction(\state) = \action\} &\text{if } \predminoutact \\ 
	\eqclassv{\state} &= \{\state \in \states \mid \gfctminoutaction(\state) = \state\} = \{\state\} &\text{ otherwise}
\end{align*}

By this we obtain the \viewN $\viewminoutaction$ for a given transition system \ts where $\states' = \bigcup_{\state \in \states} \{\eqclassv{\state}\} =: \states_1 \cup \states_2$ where 

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact\} \\ %(\state, \action, \state_1), \dots, (\state, \action, \state_\numoutact) \in \redcomment{\transitionrel}, |\{\state_1, \dots, \state_\numoutact\}| = \numoutact\} \\ 
	&\hspace{1.15mm}= \{\state \in \states \mid \text{the action } \action \text{ is outgoing at least } \numoutact \text{ times} \} \text{ and} \\
	\states_2 &:= \remstates.	
\end{align*}

In a similar fashion we define view that groups states where at most a certain number of times a given action is outgoing. 

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The view \viewmaxoutaction is defined by its \grpfctN $\gfctmaxoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
		\state,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \states$, $\numoutact \in \natnums$ is the maximal number of times a transition with action \action may be outgoing and 
	\[
	\predmaxoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_{\numoutact+1}) \in \redcomment{\transitionrel}) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numoutact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
	\label{def:viewmaxoutaction}
\end{definition}

 It ensures that if there are one more than \numoutact outgoing transitions with an action \action at least two of the states where the transitions \redcomment{end} are in fact the same. Since this is required for all possible combinations of $\numoutact + 1$ states by the grouping function, only states that have at most \numoutact outgoing actions will be assigned with \action by the grouping function. The reasoning about the equality of the \grpfctN values, the obtained equivalence classes and the resulting set of states $\states'$ of the view is analogous to \viewminoutaction.

Since we already defined \grpfctsN and hence views for a required minimal and maximal amount of times an action has to be outgoing it is now easily possible to define a view that groups states where the amount of outgoing actions is at least \numoutact and at most \numoutactb. 

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The view 
	\viewspanoutaction is defined by its \grpfctN $\gfctspanoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
		\state,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \states$ and $\numoutactb, \numoutact \in \natnums$ are the minimal and maximal number of transitions with action \action in order for state to be grouped. The predicates \predminoutact and \predmaxoutact are the predicates from the definitions \ref{def:minoutaction} and \ref{def:viewmaxoutaction} respectively.
\end{definition}

We already know that for a given $\state \in \states$ the expressions $\exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact$ and $\forall \state_1, \dots, \state_{\numoutactb+1} \in \states: \predmaxoutact[\numoutactb]$ from the definitions \ref{def:minoutaction} and \ref{def:viewmaxoutaction} require that \state has minimal and maximal amount of outgoing transitions with an action \action respectively. Hence the conjunction will be true for states where the amount of outgoing transitions with action \action is element of the set $\{\numoutactb, \numoutact+1, \dots, \numoutact-1, \numoutact\}$. We will write for this that the number of outgoing actions is \emph{in the span}.

For a given state \state and action \action we set
\[
\formoutact:= \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb]\land \\
\forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact
\]

for convenience. \formoutact is true  \iffN the number of outgoing actions is in the span. For $\state_1, \state_2 \in \states$ it is $\gfctspanoutaction(\state_1) = \gfctspanoutaction(\state_2)$ \iffN $\formoutact[\state_1] \land \formoutact[\state_2]$ or $\state_1 = \state_2$. Then its equivalence classes are

\begin{align*}
	\eqclassv{\state} &= \{\state \in \states \mid \gfctspanoutaction(\state) = \action\} &\redcomment{\text{ for } \state \in \states} \text{ and } \formoutact \text{ true} \\
	\eqclassv{\state} &= \{\state \in \states \mid \gfctspanoutaction(\state) = \state\} = \{\state\} &\text{ otherwise}	
\end{align*}

The new set of states $\states'$ of the view \viewspanoutaction is the union of the equivalence classes of equivalence relation \eqrelview on the set of states \states of the original transition system. Hence it is $\states' = \bigcup_{\state \in \states} \eqclassv{\state} =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \gfctspanoutaction(\state) = \action\} \\
	&\hspace{1.15mm}= \{\state \in \states  \mid \formoutact \text{ true}\} \\
	&\hspace{1.15mm}= \{\state \in \states \mid \text{the action } \action \text{ is outgoing } \numoutactb \text{ to } \numoutact \text{ times}\} \text{ and} \\
	\states_2 &:= \remstates.
\end{align*}

\redcomment{The views above could be expanded to several actions with requirements}

Instead of making requirements about states and group them based on whether they meet these requirements it also possible to group states that are very similar or even identical in regard to their outaction. We consider this idea with the \emph{\outactident \viewNC} in two variants: \outactidentstrong and \outactidentweak (idententiy). Firstly we will consider the variant of strong identity.

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The \viewN \viewstrongoutactident is defined by its \grpfctN $\gfctstrongoutactident : \states \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numoutact) \mid \action \in \actions, \numoutact \text{ is the number of times that \action is outgoing from } \state\}
	\]
	and $\imggrp := \actions \times \natnums_0$.
\end{definition}

The \grpfctN asserts to each state a set of pairs. Note that a pair is contained int the set for each action $\action \in \actions$. In case there is no outgoing transition from state \state with an action \action it is $(\action, 0) \in \gfctstrongoutactident$. For $\state_1, \state_2 \in \states$ it is $\gfctstrongoutactident(\state_1) = \gfctstrongoutactident(\state_2)$ \iffN $\state_1$ and $\state_2$ are mapped to the same set of pairs. By definition \ref{def:eqrelview} the obtained equivalence classes of \eqrelview are
\[
	\eqclassv{\state} := \{\state \in \states \mid \gfctstrongoutactident(\state) = \{(\action_1, \numoutact_1), \dots, (\action_l, \numoutact_l)\}, l = |\actions|\}
\]
According to definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv{\state}$ is the set of states of \viewstrongoutactident. All other components of \viewstrongoutactident are as usual structured in accordance with the definition \ref{def:view}.
As mentioned earlier a \outactidentweak variant of the \outactident \viewN is also conceivable.

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The \viewN \viewweakoutactident is defined by its \grpfctN $\gfctweakoutactident : \states \to \imggrp$ with
	\[
	\state \mapsto \{\action \in \actions \mid \exists \state' \in \states : (\state, \action, \state') \in \transitionrel\} 	
	\]
	and $\imggrp := \actions$.
\end{definition}
\redcomment{condition of image-set written in inconsistent style to strong identity. Swap strong and weak (order)?}

\redcomment{The grouping function maps to the set of outgoing actions of a state and thereby discards information about the number of times an actions is outgoing. If an action is not outgoing from a state it is not contained in the set.}

For $\state_1, \state_2 \in \states$ it is $\gfctweakoutactident(\state_1) = \gfctweakoutactident(\state_2)$ \iffN they are mapped to the same set of actions. Hence the equivalence classes of \eqrelview are
\[
	\eqclassv{\smstate} = \{ \state \in \states \mid \gfctweakoutactident(\state) = \gfctweakoutactident(\smstate) =: \{\action_1, \dots, \action_l\}, l \in \natnums\}.
\]
According to definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv{\state}$ is the set of states of \viewweakoutactident.

\subsubsection{Ingoing Actions}
Analogously to Outgoing Actions views of utilizing ingoing actions are feasable. Since there is no difference apart from the definitions itself, we only provide the definitions.

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The view \viewhasinaction is defined by its \grpfctN $\gfcthasinaction : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state' \in \states: (\state', \action, \state) \in \redcomment{\transitionrel} \\
		\state,          	& \text{otherwise}
	\end{cases}
	\]
	
	and $\imggrp := \actions \cup \states$.	
	\label{def:mininaction}
\end{definition}	


\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The view \viewmininaction is defined by its \grpfctN $\gfctmininaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state_1, \dots, \state_\numinact \in \states:  \predmininact\\
		\state,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \states$, $\numinact \in \natnums$ is the minimum amount of times a transition with action \action has to be ingoing in order to be grouped with the other states and
	\[
	\predmininact := ((\state_1, \action, \state), \dots, (\state_\numinact, \action, \state) \in \redcomment{\transitionrel}) \land |\{\state_1, \dots, \state_\numinact\}| = \numinact
	\]
	is a first order logic predicate.
	\label{def:viewmaxinaction}
\end{definition}

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The view \viewmaxinaction is defined by its \grpfctN $\gfctmaxinaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
		\state,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \states$, $\numinact \in \natnums$ is the maximal number of times a transition with action \action may be ingoing and 
	\[
	\predmaxinact := ((\state_1, \action, \state), \dots, (\state_{\numinact+1}, \action, \state) \in \redcomment{\transitionrel}) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numinact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
\end{definition}

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The view 
	\viewspaninaction is defined by its \grpfctN $\gfctspaninaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state_1, \dots, \state_\numinactb \in \states: \predmininact[\numinactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
		\state,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \states$ and $\numinactb, \numinact \in \natnums$ are the minimal and maximal number of transitions with action \action in order for state to be grouped. The predicates \predmininact and \predmaxinact are the predicates from the definitions \ref{def:mininaction} and \ref{def:viewmaxinaction} respectively.
\end{definition}

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The \viewN \viewstronginactident is defined by its \grpfctN $\gfctstronginactident : \states \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numinact) \mid \action \in \actions, \numinact \text{ is the number of times that \action is ingoing from } \state\}
	\]
	and $\imggrp := \actions \times \natnums_0$.
\end{definition}

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN and $\action \in \actions$. The \viewN \viewweakoutactident is defined by its \grpfctN $\gfctweakoutactident : \states \to \imggrp$ with
	\[
	\state \mapsto \{\action \in \actions \mid \exists \state' \in \states : (\state, \action, \state') \in \transitionrel\} 	
	\]
	and $\imggrp := \actions$.
\end{definition}

\subsubsection{Parameters}
The concept of parameters is not part of the definitions of neither transition systems, MCs or MDPs. Even though, it is of great importance in practical applications. Parameters are used to represent states (in more detail). 

For example a MDP could be used to model a computer program with human interaction. Every state of the MDP refers an overall state of the program during execution time. In this state of the program, its variables will have specific values. Instead of only assigning a state $\state \in \states$ that refers to the state of the program, we want to retain the information about the values of the variables of the program. There is no component in MDPs that fullfills this purpose. Variables and its current values are not only relevant to computer programs but also other systems. Many of those other systems rely on some kind of global state during execution, which can be expressed with variables and values assigned to them. Parameters are used to store this information.

\redcomment{OLD: Since transitions systems MCs and MDPs in practice are used to model, analyze and check real world systems it is very practical to not only name states but also describe the properties of the state in more detail. For a basic notion parameters are to be imagined as a set of variables that may have different values in different states thereby describing the characteristics of the state more thoroughly. \purpcomment{ADDED: In practice most often they arise very naturally for example as variables of a computer program that is to be modeled with a MDP.}} 

Because of the vast importance in practical applications we will consider some \viewsN that utilize them. To do so and being able to describe them formally we define we will formalize the notion of parameters by considering them as a subset of the atomic propositions \atomicprops that is assigned a value by a function.

\begin{definition}
	The set $\params \subseteq \atomicprops$ is called \emph{parameters}.
\end{definition}

\begin{definition}
	Let \paramevalimg be an arbitrary set. The function $\parameval : \states \times \params \to \paramevalimg$ is called parameter evaluation function.
\end{definition} 

Most of the time we will use \parameval to refer to the parameter evaluation function. When we speak about the value of a parameter in a state we refer to the image of $\parameval$ for that state and value. The set \paramevalimg is arbitrary so that arbitrary values can be assigned to a parameter. Speaking in terms of computer science and programming this loosens as an example the restriction of only being able to assign numbers and no booleans.

The most apparent idea for a \viewN utilizing parameters is to group states that meet some requirement regarding the values of the parameters.

\redcomment{state has parameter not here uptil now because probably not used}

\begin{definition}
	Let
	\begin{itemize}
		\item $\ts = \transitionsystem$ be a \chosengraphtypeN,
		\item $\param \in \params \subseteq \atomicprops$ and 
		\item $\parameval(\state, \param) = \paramval$ where $\state \in \states$.		
	\end{itemize} 
	The view \viewparamvalueseq is defined by its \grpfctN $\gfctparamvalueseq : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
		\paramval, &\text{if } \parameval(\state, \param) = \paramval\\
		\state, 	&\text{otherwise}
	\end{cases}
	\]
	where $\imggrp := \states \cup \{a\}$.
\end{definition}

The view \viewparamvalueseq groups states that share the same value for a given parameter. For $\state_1, \state_2$ it is $\gfctparamvalueseq(\state_1) = \gfctparamvalueseq(\state_2)$ \iffN $\parameval(\state_1, \param) = \parameval(\state_2, \param)$ or $\state_1 = \state_2$. The obtained equivalence classes are
\begin{align*}
	\eqclassv{\state} &= \{\state \in \states \mid \parameval(\state, \param) = \paramval\} \\
	\eqclassv{\state} &= \{\state \in \states \mid \gfctparamvalueseq(\state) = \state\} = \{\state\}
\end{align*}

The set of states $\states'$ of \viewparamvalueseq is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv{\state} =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \gfctparamvalueseq(\state) = \paramval\} \\
	&\hspace{1.15mm}= \{\state \in \states  \mid \parameval(\state, \param) = \paramval\} \text{ and} \\
	\states_2 &:= \remstates.
\end{align*}

Analogously a view that requires inequality instead of equality is feasible.

\begin{definition}
	Let
	\begin{itemize}
		\item $\ts = \transitionsystem$ be a \chosengraphtypeN,
		\item $\param \in \params \subseteq \atomicprops$ and 
		\item $\parameval(\state, \param) \neq \paramval$ where $\state \in \states$.		
	\end{itemize} 
	The view \viewparamvaluesneq is defined by its \grpfctN $\gfctparamvaluesneq : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
		\paramval, &\text{if } \parameval(\state, \param) \neq \paramval\\
		\state, 	&\text{otherwise}
	\end{cases}
	\]
	where $\imggrp := \states \cup \{a\}$.
\end{definition}

If states are to be grouped with the requirement of several parameters equaling or not equaling specified values this can be achieved by using \parllcompN. 
\redcomment{Insert disjunctive normal form with text, cnf without}

The view above reduces the \chosengraphtypeN in a very precise but also manual manner, because it not only dictates the parameter but also its value. A more general approach is to stipulate only the parameter but not its value. This way states will be grouped that have the same value for that parameter with no regard to the actual value of that parameter. This idea could be achieved with a view based on the \grpfctN $\grpfct_{\gfctparamvalueseqopt[\paramval_1] \pll \dots \pll \gfctparamvalueseqopt[\paramval_n]}$ with $\redcomment{\parameval(\states, \param)} = \{\paramval_1, \dots, \paramval_n\}$ and $|\parameval(\states,\param)| = n$. This grouping function just groups on every possible value for the parameter \param. Since this is \redcomment{not very practical} we define a view that achieves this result in a more direct and more efficient way.

\begin{definition}
	Let $\ts = \transitionsystem$ be a \chosengraphtypeN. The view \viewparamvalident is defined by its \grpfctN $\gfctparamvalident : \states \to \imggrp$ with
	\[
	\state \mapsto \parameval(\state,\param)
	\]
	and $\imggrp := \parameval(\states, \param)$.
\end{definition}

With this grouping function we directly map to the value of the parameter. Hence for $\state_1, \state_2 \in \states$ it is $\gfctparamvalident(\state_1) = \gfctparamvalident(\state_2)$ \iffN they are mapped to the value $\paramval \in \imggrp$. Hence the equivalence classes of \eqrelview are
\[
\eqclassv{\smstate} = \{ \state \in \states \mid \parameval(\state) = \parameval(\smstate)\}.
\]
According to definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv{\state}$ is the set of states of \viewparamvalident.

\subsubsection{Distance}
\subsection{Computation on MDP-Graph}




\subsection{Comparison of the Examples}
\end{document} 
