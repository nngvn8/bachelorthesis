\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}

\begin{document}
\section{Introduction}
	
The modern world relies heavily on information and communication technology (ICT) systems. They are found in devices used everyday like smartphones or laptops or in distributed systems such as the infrastructure sustaining the internet, but also in life-saving ones utilized in medicine. In addition to performance, features, and functionality, one of the most important aspects of such systems is their fault-free behavior during runtime. The impact of a system failure can range from a small disturbance in the user experience to the inoperability of the entire system, which could result in an annoyed user, millions of dollars in financial damage, or a lost life. To prevent these potentially severe negative effects, methods are needed to verify the correct behavior of a system.

In addition to commonly used approaches such as peer review and testing for software and emulation and simulation for hardware, formal methods can also be used to verify the correct behavior of a system. 
These can be based on models, where a state in the model refers to a possible state of the system. Models describe the possible system behavior in a mathematically precise and unambiguous manner and can be used for verification in different ways: the state space can be explored exhaustively, only certain scenarios can be considered, or they are tested in reality.

Model checking describes the approach of exhaustive exploration of the state space. It is a formal model-based method for system verification, that checks in an automated manner if a given property holds for every state of a given finite-state model. \cite[chs. 1.1 and 1.2]{Baier2008}. Probabilistic model checking allows not only nondeterministic transitions between states in the models checked, but also probabilistic ones. It enables to properly model and check systems in which both controllable, as well as stochastic phenomena are occurring. The main limitation for algorithms that run on the set of states of models to model check them is the state explosion issue. The state explosion issue states that the number of states grows exponentially with the number of variables in a program graph or with the number of components in concurrent systems \cite[ch. 2.3]{Baier2008}. Even simple system models can lead to complex system behavior and an immense number of states. This is not only a issue for algorithms, but also for humans who need to understand, analyze, and verify models in the context of model checking. An interactive visualization can assist with this issue and even be made use of to achieve further goals such as debugging or model repair. 

There are techniques in visualization for large multivariate graphs (networks where nodes and relationships have attributes), such as \mdpsN. Aggregation and clustering methods are used in visualization for \emph{large} graphs\cite{Goerke2009}. There also exist methods for visualizing \emph{multivariate} graphs \cite{Kerren2014,Nobre2019}. One approach for visualizing multivariate graphs are multiple coordinated view setups featuring parallel coordinate plots (PCPs) \cite{Johansson2016}. However, even these techniques in visualization have their limitations for very large amounts of data as they are easily reachable with models used in model checking. The pure data volume remains unaffected. One could address this issue by reducing the amount of data that is passed to the visualization. This is the goal of this thesis: to preprocess the data that is then used in the visualization.

%In this thesis we want to preprocess data, that is then utilized in visualization. 
Preprocessing is a term that describes an approach mostly used in data mining and machine learning. Common problems are too much data, too little data, and imperfect data (noise, incompleteness)\cite{Garcia2016}. Preprocessing addresses these issue. As the state explosion problem causes an immense amount of states, approaches that reduce the amount of data are of interest. Methods reducing data can refer to the size of single samples (feature selection, space transformations) or the amount of samples (instance reduction). There are several methods to reduce the number of instances. The approach that will be explored in this thesis can be classified as instance reduction and can be considered as a variant of clustering, although in literature clustering can describe slightly different notions \cite{Alasadi2017,Baskar2013}.

Whereas these approaches are general in the sense that they concern arbitrary datatypes, the representations of \mdpsN are graphs, which have been heavily studied in the last decades. In consequence, there exist many approaches to simplifying graphs. There are simplifications based on the pure mathematical object, without any domain-specific context, such as connectivity \cite{Zhou2010}, patterns\cite{Soldano2014}, modularity \cite{Arenas2007} or cuts \cite{Goerke2009,Fung2011}. There also exist methods specific to certain domains \cite{Ruan2011,Li2022,Yaw2019}. In this thesis we want to explore approaches specific to the domain of model checking. Approaches found in literature aim at preserving certain logic formulae or the ability to perform proper verification on the simplified graph \cite{Rensink2012,Bonchi2013,Boneva2007}. An interesting model checking specific approach is based on equivalence or order relations on the set of states. States are in relation if they can simulate each other step by step or in several steps with respect to atomic propositions. This causes preservation of certain logical formulae used in model checking, but conversely other information is lost. In addition, the computation of these relations is rather costly. We will introduce and provide an implementation of a concept called \viewN, which is similar to abstraction \cite[p. 499]{Baier2008}. It defines an equivalence relation on the set of states that share certain properties. Its intention is to show humans interacting with the visualization as much information as possible in a compact and concise form, rather than preserving logical formulae.

After giving some fundamentals about the systems where the concept \viewN may be applied in chapter \ref{ch:prelim}, we will formalize \viewsN, discuss types and operations on and with them in chapter \ref{ch:view}. In chapter \ref{ch:viewexmp} we will give examples of views utilizing \chgphN characteristics and \viewsN utilizing the structure of the \chgphN graph, but for this bachelor thesis limit the scope of views considered to those, that do not take advantage of probabilities in \chgphsN. In chapter \ref{ch:viewimpl} we will elaborate where and how the \viewsN proposed in chapter \ref{ch:viewexmp} have been implemented. Lastly the \viewsN will be evaluated in chapter \ref{ch:eval} by considering three use cases how \viewsN can be applied and used. An overview of the performance and scalability of the proposed \viewsN is also given. 

%\begin{itemize}
%	
%	\item Fung sparsification - no domain specific
%	\item Zhung connectivity
%	\item Soldano Patterns topological constraint in Graphs - no domain specific
%	\item Arena - module
%	\item Ruansen Maintain shortest path
%	\item Yaw2019 simplifcation for networks
%	\item Li2022 Dyck reachability
%	\item Bonchi2013 activity traces + general appraoches
%	\item Boneva edge labeling, neighbourhood,  preservance of formulae
%	\item Resink Verification of infinite graphs on abstract level using patterns
%	
%\end{itemize}

\end{document}
