\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}

\begin{document}
\section{Introduction}
	
The modern world heavily relies on ICT (Information and Communication Technology) systems. They are found in devices used everyday like smartphones or laptops or in distributed systems such as the infrastructure sustaining the internet, but also in live saving ones utilized in medicine. Apart from performance, provided features and functionality, one of the most relevant aspects of such systems is their faulty free behavior, when active or running Although desirable many people have personal experience with such systems not behaving as expected, what is commonly referred to as a bug. These can reach from a small disturbance in the user experience to inoperability of the whole system. Depending on the system the impact could be an annoyed user or financial damage of several millions. To prevent these possibly severe negative effects, methods to verify the correct behavior of a system are needed.

%In practice peer review and testing account to the most popular verification techniques to verify software. Peer review struggles with finding subtle errors while testing only enables to show the presence of errors but not their absence. One approach to verify hardware is by emulate it. This means using reconfigurable generic hardware (emulator) so that it behaves like the hardware that is to be verified. It can made used of to test whether for specific inputs the resulting outputs meet the expected one. The notion is similar to testing software, and yields the same disadvantage to only show for certain cases if the system behaves correctly.

Apart from in practice often used approaches like peer review and testing for software and emulation and simulation for hardware, formal methods can be used as well to verify the correct behavior of a system. One category within formal verification techniques are model based approaches. As the name suggests they are based on models describing the possible system behavior in a mathematically precise and unambigous manner. A state in the model refers to a possible state of the system. These models can be utilized various ways: the state space can be explored exhaustively, only specific scenarios can be considered or they are tested in reality.

Model checking describes the approach of exhaustive exploration of the state space. It is a formal model-based method for system verification. In precise terms, model checking is an automated technique, to check if a given property holds for every state of a given finite-state model. \cite[chs. 1.1 and 1.2]{Baier2008}. Probabilistic model checking allows not only nondeterministic transitions between states in the models checked, but also probabilistic ones. It enables to properly model and check systems in which also stochastic phenomena are occurring. The major limitation for algorithms running on the set of states of models, in order to model check them, is the state explosion problem. The state explosion problem states that the number of states grow exponentially in the number of variables in a program graph or the number of components in concurrent systems \cite[ch. 2.3]{Baier2008}. Already simple system models can lead to complex system behavior and an immense amount of states. This is not only a problem for algorithms but also humans who need to understand, analyze and review models in the context of model checking. An interactive visualization can assist with this issue and even be made use of to achieve further goals such as debugging or model repair. However, the pure data volume is left unaffected. There are visualization techniques \redcomment{more detail to be inserted} for multivariate networks (networks where nodes and relationships have attributes) which can be used for larger amounts of data. But even these perform poorly for very large amounts of data as they are easily achievable with models used in model checking \cite{Kerren2014,Nobre2019}. 

There is graph abstraction (in Visualization) but we wont look further into that \redcomment{more detail to be inserted}

Moreover they represent approaches that are not specific to the domain. In this thesis we want to explore approaches that use domain specific information and knowledge to preprocess data, that is then utilized for visualization. Preprocessing is an approach to clean up and prepare data for Data Mining and Machine Learning. The goal is to prepare so that they meet the requirements in order for algorithms being able to analyze them. To achieve that data is reduced if there is too little, inferred if there is not sufficient or cleaned if it includes noise or errors. Since the state explosion problem causes an immense amount of states approaches that reduce the amount of data are of interest. Methods reducing the amount of data either reduce the size of a single sample (feature selection), reduce the amount of samples (data elimination) or cluster samples to one single sample (data selection)\cite{Famili1997,Garcia2016}. The approach that will be explored in this thesis falls in the category of data selection. \redcomment{insert more related work}

Apart from \redcomment{related work} there exist domain specific approaches to simplify \mdpsN. One approach is partial order reduction, the idea of which is to reduce the state space omitting states and transitions that will cause the same effect. There may be transitions representing operations that are independent and hence the order does not matter. That is why the notion is to only include a single ordering in the model, rather than all of them. While the motivation for this approach lies in to reduce the effort needed to model check these systems. \redcomment{I could have used this for views but did not really know about it... do not know how to make a good transition. I think I should mention it here.}

Another domain specific approach for simplification is based on equivalence or order relations on the set of states. States are in relation, if they can simulate each other stepwisely or in several steps with respect to atomic propositions, where atomic propositions are to be understood as an atomic property for that holds in a state. The ability to simulate another state with respect to the atomic propositions, causes preservation of certain logical formulae used in model checking. Although certain logical formulae and hence model checking properties are preserved other information is lost. In addition the computation of these computations is rather costly. We will introduce a concept, which will be called \viewN, that is very similar to abstraction \cite[pp. 499]{Baier2008}, but without permanently losing on information. Moreover, its intention is to show humans interacting with the visualization as much information possible in compact and concise form, rather than preserving logical formulae.

After giving some fundamentals about the systems where the concept \viewN may be applied in chapter \ref{ch:prelim} we will formalize \viewsN, discuss types and operations on and with them in chapter \ref{ch:view}. In chapter \ref{ch:viewexmp} we will give examples of views utilizing \chgphN components, \viewsN utilizing the \chgphN structure and \viewsN utilizing results of model checking. For this thesis the scope of views considered is limited to those that do not take advantage of the probabilities in \chgphsN. In chapter \ref{ch:viewimpl} we will elaborate on where and how the proposed \viewsN of chapter \ref{ch:viewexmp} have been implemented. Lastly the \viewsN will be evaluated in chapter \ref{ch:eval} by considering three usecases how \viewsN can be applied and used. Moreover there will be an overview about performance and scalability of the proposed \viewsN. 

\end{document}
