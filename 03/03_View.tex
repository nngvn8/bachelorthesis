 
\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}


\begin{document}
	
\section{View}  \label{ch:view}

In this chapter we will introduce the core concept of this thesis, which will be called view. The notion of a view is to obtain a simplification of a given \mdpN. It is an independent \mdpN derived from a given \mdpN and represents a (simplified) view on the given one - hence the name. Thereby the original \mdpN is retained.

In the preliminaries transition systems and Markov Chains were listed as simpler version of \mdpsN. Roughly speaking transition systems and \mdpsN are special \mdpsN namely that have no probability distribution in each state for each action or no actions. When defining \viewsN it seems feasible to do so for the most general system of the ones of consideration.That is why we will define views on \mdpsN. Only for specific views and their implementation it is to be kept in mind that if they regard an action or the probability distribution of an action in a state it is not applicable to transitions systems or MCs respectively.

\subsection{Grouping Function}
The conceptional idea of a \viewN is to group states by some criteria and structure the rest of the system accordingly. To formalize the grouping we define a dedicated function.

\begin{definition}
	Let \smstates and \arbset be arbitrary sets with $\remelem \in \arbset$. The function $\grpfctsub : \smstates \to \imggrp$ is called \emph{\grpfctsubN}, where the symbol \viewppty is an unique identifier.
	
	\label{def:grpfctsub}
\end{definition}


\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\grpfctsub : \smstates \to \imggrp$ a detached grouping function where $\smstates \subseteq \states$. The function $\grpfct : \states \to \imggrp$ with	
	
	\[
	\state \mapsto
	\begin{cases}
		\tilde\grpfct(s),				& \text{if } \state \in \smstates \\ 		\remelem,          	& \text{otherwise}
	\end{cases}
	\]	
	is called \emph{\grpfctN}. The symbol \viewppty is an unique identifier.
	
	\label{def:grpfct}
\end{definition}



The \grpfctsubN is used to formalize the behavior that groupings can also only be defined on a subset of states, while still obtaining a total function on the set of states \states. We write $M(\grpfct)$ and $M(\grpfctsub)$ to refer to the their codomain of \grpfct and \grpfctsub respectively. The identifier \viewppty normally hints the objective of the grouping function. Two states will be grouped to a new state if and only if the grouping function maps them to the same value if that value is not the unique symbol \remelem. The mapping to the symbol \remelem will be used whenever a state is supposed to be excluded from the grouping. The definition offers an easy way of creating groups of states. It is also very close to the actual implementation later on. The exact mapping depends on the desired grouping. In order to define a new set of states for the \viewN, we define an equivalence relation \eqrelview based on a given grouping function \grpfct.

\begin{definition}
	Let $\nogroupset := \{\remelem\} \cup \bigcup_{n \in \natnums \setminus \{0\}} \{t \in \{\remelem\}^{n+1}\}$.
\end{definition}

With this definition it is $\nogroupset = \{\remelem, (\remelem, \remelem), (\remelem, \remelem, \remelem), \dots\}$ an infinite set. That is, it contains every arbitrary sized tuple only containing the symbol \remelem. This generalization to arbitrary large tuples with \remelem is needed for composition in section \ref{ch:composition}.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and \grpfct a grouping function. We define the equivalence relation $\eqrelview :=\{ (\state_1, \state_2) \in \states \times \states \mid \grpfct(\state_1) = \grpfct(\state_2) \notin \nogroupset\} \cup \{(\state, \state)  \mid \state \in \states\}$
	
	\label{def:eqrelview}
\end{definition}

\eqrelview is an equivalence relation because it is reflexive, transitive and symmetric. \eqrelview is reflexive because $\{(\state, \state)  \mid \state \in \states\} \subseteq \eqrelview$. Thus for all states \state it is $(\state, \state) \in \eqrelview$. Therefore for the properties transitivity and symmetry we only consider distinct $\state_1, \state_2 \in \states$. Consider $(\state_1, \state_2) \in \states \times \states$. If $\grpfct(\state_1) \in \nogroupset$, then it is either $\grpfct(\state_2) = \grpfct(\state_1) \in \nogroupset$ or $\grpfct(\state_2) \neq \grpfct(\state_1)$. In both cases it follows from definition of \eqrelview that $(\state_1, \state_2) \notin \eqrelview$. If $\grpfct(\state_2) \in \nogroupset$ it directly follow from the definition of \eqrelview that $(\state_1, \state_2) \notin \eqrelview$. So for  $\grpfct(\state_1) \in \nogroupset$ or  $\grpfct(\state_2) \in \nogroupset$ it follows that $(\state_1, \state_2) \notin \eqrelview$. Hence when considering transitivity and symmetry we assume $\grpfct(\state_1), \grpfct(\state_2) \notin \nogroupset$. If $\grpfct(\state_1) = \grpfct(\state_2)$ it is obviously also $\grpfct(\state_2) = \grpfct(\state_1)$, which means if $(\state_1, \state_2) \in \eqrelview$ it follows that $(\state_2, \state_1) \in \eqrelview$. Hence \eqrelview is symmetric. The property directly conveyed from equality. In the same way transitivity directly conveys from the equality relation to \eqrelview.

We observe that two states $\state_1, \state_2$ are grouped to a new state if and only if $(\state_1, \state_2) \in \eqrelview$. This is the case if and only if $\state_1, \state_2 \in \eqclassv[\state_1] = \eqclassv[\state_2]$ where $\eqclassv[\state_i]$ for $i \in \natnums$ denotes the respective equivalence class of \eqrelview, i.e. $\eqclassv[\smstate] := \{\state \in \states \mid (\state,\smstate) \in \eqrelview\}$. \eqclasssetv denotes the set of all equivalence classes of \eqrelview, i.e. $\eqclasssetv := \bigcup_{\state \in \states}\{\eqclassv\}$.

\subsection{Formal Definition}

The definition of a \viewN is dependent on a given MDP and a \grpfctN $\grpfct$. We derive the equivalence relation \eqrelview as in Definition \ref{def:eqrelview} and use its equivalence classes \eqclassv ($\state \in \states$) as states for the \viewN. The rest of the \chgphN is structured accordingly.


\begin{definition}
	
	Let \chgph = \chgphtuple be \chgphN, $\smstates \subseteq \states$ and $\grpfct$ a \grpfctN where $\grpfctsub : \smstates \to \imggrp$ it its detached \grpfctN. A \emph{\viewN} is \achgphN $\view = \chgphtupledist$ that is derived from \mdp with the \grpfctN $\grpfct$ where
	
	\begin{itemize}
				\item $\states' = \{ \eqclass{\state}{\eqrelview} \mid \state \in \states \} = \eqclasssetv$
				%\eqclass{s}
				
				\item $\actions' = \actions$
				
				%\redcomment{\item $\trans' = \{ (\eqclassv[\state_1], \action, \eqclassv[\state_2]) \mid \exists \state_1 \in \eqclassv[\state_1] \exists \state_2 \in \eqclassv[\state_2] : (\eqclassv[\state_1], \action, \eqclassv[\state_2]) \in \trans\}$}%\subseteq \states' \times \actions' \times \states'$
				
				\item $\probtfunc : \eqclasssetv \times \actions \times \eqclasssetv \to [0,1]$ with 
				\[ 
				\probtfunc'(\eqclassv[\state_1], \action, \eqclassv[\state_2]) = 
				\frac
				{\bbigsum{\substack{\state_a \in \eqclassv[\state_1], \\ \state_b \in \eqclassv[\state_2]}}\probtfunc(\state_a, \action, \state_b) }
				{
%					\bbigsum{\state_x \in \eqclassv[\state_1], \state_y \in \states} \probtfunc(\state_x, \action, \state_y)
					\max\{|\{\state \in \eqclassv[\state_1] \mid \outacts(\state) = \action\}|, 1\}
					}
				\]
				
				%\{\eqclassv[\state'] \in \states' \mid \exists \state \in \eqclassv[\state'] : \state \in \init \}$
				
				\item $\initdistrib' : \eqclasssetv \to [0,1]$ with 
				\[
				\initdistrib'(\eqclassv) = \bbigsum{\state' \in \eqclassv} \initdistrib(\state')
				\]
							
				\item $\labelingfct': \states' \to \powerset{\atomicprops}, \eqclassv[\state] \mapsto \bigcup_{\state' \in \eqclassv} \labelingfct(\state')$
				
			\end{itemize}
	and \eqrelview is the equivalence relation according to Definition \ref{def:eqrelview}.
	

	\label{def:view}	
\end{definition}

The identifier \viewppty is inherited from $\grpfct$ to \view. The identifier declares that $\grpfct$ is the \grpfctN of \view and thereby also uniquely determines \view. If \smstates is not provided when instantiating a view it is assumed $\smstates = \states$. If a \viewN takes parameters and we want to talk about an instance of a \viewN with specific parameters $p_1, \dots, p_n$ we will write it as $\view(p_1, \dots, p_n)$. If we want to talk about the \grpfctN \grpfct of \view with the parameters $p_1, \dots, p_n$. We write $\grpfct(\state \cond p_1, \dots, p_n)$, where $\state \in \states$ and \states is the state set of \chgph. 

The definition of $\trans'$ is as is, because a state in a \viewN is an equivalence class and it may be that in it there are several states with the same outgoing action. Hence, summing up the probabilities for two given equivalence classes and action \action may yield a value greater than one (no probability anymore). This is why the sum of  probabilities has to be normalized, by dividing by the number of states that have the action \action outgoing. 

Note that the definition is in a most general form in the sense that if in a \viewN a property accounts to one piece of some entity the whole entity receives the property i.e. 
\begin{itemize}	
	\item $(\state_1, \action, \state_2) \in \trans \impr (\eqclassv[\state_1], \action, \eqclassv[\state_2]) \in \trans'$
	\item $\state \in \init \impr \eqclassv \in \initdistrib'$
	\item $\forall \state \in \states : \labelingfct(\state) \subseteq \labelingfct'(\eqclassv)$
	%	$\labelingfct(\state) =: \atomicprop \impr \atomicprop \in \labelingfct(\eqclassv)$
\end{itemize}

\begin{exmp}
To clarify the concept we will consider a \viewN \view on the \mdpN \mdp with $\states = \{\state_1, \dots, \state_6\}$ in Figure \ref{fig:exampleMdp}. The \view \viewN is defined by its grouping function \grpfct where $\grpfctsub : \smstates \to \imggrp$ with 

\begin{table}[h]
	\centering
	\begin{tabular}{c|c}
		States & $\grpfct(\state_i)$\\
		\hline
		$\state_1$ & $1$\\
		$\state_3$ & $1$\\
		$\state_4$ & $2$\\
		$\state_5$ & $2$\\
		$\state_6$ & $\remelem$\\
	\end{tabular}
\end{table}
where $\smstates = \states \setminus \{\state_2\}$ and $\imggrp = \{1,2,\remelem\}$. We obtain $\eqclasssetv = \{\{\state_1, \state_3\}, \{\state_4, \state_5\}, \{\state_2\}, \{\state_6\}\}$, because $\grpfct(\state_1) = \grpfct(\state_3)$, $\grpfct(\state_4) = \grpfct(\state_5)$ and $\grpfct(\state_2) = \grpfct(\state_6) = \remelem \in \nogroupset$. Because in \chgph it is 
\begin{center}
	\begin{tabular}{lcl}
		$\initdistrib(\state_1) = 0.7$ & \quad\quad & $\initdistrib(\state_4) = 0.1$\\
		$\initdistrib(\state_3) = 0.2$ & \quad\quad & $\initdistrib(\state_5) = 0$\\
	\end{tabular}
\end{center}
in \view it is $\initdistrib'(\{\state_1,\state_3\}) = 0.7 + 0.3 = 0.9$ and $\initdistrib'(\state_4, \state_5) = 0.1 + 0 = 0.1$. Because in \chgph it is
\begin{center}
	\begin{tabular}{lcl}
	$\labelingfct(\state_1) = \emptyset$& \quad\quad & $\labelingfct(\state_4) = \{b\}$\\
	$\labelingfct(\state_3) = \{a,b\}$ & \quad\quad & $\labelingfct(\state_5) = \{a\}$\\
	\end{tabular}
\end{center}
in \view it is $\labelingfct'(\{\state_1, \state_3\}) = \labelingfct(\state_1) \cup \labelingfct(\state_3) = \{a,b\}$ and $\labelingfct'(\{\state_4, \state_5\}) = \labelingfct(\state_4) \cup \labelingfct(\state_5) = \{a,b\}$. Since $\state_2$ and $\state_6$ have not been grouped, they are mapped to same values with $\initdistrib'$ and $\labelingfct'$ in \view as with $\initdistrib$ and \labelingfct in \chgph. When considering trans we will only look at some interesting outgoing actions for some states. In \chgph it is 
\begin{center}
	\begin{tabular}{lcl}
 $\trans(\state_1,\action,\state_3) = 0.5$& \quad\quad &	$\trans(\state_3,\actionb,\state_2) = 0.6$ \\
 $\trans(\state_1,\actionb,\state_4) = 1$ & \quad\quad &	$\trans(\state_3,\actionb,\state_3) = 0.4$ \\
	\end{tabular}
\end{center}

Because there are no other other outgoing transitions from $\state_1$ or $\state_3$ with action \actionb in \view it is 
\begin{alignat*}{4}
	\trans'(\eqclassv[\state_1], \actionb, \eqclassv[\state_1]) &= \frac{\trans(\state_3,\actionb,\state_3)}{|\{\state \in \eqclassv[\state_1] \mid \outacts(\state) = \actionb\}|} &&= \frac{0.4}{2} &= 0.2\\
	\trans'(\eqclassv[\state_1], \actionb, \eqclassv[\state_2]) &= \frac{\trans(\state_3,\actionb,\state_2)}{|\{\state \in \eqclassv[\state_1] \mid \outacts(\state) = \actionb\}|} &&= \frac{0.6}{2} &= 0.3\\
	\trans'(\eqclassv[\state_1], \actionb, \eqclassv[\state_4]) &= \frac{\trans(\state_1,\actionb,\state_4)}{|\{\state \in \eqclassv[\state_1] \mid \outacts(\state) = \actionb\}|} &&= \;\:\frac{1}{2} &= 0.5
\end{alignat*}

because $\eqclassv[\state_1] = \{\state_1, \state_3\}, \eqclassv[\state_2] = \{\state_2\}, \eqclassv[\state_4] = \{\state_4\}$ and each time there is only one transition with that action and \redcomment{direction} \redcomment{(undefined! ..should define our intuitive?)} between the equivalence classes. The transition $\trans(\state_1,\action,\state_3) = 0.5$ is interesting because it is within an equivalence class. This causes a loop on the state $\{\state_1,\state_3\}$ in the view \view with the transition $\trans(\eqclassv[\state_1],\action,\eqclassv[\state_3]) = 0.5$. The value remains unchanged as $\trans(\eqclassv[\state_1],\action,\eqclassv[\state_3]) = 0.5$ is the only other transition with action \action outgoing from one of the states $\state_1,\state_3$. Hence the denominator of $\trans'$ in Definition \ref{def:view} is one.
\end{exmp}

\subsection{View Types and Disregarding Views}
In this section we categorize views in two view types. We will present views of two types: binary and categorizing. Given a \grpfctN $\grpfct : \states \to \imggrp$ or a detached \grpfctN $\grpfctsub : \smstates \to \imggrp$

\begin{definition}
	\sloppy
	A \viewN \view is called \emph{binary} if for every \chgphN $\chgph = \chgphtuple$ it is ${\grpfct}[\states] \in \{\{\hasppty, \notppty\}, \{\remelem, \notppty\}, \{\hasppty\, \remelem\}\}$. 
	
	\noindent
	A \viewN \view is called categorizing if for every \chgphN $\chgph = \chgphtuple$ it is $\hasppty, \notppty \in {\grpfct}[\states]$. 
	\label{def:viewtypes}
\end{definition}

\begin{figure}[t]
	\centering \input{./03/images/exampleView}
	\caption{\viewNC \view on \chgphN \chgph from Figure \ref{fig:exampleMdp}}
	\label{fig:exampleView}  
\end{figure}

The notion of a binary view is that it maps each state to whether or not it has a certain property. The symbol \hasppty shall be used if it has the property and the symbol \notppty shall be used if it does not have the property. The symbol \remelem can either be used to not group states that have the property or to not group state states that do not have the property. The case of $\grpfct[\states] = \{\hasppty, \notppty\}$ may seem of rather little benefit, since the resulting view only contains two states. In the actual implementation such a view might be very useful, as at the tier of visualization there will be the feature of expanding grouped states and show the ones they contain. Hence, at runtime it can be decided which states are to be shown, rather than in the phase of preprocessing.

The notion of a categorizing \viewN is that categorizes states to groups, which have a certain property. One could argue that binary \viewsN as well categorize states in two groups that have in common to share having or not having a certain property. We defined categorizing \viewsN as in Definition \ref{def:viewtypes} so that a view either is binary or categorizing to distinguish between the intention of a \viewN.

For binary \view we already presented three cases in which a view is called binary. We will now further elaborate on those cases and generalize the concept and also enable it with categorizing views. When looking at the Elements of the set $\{\{\hasppty, \notppty\}, \{\remelem, \notppty\}, \{\hasppty\, \remelem\}\}$ we observe that for distinct $s,t$ in the set it is $|s|-|s \; \cap \; t| = 1$, i.e. $s$ and $t$ only differ in one element. We declare the case when $\remelem \in M(\grpfct)$ a special case, because instead of assignment of \hasppty or \notppty, the symbol \remelem is assigned, to avoid grouping on states with this property. In general it may be that grouping on states that would be mapped to a certain value should not be grouped. To accomplish this we define disregarding \viewsN.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\grpfctsub : \smstates \to \imggrp$ a detached grouping function where $\smstates \subseteq \states$. The \viewN $\view^\disregardelements$ is defined by its grouping function $\grpfct^\disregardelements : \states \to \imggrp$ where it is $\grpfctsub^\disregardelements : \smstates \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
		\tilde\grpfct(\state),				& \text{if } \grpfctsub(\state) \notin \{\disregardelements\} \\ 		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	Its \grpfctN $\grpfct^\disregardelements$ is called \grpfct \emph{disregarding} \disregardelements and the respective \viewN $\view^\disregardelements$ is called \view \emph{disregarding} \disregardelements. 
\end{definition}

With a disregarding \viewN grouping is avoided if its detached \grpfctN would map to any of the values \disregardelements. That is when reading $\view^\disregardelements$ we know that no grouping occurs on states with one of the properties \disregardelements. In a sense states with these properties are shown - maybe amongst others if $\smstates \subset \states$. For this thesis we will only consider disregarding views for $n = 1$. Normally we will define binary views as the disregarding $\view^\hasppty$ and perceive them as filters that show use states that have that property. 
For $n = 1$ $\view$ can be obtained from $\view^\hasppty$ with 
\[
\grpfctsub(\state) = 
\begin{cases}
	\hasppty,				& \text{if } \grpfctsub^\hasppty(\state) = \remelem  \\
	\grpfctsub^\hasppty(\state),       		& \text{otherwise }
\end{cases}
\]
and $\view^\notppty$ from $\view$ with
\[
\grpfctsub^\notppty(\state) = 
\begin{cases}
	\grpfctsub(\state),       		&\text{if } \grpfctsub(\state) = \hasppty  \\ 
	\remelem,				&\text{otherwise } 
\end{cases}
\]

Similarly $\view$ can be obtained from $\view^\notppty$ and $\view^\hasppty$ from $\view$. Hence it suffices to give one Definition for binary view. For categorizing views we normally wont use disregarding views.

%These have the advantage of being revertible, even if only the detached disregarding \grpfctN is available. This is because if $\grpfctsub^\disregardelem(\state) = \remelem$ we know $\grpfctsub(\state) = \disregardelem$. If $n > 1$ for $\grpfctsub^\disregardelements(\state) = \remelem$ the value $\grpfct(\state)$ is ambigous. When choosing $n = 1$

\subsection{Composition of Views} \label{ch:composition}
In essence views are a simplification generated from \chgphN. It seems rather obvious that the composition of views is a very practical feature, in order to combine simplifications. Therefore in this chapter we will introduce, formalize and discuss different notions of compositions. All variants will ensure that the effect caused by each partaking views also takes effect in the composed view. Moreover it is to be generated in a way that the effect of each individual view can be reverted from the composed one. There may be restrictions in the order of removal.

\subsubsection{\parllcompNCC} 
In this section we will introduce the concept of parallel composition. The most apparent idea is to group states that match in the function value of all given \grpfctsN. This idea is parallel in the sense that a set of \grpfctN is combined to a new \grpfctN in one single step.

\begin{definition} \label{def:pllcompviewandgfct}
	Let $\view[\viewppty_1], \view[\viewppty_2], \dots, \view[\viewppty_n]$ be \viewsN, and $\grpfct[\viewppty_1], \grpfct[\viewppty_2], \dots, \grpfct[\viewppty_n]$ be their corresponding \grpfctsN. The \grpfctN $\grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n}]: \states \to \arbset(\grpfct[\viewppty_1]) \times \dots \times \arbset(\grpfct[\viewppty_n])$ is defined with
	\[
	\state \mapsto (\grpfct[\viewppty_1](\state), \grpfct[\viewppty_2](\state), \dots, \grpfct[\viewppty_n](\state))
	\] 
	and called \emph{parallel composed grouping function}.
	The corresponding parallel composed view is denoted as $\view[\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n]$.
\end{definition}

Note that for $\grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n}]$ if $\grpfct[\viewppty_1](\state) = \grpfct[\viewppty_2](\state) = \dots = \grpfct[\viewppty_n](\state) = \remelem$ the state \state will not be grouped with any other state due to Definition \ref{def:eqrelview} of \eqrelview. An important property of parallel composed \grpfctsN is, that they defy order. That is, with regard to the impact on grouping the order of the included \grpfctsN does not matter.

\begin{proposition}
	Let $\grpfct[u]$ and $\grpfct[v]$ be non parallel composed \grpfctsN and \states a set of states. For all $\state_1, \state_2 \in \states$ it holds that
	\[
	\grpfct[u \pll v](\state_1) = \grpfct[u \pll v](\state_2) \iff \grpfct[v \pll u](\state_1) = \grpfct[v \pll u](\state_2)
	\]
\end{proposition}

\begin{proof}
	Let $\grpfct[u]$ and $\grpfct[v]$ be \grpfctsN, $\state_1, \state_2 \in \states$ and
	\begin{align*}
		\grpfct[u \pll v](\state_1) &= (\grpfct[u](\state_1), \grpfct[v](\state_1)) =: (a, b) \\
		\grpfct[u \pll v](\state_2) &= (\grpfct[u](\state_2), \grpfct[v](\state_2)) =: (x, y)			
	\end{align*}
	Then it is
	\begin{align*}
		\grpfct[v \pll u](\state_1) &= (\grpfct[v](\state_1), \grpfct[u](\state_1)) = (b, a) \\
		\grpfct[v \pll u](\state_2) &= (\grpfct[v](\state_2), \grpfct[u](\state_2)) = (y, x)
	\end{align*}
	It follows that
	\[
	\grpfct[u \pll v](\state_1) = \grpfct[u \pll v](\state_2) \iff \grpfct[v \pll u](\state_1) = \grpfct[v \pll u](\state_2)
	\]
	because $(a, b) = (x, y) \iff a = x \,\, \land \,\, b = y \iff (b, a) = (y, x)$.
\end{proof}

We assume that whenever a \viewN or \grpfctN is parallel composed this is notated as declared in Definition \ref{def:pllcompviewandgfct}. That is, \iffN there is the operator \pll in the subsrcipt of a \viewN or \grpfctN it is parallel composed. We define the operator \pll in order to construct parallel composed \grpfctsN and \viewsN. 

%\begin{definition}
%	The operator \pll maps two \grpfctsN to a new \grpfctN. It is defined recursively.
%	\begin{enumerate}
%		\item $(\grpfct[\viewppty_1] \pll \grpfct[\viewppty_2])(\state) := (\grpfct[\viewppty_1](\state),\grpfct[\viewppty_2](\state)) = \grpfct[\viewppty_1 \pll \viewppty_2](\state)$ \\
%		if it is not $\grpfct[\viewppty_1] = \grpfct[x] \pll \grpfct[y]$ or $\grpfct[\viewppty_2] = \grpfct[x] \pll \grpfct[y]$ for some \grpfctsN \grpfct[x], \grpfct[y].
%		\item $((\grpfct[\viewppty_1], \dots, \grpfct[\viewppty_n]) \pll \grpfct[\viewppty])(\state) := (\grpfct[\viewppty_1](\state), \dots, \grpfct[\viewppty_n](\state), \grpfct[\viewppty](\state)) = \grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n \pll \viewppty}](\state)$ 
%		\\ if for all $i \in \{1, \dots, n\}$ it is not $\grpfct[\viewppty_i] = \grpfct[x] \pll \grpfct[y]$ and also not $\grpfct = \grpfct[x] \pll \grpfct[y]$ for some \grpfctsN \grpfct[x], \grpfct[y].
%	\end{enumerate}
%	
%\end{definition}
\begin{definition}
	The operator \pll maps two \grpfctsN to a new \grpfctN. It is defined inductively.
	\begin{enumerate}
		\item $(\grpfct[\viewppty_1] \pll \grpfct[\viewppty_2])(\state) := \grpfct[{\viewppty_1 \pll \viewppty_2}](\state)$
		\item $(\grpfct[{\viewppty_1 \pll \dots \pll \viewppty_n}] \pll \grpfct)(\state) := \grpfct[{\viewppty_1 \pll \dots \pll \viewppty_n \pll \viewppty}](\state)$ \quad where $n \in \natnums$
		\item $(\grpfct \pll \grpfct[{\viewppty_1 \pll \dots \pll \viewppty_n}])(\state) := \grpfct[{\viewppty \pll \viewppty_1 \pll \dots \pll \viewppty_n}](\state)$ \quad where $n \in \natnums$
	\end{enumerate}
	
\end{definition}

\begin{proposition}
	The operator \pll is associative.
\end{proposition}

\begin{proof}
	Let	$\grpfct[\viewppty_1], \grpfct[\viewppty_2], \grpfct[\viewppty_3]$ be \grpfctsN. For simplicity we omit the parameter (state \state).
	\[
		\grpfct[\viewppty_1] \pll (\grpfct[\viewppty_2] \pll \grpfct[\viewppty_3]) = \grpfct[\viewppty_1] \pll \grpfct[{\viewppty_2 \pll \viewppty_3}] = \grpfct[{\viewppty_1 \pll \viewppty_2 \pll \viewppty_3}] = \grpfct[{\viewppty_1 \pll \viewppty_2}] \pll \grpfct[\viewppty_3] = (\grpfct[\viewppty_1] \pll \grpfct[\viewppty_2]) \pll \grpfct[\viewppty_3]
	\]
	The proof is analogous if one or several of the \grpfctsN are parallel composed.
	
%	(\grpfct[\viewppty_1](\state) \pll (\grpfct[\viewppty_2](\state) \pll \grpfct[\viewppty_3]))(\state) = \grpfct[\viewppty_1](\state) \pll \grpfct[{\viewppty_2 \pll \viewppty_3}](\state) = \grpfct[{\viewppty_1 \pll \viewppty_2 \pll \viewppty_3}] = \grpfct[{\viewppty_1 \pll \viewppty_2}](\state) \pll \grpfct[\viewppty_3](\state) = (\grpfct[\viewppty_1](\state) \pll \grpfct[\viewppty_2])(\state) \pll \grpfct[\viewppty_3](\state)
\end{proof}

We write $\view[\viewppty_1] \pll \view[\viewppty_2]$ for $\view[\viewppty_1 \pll \viewppty_2]$ defined by the grouping function \grpfctN $\grpfct[\viewppty_1] \pll \grpfct[\viewppty_2] = \grpfct[\viewppty_1 \pll \viewppty_2]$.
%The operator \pll used in the definition is inspired from the operator used in electric circuits, when the respective elements are connected in parallel. 
%If we want to speak about this grouping function in a general way, where it is only of importance that we refer to this type of composition and the given \grpfctsN are of no importance, we will denote a \emph{\parllcompN \grpfctN} with \gfctpll.
%
%The operator \pll in \gfctpll is associative with respect to the grouped states. That is exactly the same states are grouped no matter where parenthesis are put.
%\begin{proposition}
%	Let $\grpfct[u], \grpfct[v], \grpfct[w]$ be \grpfctsN and \states a set of states. For all $\state_1, \state_2 \in \states$ it holds that
%	\[
%	\grpfct[(u \pll v) \pll w](\state_1) = \grpfct[(u \pll v) \pll w](\state_2) \iff \grpfct[u \pll (v \pll w)](\state_1) = \grpfct[u \pll (v \pll w)](\state_2)
%	\]
%\end{proposition}
%
%\begin{proof}
%Let $\grpfct[u], \grpfct[v], \grpfct[w]$ be \grpfctsN and \states a set of states with $\state \in \states$. It is
%\begin{equation*}
%	\begin{aligned}[c]
%			&\grpfct[u \pll v](\state) = (\grpfct[u](\state), \grpfct[v](\state)) \\
%			&\grpfct[(u \pll v) \pll w](\state) = ((\grpfct[u](\state), \grpfct[v](\state)), \grpfct[w](\state))
%		\end{aligned}
%	\quad\quad\quad\quad\quad
%	\begin{aligned}[c]
%			&\grpfct[v \pll w](\state) = (\grpfct[v](\state), \grpfct[w](\state)) \\
%			&\grpfct[u \pll (v \pll w)](\state) = (\grpfct[u](\state), (\grpfct[v](\state), \grpfct[w](\state))\\
%		\end{aligned}					
%\end{equation*}
%\\
%\noindent
%Let $\state_1, \state_2 \in \states$ be arbitrary. Moreover let %$\grpfct[((u \pll v) \pll w)](\state_1) =: ((a,b),c)$ and $\grpfct[u \pll (v \pll w)](\state_1) =: ((x, y), z)$, then $\grpfct[u \pll (v \pll w)](\state_1) = (a, (b, c))$ and $\grpfct[u \pll (v \pll w)](\state_2) = (x, (y, z))$
%\begin{equation*}
%	\begin{aligned}[c]
%			&\grpfct[(u \pll v) \pll w](\state_1) =: ((a,b),c) \text{ and} \\
%			&\grpfct[(u \pll v) \pll w](\state_2) =: ((x, y), z) \text{.}
%		\end{aligned}
%	\quad\quad\text{Then it is}\quad\quad
%	\begin{aligned}[c]
%			&\grpfct[u \pll (v \pll w)](\state_1) = (a, (b, c)) \text{ and} \\
%			&\grpfct[u \pll (v \pll w)](\state_2) = (x, (y, z)).
%		\end{aligned}
%	\quad\quad\quad				
%\end{equation*}
%
%\noindent
%Then it is
%\[
%	\grpfct[(u \pll v) \pll w](\state_1) = \grpfct[(u \pll v) \pll w](\state_2) \iff \grpfct[u \pll (v \pll w)](\state_1) = \grpfct[u \pll (v \pll w)](\state_2)
%\]
%
%\noindent
%This is because
%\begin{align*}
%	&((a, b), c) = ((x, y), z) \\
%	\iff \quad &(a, b) = (x, y) \land c = z \\
%	\iff \quad &a = x \land b = y \land c = z \\
%	\iff \quad &a = x \land (b, c) = (y, z) \\
%	\iff \quad &(a, (b, c)) = (x, (y, z))
%\end{align*}
%\end{proof}
%
%Note that the operator \pll is not associative, because it is not defined for expressions of the form $\grpfct[\viewppty] \pll (\grpfct[\viewppty_1], \dots, \grpfct[\viewppty_n])$. For the same reason \pll is in general not commutative (only for the base case). These are no issues since parallel composed \grpfctsN defy order. 
Note that the operator \pll is obviously not commutative, but as parallel composed \grpfctsN defy order, the absence of this property will not have any effect on the resulting grouping.

\begin{definition}
	Let $\grpfct[\viewppty_1 \pll \dots \pll \viewppty_n]$ be a parallel composed grouping function. The operator \pllrev is defined as
	\[
	\grpfct[\viewppty_1, \dots, \viewppty_n] \pllrev \grpfct[\viewppty_i] := (\grpfct[\viewppty_1], \dots, \grpfct[\viewppty_{i-1}],\grpfct[\viewppty_i+1], \dots, \grpfct[n]) = \grpfct[\viewppty_1 \pll \dots \pll \viewppty_{i-1} \pll \viewppty_{i+1} \pll \dots \pll \viewppty_n]
	\]
\end{definition}

The operator \pllrev is the reversing operator to \pll. Given a parallel composed view and an in it contained grouping function it removes this view. We write $\view[\viewppty_1 \pll \dots \pll \viewppty_n] \pllrev \view[\viewppty_i]$ for the view defined by the \grpfctN $\grpfct[\viewppty_1 \pll \dots \pll \viewppty_{i-1} \pll \viewppty_{i+1} \pll \dots \pll \viewppty_n]$.

\subsubsection{Selective Composition} \label{subsec:selecitvecomp}
Selective composition is a variant of parallel composition. It aims for application of the grouping function only on certain states, where the other composing functions have a certain value.

\begin{definition}
	Let $\view[\viewppty_1 \pll \viewppty_2 \pll \dots \pll 
	\viewppty_n]$ be a parallel composed view with its \grpfctN $\grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n}]$, where $n$ might be 1 and let \view be another view with its \grpfctN \grpfct. 
	We write $\imggrp_i$ for the image of $\grpfct[\viewppty_i]$. 
	Given a set $\compselectset \subseteq \{ (\grpfct[\viewppty_i], a) \mid a \in \imggrp_i, i \in \{1, \dots, n\}\}$ the operator \compselectpure is defined as $\grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n}] \compselect \grpfct := \grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n} \pll \viewppty]: \states \to \arbset$ with
	\[
	\state \mapsto (\grpfct[\viewppty_1](\state), \dots, \grpfct[\viewppty_n]'(\state))
	\]
	where $\grpfct' : \states \to \imggrp$ with $\grpfctsub' : \smstates \to \imggrp, \state \to \grpfct(\state)$ and $\smstates := \{\state \in \states \mid \forall i \in \{1, \dots, n\} : (\grpfct[\viewppty_i], \grpfct[\viewppty_i](\state)) \in \compselectset\}$.
	
	
	
	\noindent
	Then $\view[\viewppty_1 \pll \viewppty_2 \pll \dots \pll 
	\viewppty_n \pll \viewppty]$ is a parallel composed \viewN with $\grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n} \pll \viewppty]$ being its parallel composed \grpfctN.
	\label{def:compositionselective}
\end{definition}

The set \compselectset determines on which states the \viewN \view shall take effect, by restricting the state set \smstates of the detached grouping function to those states, that meet the requirement. Every state that is not in \smstates then by Definition \ref{def:grpfct} is mapped to \remelem. Considering $\compselectset = \{(\grpfct[\viewppty_1], a_1),(\grpfct[\viewppty_1], b_1), (\grpfct[\viewppty_2], a_2)\}$ it induces that \view only takes effect on a state \state of \mdp if 

\[
	((\grpfct[\viewppty_1](\state) = a_1) \lor (\grpfct[\viewppty_1](\state) = b_1)) \land (\grpfct[\viewppty_2](\state) = a_2)
\]

That is, if this boolean expression is false the last entry in the mapped tuple in Definition \ref{def:compositionselective} equals \remelem and only otherwise equals $\grpfct(\state)$. Note that Definition \ref{def:compositionselective} is the same as declaring $\grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n}] \compselect \grpfct$ through $\grpfct[{\viewppty_1 \pll \viewppty_2 \pll \dots \pll \viewppty_n} \pll \viewppty]: \states \to \arbset$ with
\[
\state \mapsto
\begin{cases}
	(\grpfct[\viewppty_1](\state), \dots, \grpfct[\viewppty_n](\state),  \grpfct[\viewppty](\state))				& \text{if } \forall i \in \{1, \dots, n\} : (\grpfct[\viewppty_i], \grpfct[\viewppty_i](\state)) \in \compselectset \\ 		
	(\grpfct[\viewppty_1](\state), \dots, \grpfct[\viewppty_n](\state),  \remelem),          	& \text{otherwise}
\end{cases}
\]
In the original definition the set of states \smstates is restricted which causes the remaining elements to be mapped to \remelem. In the equivalent proposed definition here the grouping function is applied only if the requirement is met and otherwise the element \remelem is mapped. Hence, the effect is the same: Whenever the requirement is met the last entry of the tuple is $\grpfct(\state)$ otherwise it is \remelem. Although the latter proposed definition may seem more intuitive the the actual Definition \ref{def:compositionselective} was chosen because it matches the implementation better.


\end{document}

