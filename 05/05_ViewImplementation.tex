\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}


\begin{document}
\section{View Implementation} \label{ch:viewimpl}

The focus of this chapter is to delve into the implementation details of the \emph{\pmcvis} web application, with particular emphasis on the mechanisms behind views and their integration into the system. The primary purpose of the application is to explore and visualize \mdpsN. \viewsNC are used to pre-process data and provide simplified perspectives on \mdpsN.

The \pmcvis project is a web-based application designed for MDP exploration and visualization. Being a web-based application, the project can be divided into two main components: the frontend and the backend. The frontend is responsible for rendering visualizations and providing various customization options for viewing MDPs. The backend provides data to the frontend in JSON format. It consists of three parts: several \prism models, the Java server, and several databases. The Java server interacts with the \prism models, controls them, parses them, and creates a dedicated database for each model. These databases primarily store the structure of \mdpsN and are divided into two tables: one for states and one for transitions. In each table, a row represents a state or a transition.

Information such as property values are stored in dedicated columns in each state table. Whenever a new property is introduced, a new column is added to the database, assigning property values to each state. Similarly, values obtained from the grouping function of a particular view are stored in dedicated columns. Figure \ref{fig:projectstructure} shows an overview of the project structure.

\begin{figure}[h]
	\input{./05/images/ProjectStructure.tex}
	\caption{Project Structure, showing interaction and internal structure of frontend and backend}
	\label{fig:projectstructure}
\end{figure}

Views are implemented within the server on the backend side in the 
%\lstinline[breaklines=true]{prism.core.views} 
\texttt{prism.core}\texttt{.views} package.
Each view is represented by a Java class. While individual views often have their own dedicated class, sometimes multiple similar views are implemented within a single class. All views inherit from the abstract class \texttt{View}. This abstract class contains common attributes and methods that are needed by all views. Many of these are used for testing and I/O. Listing \ref{lst:classview} shows an overview of the relevant attributes and methods. The method \texttt{buildView()} is of particular importance as it computes the mappings of the grouping function and updates the corresponding state table in the database. The process involves 1) checking prerequisites, 2) creating a new column to store grouping results, 3) applying the grouping function which returns the mapped values in the form of a list of SQL queries, and 4) executing these SQL queries to insert the computed values (see listing \ref{lst:buildview}).

%\lstset{}

\begin{figure}[!htb]
	\begin{lstlisting}[style=javaStyle, caption={Most relevant attributes and methods of class \texttt{View}}, label={lst:classview}]
public abstract class View implements Namespace { // ~\commentcolorize{\view}~
	
	protected final ViewType type; // similar to identifier ~\commentcolorize{\viewppty}~
	
	protected final Model model; // ~\commentcolorize{\mdpN \mdp}~
	
	protected long id; 
	
	protected Set<Long> relevantStates; // ~$\commentcolorize{\smstates}$~, Def. view
	
	protected Map<String,Set<String>> stateRestriction 
	= new HashMap<>(); // ~\commentcolorize{$Z$}~, Def. selective composition

	
	protected boolean semiGrouping = true; // ~\commentcolorize{$\remelem \in {\grpfct}[\states]$ allowed}~
	// true: remaining states without property grouped
	// false: remaining states without property NOT grouped
	
	protected enum BinaryMode {SHOW, HIDE} // ~\commentcolorize{$\disregardelem \in \{\hasppty, \notppty\}$}~
	// HIDE: Group states that have the property 
	// SHOW: Group states that do NOT have the property
	
	protected BinaryMode binaryMode = BinaryMode.SHOW; // ~\commentcolorize{$\disregardelem = \hasppty$}~
	// declares binary mode, only queried in binary ~\commentcolorize{\viewsN}~
	
	private void setRelevantStates(Map<String, Set<String>> stateRestriction) { ~\commentcolorize{...}~ }
	
	public void buildView() { ~\commentcolorize{...}~ }
		
	protected abstract List<String> groupingFunction() throws Exception; // ~\commentcolorize{\grpfctsub}~, Def. detached grouping function
\end{lstlisting}
\end{figure}

\begin{figure}[!htb]
	\begin{lstlisting}[style=javaStyle, caption={Implementation of \texttt{buildView()} function}, label={lst:buildview}]
public void buildView() {
	try {	
		// 1. View specific checks
		if (!viewRequirementsFulfilled()) return;
					
		// 2. Create new Column 
		model.getDatabase().execute(String.format("ALTER TABLE %s ADD COLUMN %s TEXT DEFAULT %s",
		model.getStateTableName(), getCollumn(), Namespace.ENTRY_C_BLANK));
		
		// 3. Compute grouping function mapping
		List<String> toExecute = groupingFunction();				
		// 4. Write mapping to database
		model.getDatabase().executeBatch(toExecute);
		
	} catch(Exception e){
		throw new RuntimeException(e);
	}		
}

\end{lstlisting}
\end{figure}


Creating a new view entails implementing the grouping function, the method \texttt{getCollumn()}, and any necessary private attributes. This approach conforms to the formal definition of \viewsN and ensures consistency in the process of creating \viewsN, since each view is essentially defined by its grouping function.

Parallel composition of views is achieved by simply creating another view, resulting in the grouping function entries being written to a new column in the database. Selective composition involves setting a restriction (\texttt{stateRestriction}) corresponding to \compselectset from the definition \ref{def:compositionselective}. This restriction is realized with a map that maps column names to lists of allowed values. In contrast to the formalization, this restriction is then used to generate an SQL query that selects states from the database that satisfy this requirement (\texttt{relevantStates}). This is achieved by setting the where clause of the SQL statement to a boolean expression in conjunctive normal form that expresses the requirement.

The concept of disregarding views is implemented a little less general as in the formalization. In this context, the variable \texttt{semigrouping} plays a crucial role, indicating whether something should be grouped or not. For categorizing views the disregarded value is fixed empty set or string. That is, only for states that would otherwise be mapped to the empty set or string, it can be specified whether they are to be grouped. For instance, in the case of the \viewN \viewscc with a parameter "n" equal to 3, the variable \texttt{semigrouping} determines whether states in an \sccN with less than three states are grouped together. For binary views, an enumeration value decides whether \hasppty or \notppty should possibly be disregarded (not grouped) if the variable \texttt{semigrouping} is true.

To create a view, one accesses \nolinkurl{localhost:8080/<model\_id>/view:<viewname>?param=<param\_val\_1>\&param=<param\_val\_2>..."} via a browser, assuming the backend and frontend are operational. After that, accessing \nolinkurl{localhost:3000/?id=<model\_id>/} will display the graphical \viewN representation. Accessing \nolinkurl{localhost:8080} causes the call of \texttt{createView()}, which creates a new view by calling its constructor, saves it to the internal list of views, and finally calls \texttt{build()} on it, which causes the grouping function values of the view to be written to the database. When accessing \nolinkurl{localhost:3000}, the frontend calls the backend which then creates and provides the JSON file to the frontend with the information stored in the database. This includes the saved information about the grouping function mappings.

The implementation of views leverages an internal graph structure, which was particularly important for views that use grouping based on the structural properties of the MDP graph. To facilitate this, the application uses the \jgrapht library \cite{Michail2020}, which provides not only graph structures but also many common graph algorithms. This library was chosen because it is the most widely used and up-to-date Java library for graphs, with the best documentation and the broadest functionality. The MDP itself is represented by the class \texttt{MdpGraph}, which inherits from the class \texttt{DirectedWeightedPseudgraph} from the \jgrapht library. A directed weighted pseudgraph was chosen because it is directed, allows weights, self loops, and multiple edges between nodes as they occur in \chgphsN, where weights are set to transition probabilities, edges are transitions, and nodes are states.

To maintain a lightweight graph, nodes and vertices are represented as long values that refer to state and transition IDs. Information about states and transitions is accessible via hashmaps within the \texttt{MdpGraph} class. These hashmaps provide modular access to essential information for view functionality, such as action strings for transitions or variable values for states.

Besides the implementation of \viewsN and the classes and data structures required by them, several functionalities have been implemented to allow the following actions at runtime without restarting the server
\begin{itemize}
	\item Show current \viewN information (variable values, etc.) and built views
	\item Rebuild \viewN with new parameters
	\item Remove views by specifying id or name (\pllrev, from Definition \ref{def:pllrev})	
\end{itemize}

These rely on several string parsing methods that have been implemented. The latest version of the project \pmcvis is available at \url{https://imld.com/pmc-vis}. The latest artifact of the project is available at \url{https://zenodo.org/record/8172531}.



\end{document}