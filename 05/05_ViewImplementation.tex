\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}


\begin{document}
\section{View Implementation} \label{ch:viewimpl}

The focus of this chapter is to delve into the implementation details of the \emph{\pmcvis} web application, particularly concentrating on the mechanisms behind views and their integration within the system. The application primarily serves the purpose of exploring and visualizing \mdpsN. \viewsNC are used for preprocessing data and give simplified perspectives on \mdpsN.


The \pmcvis project is a web-based application designed for MDP exploration and visualization. Since it is a web-based application the project can be divided into two main components: the frontend and the backend. The frontend is responsible for rendering visualizations and providing various customization options for viewing MDPs. The backend supplies data to the frontend in JSON format. It consists of three parts: several prism models, the Java server, and multiple databases. The Java server interacts with the prism models, controls them, parses them, and creates a dedicated database for each model. These databases primarily store the structure of \mdpsN, divided into two tables: one for states and another for transitions.

Information such as property values are stored in dedicated columns in the respective state table. Whenever a new property is introduced, a new column is added to the database, assigning property values to each state. Similarly, values obtained from the grouping function of a particular view are stored in designated columns. Figure \ref{fig:projectstructure} shows an overview of the structure of the project.

\begin{figure}[h]
	\input{./05/images/ProjectStructure.tex}
	\caption{Project Structure, showing interaction and internal structure of frontend and backend}
	\label{fig:projectstructure}
\end{figure}

Views are implemented within the server on the backend side in the 
%\lstinline[breaklines=true]{prism.core.views} 
\texttt{prism.core}\texttt{.views} package.
Each view is represented by a Java class. While individual views often have their own dedicated class, sometimes multiple similar views are implemented within a single class. All views inherit from the abstract class \texttt{View}. This abstract class contains common attributes and methods required by all views. Many of these are used for testing and I/O. In Listing \ref{lst:classview} an overview of relevant attributes and methods is shown. The method is \texttt{buildView()} is of particular importance as it computes the mappings of the grouping function and updates the corresponding state table in the database. The process involves 1) checking prerequisites, 2) creating a new column for storing grouping results, 3) applying the grouping function, which returns the mapped values in the form of a list of SQL queries and 4) executing these SQL queries to insert the computed values (see Listing \ref{lst:buildview}).

%\lstset{}

\begin{figure}[!htb]
	\begin{lstlisting}[style=javaStyle, caption={Most relevant attributes and methods of class \texttt{View}}, label={lst:classview}]
public abstract class View implements Namespace { // ~\commentcolorize{\view}~
	
	protected final ViewType type; // similar to identifier ~\commentcolorize{\viewppty}~
	
	protected final Model model; // ~\commentcolorize{\mdpN \mdp}~
	
	protected long id; 
	
	protected Set<Long> relevantStates; // ~$\commentcolorize{\smstates}$~, Def. view
	
	protected Map<String,Set<String>> stateRestriction 
	= new HashMap<>(); // ~\commentcolorize{$Z$}~, Def. selective composition

	
	protected boolean semiGrouping = true; // ~\commentcolorize{$\remelem \in {\grpfct}[\states]$ allowed}~
	// true: remaining states without property grouped
	// false: remaining states without property NOT grouped
	
	protected enum BinaryMode {SHOW, HIDE} // ~\commentcolorize{$\disregardelem \in \{\hasppty, \notppty\}$}~
	// HIDE: Group states that have the property 
	// SHOW: Group states that do NOT have the property
	
	protected BinaryMode binaryMode = BinaryMode.SHOW; // ~\commentcolorize{$\disregardelem = \hasppty$}~
	// declares binary mode, only queried in binary ~\commentcolorize{\viewsN}~
	
	private void setRelevantStates(Map<String, Set<String>> stateRestriction) { ~\commentcolorize{...}~ }
	
	public void buildView() { ~\commentcolorize{...}~ }
		
	protected abstract List<String> groupingFunction() throws Exception; // ~\commentcolorize{\grpfctsub}~, Def. detached grouping function
\end{lstlisting}
\end{figure}

\begin{figure}[!htb]
	\begin{lstlisting}[style=javaStyle, caption={Implementation of \texttt{buildView()} function}, label={lst:buildview}]
public void buildView() {
	try {	
		// 1. View specific checks
		if (!viewRequirementsFulfilled()) return;
					
		// 2. Create new Column 
		model.getDatabase().execute(String.format("ALTER TABLE %s ADD COLUMN %s TEXT DEFAULT %s",
		model.getStateTableName(), getCollumn(), Namespace.ENTRY_C_BLANK));
		
		// 3. Compute grouping function mapping
		List<String> toExecute = groupingFunction();				
		// 4. Write mapping to database
		model.getDatabase().executeBatch(toExecute);
		
	} catch(Exception e){
		throw new RuntimeException(e);
	}		
}

\end{lstlisting}
\end{figure}


Creating a new view entails implementing the grouping function, the method \texttt{getCollumn()}, and any necessary private attributes. This approach matches the formal definition of \viewsN and ensures consistency in the process of generating \viewsN, given that each view is essentially defined by its grouping function.

Parallel composition of views is achieved by simply creating another view, resulting in the grouping function entries being written to a new column in the database. Selective composition involves setting a  restriction (\texttt{stateRestriction}) that corresponds to \compselectset from Definition \ref{def:compositionselective}. This restriction is realized with a map, mapping column names to lists of allowed values. In contrast to the formalization this restriction is then used to generate an SQL Query, that selects states from the database that meet this requirement. This is achieved by setting the where clause of the SQL statement to a boolean formulae in conjunctive normal form that expresses the requirement.

The concept of disregarding views is implemented a little less general as in the formalization. In this context, the variable  \texttt{semigrouping} plays a crucial role, indicating whether something should be grouped or not. For categorizing views the disregarded value is fixed empty set or string. That is, only for states that would otherwise be mapped to an empty set or string, it can be set whether they are to be grouped. For instance, in the case of the \viewN \viewscc with a parameter "n" equal to 3, the variable  \texttt{semigrouping} determines whether states in an \sccN with less than three states are grouped together. For binary views, an enumeration value decides whether \hasppty or \notppty should possibly be disregarded (not grouped), in the case of the variable  \texttt{semigrouping} being true.

To create a view, one accesses \nolinkurl{localhost:8080/<model\_id>/view:<viewname>?param=<param\_val\_1>\&param=<param\_val\_2>..."} via a browser, assuming the backend and frontend are operational. Afterward, accessing \nolinkurl{localhost:3000/?id=<model\_id>/} displays the graphical \viewN representation. The accessing of \nolinkurl{localhost:8080} causes the call of \texttt{createView()}, which creates a new view by calling its constructor, saves it in the internal list of views and finally calls \texttt{build()} on it, which causes the the grouping function values of the view being written to the database. When accessing \nolinkurl{localhost:3000} the frontend calls the backend which then creates and provides the JSON file to the frontend with the information stored in the database. This includes the saved information about the grouping function mappings.

The implementation of views utilizes an internal graph structure that was particularly essential for views that employ grouping based on the structural properties of the MDP graph. To facilitate this, the application utilizes the \jgrapht library \cite{Michail2020}, which not only provides graph structures but also offers many common graph algorithms. This library was selected because it is the most common, most up to date java library for graphs with the best documentation and broadest functionality. The MDP itself is represented by the class \texttt{MdpGraph} that inherits from the class \texttt{DirectedWeightedPseudgraph} from the \jgrapht library. A directed weighted pseudograph has been chosen because it is directed, allows weights, self loops and multiple edges between nodes, as they occur in \chgphsN, where the weights are set to the transition probabilities, edges are transitions and nodes are states.

To maintain a lightweight graph, nodes and vertices are represented as long values, referring to state and transition IDs. Information about states and transitions is accessible via hashmaps within the \texttt{MdpGraph} class. These hashmaps facilitate modular access to essential information for view functionalities, such as action strings for transitions or variable values for states.

Apart from implementation of \viewsN and by them required classes and data structures, several functionalities have been implemented to allow the following actions at runtime without restarting the server:
\begin{itemize}
	\item Display current \viewN information (Parameter values etc.) and built views
	\item Rebuild \viewN with new parameters
	\item Remove views by providing id or name (\pllrev, from Definition \ref{def:pllrev})	
\end{itemize}

These rely on several string parsing methods that have been implemented. The latest version of the project \pmcvis is available at \url{https://imld.com/pmc-vis}. The latest artifact of the project is available at \url{https://zenodo.org/record/8172531}.



\end{document}