\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}


\begin{document} 
\section{View Examples} \label{ch:viewexmp}
In this chapter we will introduce and discuss some \viewN examples created by the author. Their purpose is to understand the idea and concept of a \viewN and to get to know some \viewsN that might be useful in real world applications. \\
When considering \viewsN, we want to consider only those that exploit properties of MDPs, or that perform computations that are also feasible on normal graphs, but are of explicit relevance to MDPs.
\subsection{Views Utilizing MDP Characteristics}
In this section, we will introduce some \viewsN that are purely based on the properties of an \mdpN. This includes \viewsN that leverage elements of the tuple from the definition of \chgphsN ("\chgph components"), but also information associated with it, such as variables, reward or cost structure, and model checking results.
\subsubsection{Atomic Propositions}
One of the least involved approaches to create a \viewN is to base it on the atomic propositions assigned to each state by the labeling function. Atomic Propositions are of relevance because in they are the base tools to identify states with certain notable properties. The notion is to group states that were assigned the same set of atomic propositions.
%\redcomment{Why useful?, currently no "has AP" $\to$ maybe should be added}

\begin{definition}	
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. The \viewN \viewatomicprops is defined by its \grpfctN \gfctatomicprops where $\gfctsubatomicprops : \smstates \to \imggrp, {\state}\mapsto{\labelingfct(\state)}$ with $\imggrp = \atomicprops \cup \remset$.
\end{definition}

The grouping function is exactly the labeling function i.e. for all $\state \in \states$ it is $\gfctatomicprops(\state) := \labelingfct(\state)$. So it is $\gfctatomicprops(\state_1) = \gfctatomicprops(\state_2)$ \iffN $\labelingfct(\state_1) = \labelingfct(\state_2)$. By Definition \ref{def:eqrelview} for $\smstate \in \states$ it is $\eqclassv[\smstate] = \{\state \in \states \mid \labelingfct(\state) = \labelingfct(\smstate)\}$.
%$\forall \state_1, \state_2 \in \states :

Thereby we obtain the \viewN $\viewatomicprops$ for a given \chgphN \chgph where: $\states' = \bigcup_{\state \in \states} \{\eqclassv\} = \bigcup_{a \in \atomicprops} \{\{\state \in \states \mid \labelingfct(\state) = a\}\}$. All other components are constructed as in Definition \ref{def:view}.

\begin{figure}[!htb]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}
		\input{./04/images/ap/apBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/ap/apIdentAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN \viewatomicprops on it (right)}
	\label{fig:apIdentBeforeAfter} 
\end{figure}

\begin{exmp}
	In Figure \ref{fig:apIdentBeforeAfter} we can observe the \viewN \viewatomicprops on \chgph. In the simplified representation on the left the assigned set of atomic propositions of each state are noted next to them. There are four different sets of atomic propositions: $\{\}, \{a\}, \{b\} \text{ and } \{a,b\}$. In the \viewN on the right the states with the same set of atomic propositions have been grouped.
\end{exmp}

Although this \viewN may seem rather simple, since it essentially only performs $\gfctatomicprops := \labelingfct$, it is the most powerful. This is because every \viewN presented below is reducible to this one. This is because a \grpfctN assigns a value to each state. This value could be interpreted as an atomic proposition. The reduction can be realized by replacing the labeling function with the grouping function of the respective \viewN. That is, $\labelingfct := \grpfct$ and $\atomicprops := {\grpfct}[\states]$ for some \grpfctN \grpfct. While this works, it alters the underlying \chgphN.

\subsubsection{Initial States}
A slightly more complicated idea than directly using a given function is to use the support of the initial distribution $\{\state \in \states \mid \initdistrib(\state) > 0\}$. We can group states that have a probability greater than zero to start from. In practice, this may be useful to quickly find all initial states.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\initstates := \{\state \in \states \mid \initdistrib(\state) > 0\}$. The \viewN \viewinitstates is defined by its \grpfctN \gfctinitstates where $\gfctsubinitstates : \smstates \to \imggrp$ with 
	
	\[
	\gfctsubinitstates(\state) =
	\begin{cases}
			\remelem,				& \text{if } \state \in \initstates \\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]	
	and $\imggrp := \imggrpbinview$.
\end{definition}

%For $\state_1,\state_2 \in \states$ it is $\gfctinitstates(\state_1) = \gfctinitstates(\state_2)$ \iffN $\state_1, \state_2 \notin \initstates$ or $\state_1 = \state_2$.
\noindent By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are 
\begin{alignat*}{3}
	\eqclassv &= \{\state \in \states \mid \gfctinitstates(\state) = \remelem\} = \{\state\} \quad\quad\quad\quad\quad\quad &&\text{for } \state \in \initstates \\
	\eqclassv &= \{\state \in \states \mid \gfctinitstates(\state) = \notppty \} &&\text{otherwise}
\end{alignat*}

\noindent Thereby we obtain the \viewN $\viewinitstates$ for a given \achgphN \chgph where: $\states' = \bigcup_{\state \in \states} \{\eqclassv\} = \{\state \in \states \mid \state \notin \initstates\}\cup \bigcup_{\state \in \initstates}\{\{\state\}\}$. All other components are constructed as in Definition \ref{def:view}.

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/initStates/initStatesBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/initStates/initStatesAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN \viewinitstates on it (right)}
	\label{fig:initStatesExmp} 
\end{figure}

\begin{exmp}
	In Figure \ref{fig:initStatesExmp} we can observe the effect of \viewinitstates. In the simplified representation of \achgphN on the left the states $\state_1$ and $\state_3$ are marked as initial states ($\state_1, \state_3 \in \initstates$). Hence, these two are not grouped whereas the remaining two are grouped.
\end{exmp}

\subsubsection{Outgoing Actions}
Another crucial component of \achgphN is its set of actions \actions. Actions are used for interprocess communication and synchronization. In this subsection we will provide and discuss some \viewsN that utilize outgoing actions from a state. 
The most apparent notion to group states is to group states that \emph{have} a given outgoing action.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewhasoutaction is defined by its \grpfctN \gfcthasoutaction where $\gfctsubhasoutaction : \states \to \imggrp$ with

	\[
	\gfctsubhasoutaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state' \in \states: (\state, \action, \state') \in \trans \\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]
	and $\imggrp := \imggrpbinview$. %\actions \cup \remset$.	
\end{definition}


%For $\state_1,\state_2 \in \states$ it is $\gfcthasoutaction(\state_1) = \gfcthasoutaction(\state_2)$ \iffN 
%there exist $\state_{a},\state_{b} \in \states$ with 
%$(\state_1, \action, \state_{a}), (\state_2, \action, \state_{b}) \in \trans$ (i.e. they have \action as outgoing action). 
\noindent By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are 
\begin{alignat*}{3}
	\eqclassv &= \{\state \in \states \mid \gfcthasoutaction(\state) = \remelem\} = \{s\} \quad\quad\quad\quad\quad &&\text{if }\exists\state' \in \states : (\state, \action, \state') \in \trans \\
	\eqclassv &= \{\state \in \states \mid \gfcthasoutaction(\state) = \notppty\} \quad\quad\quad\quad\quad &&\text{otherwise}
\end{alignat*}
 %if for all $\state' \in \states : (\state,\action,\state') \notin \trans$.

\noindent Thereby we obtain the \viewN \viewhasoutaction for a given \chgphN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where
\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states,\, \exists \state' \in \states: (\state, \action, \state') \in \trans\}\} \\
	&\;= \{\{\state\} \mid \state \in \states,\, \gfctminoutaction(\state) = \remelem\} = \nogroupstates \text{  and} \\
	\states_2 &:= \{\{\state \in \states \mid \lnot \exists \state' \in \states: (\state, \action, \state') \in \trans\}\} \\
	&\;= \{\{\state \in \states \mid \gfctminoutaction(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActHasAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewhasoutaction(\action)$ on it (right)}
	\label{fig:outActHasAfter} 
\end{figure}
\begin{exmp}
	In Figure \ref{fig:outActHasAfter} we can observe the \viewN $\viewhasoutaction(\action)$ \chgph. In the simplified representation of \achgphN on the left the action \action is outgoing from states $\state_1, \state_2, \state_3$ and $\state_4$, whereas it is not outgoing from $\state_5$ and $\state_6$. Hence, $\state_1, \dots, \state_4$ are not grouped but shown, and states $\state_5$ and $\state_6$ are grouped.
\end{exmp}

Since actions are a very important part of \chgphsN and TS, it seems useful to further enhance this \viewN and look at variants of it. Instead of only showing states that \emph{have} an action outgoing action we could quantify the amount of times that action should be outgoing. For example we could require that a given action has to be outgoing a minimum amount of times. 

\begin{definition}	
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewminoutaction is defined by its \grpfctN \gfctminoutaction where $\gfctsubminoutaction : \smstates \to \imggrp$ with

	\[
	\gfctsubminoutaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact\\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]
	where $\imggrp := \imggrpbinview$,
	%	\actions \cup \remset$
	 $\numoutact \in \natnums$ is the minimum amount of times a transition with action \action has to be outgoing in order to be grouped with the other states and
	\[
	\predminoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_\numoutact) \in \trans) \land |\{\state_1, \dots, \state_\numoutact\}| = \numoutact
	\]
	is a first order logic predicate.
	\label{def:minoutaction}
\end{definition}

The predicate \predminoutact requires that there are transitions with action \action to \numoutact distinct states, but would also be satisfied, if there were more.
%For $\state_1,\state_2 \in \states$ it is $\gfctminoutaction(\state_1) = \gfctminoutaction(\state_2) \neq \remelem$ \iffN there do not exist distinct $\state_{a_1}, \dots, \state_{a_\numoutact} \in \states$ and distinct $\state_{b_1}, \dots, \state_{b_\numoutact} \in \states$ so that $(\state_1, \action, \state_{a_1}), \dots, (\state_1, \action, \state_{a_\numoutact}) \in \trans$ and $(\state_2, \action, \state_{b_1}), \dots, (\state_2, \action, \state_{b_\numoutact}) \in \trans$. 
\noindent By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are 
\begin{alignat*}{3}
	\eqclassv &= \{\state \in \states \mid \gfctminoutaction(\state) = \remelem\} = \{\state\} \quad\quad\quad &&\text{if } \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact \\ 
	\eqclassv &= \{\state \in \states \mid \gfctminoutaction(\state) = \notppty\} &&\text{otherwise}
\end{alignat*}

\noindent Thereby we obtain the \viewN $\viewminoutaction$ for a given \chgphN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where 
\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states,\, \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact\} \\
	&\;= \{\{\state\} \mid \state \in \states,\, \gfctminoutaction(\state) = \remelem\} = \nogroupstates \text{  and} \\
	\states_2 &:= \{\{\state \in \states \mid \lnot \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact\}\} \\
	&\;= \{\{\state \in \states \mid \gfctminoutaction(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActMinAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewminoutaction(\action,2)$ on it (right).}
	\label{fig:outActMinAfter} 
\end{figure}

\begin{exmp}
	In Figure \ref{fig:outActMinAfter} we can observe the \viewN $\viewminoutaction(\action,2)$ on \chgph. In the simplified representation of \achgphN on the left the action \action is outgoing zero times from $\state_5, \state_6$, one time from $\state_3, \state_4$ and two times from $\state_1, \state_2$. Hence, $\state_1$ and $\state_2$ are not grouped but shown, and states $\state_3, \dots, \state_6$ are grouped.
\end{exmp}

\noindent In a similar fashion we define \viewN, which groups states where a given action occurs at most a certain number of times. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewmaxoutaction is defined by its \grpfctN \gfctmaxoutaction where $\gfctsubmaxoutaction : \smstates \to \imggrp$ with

	\[
	\gfctsubmaxoutaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]
	where $\imggrp := \imggrpbinview$,
%	$\numoutact \in \natnums$ 
	is the maximal number of times a transition with action \action may be outgoing and 
	\[
	\predmaxoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_{\numoutact+1}) \in \trans) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numoutact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
	\label{def:viewmaxoutaction}
\end{definition}

The predicate \predmaxoutact ensures that there are at most \numoutact actions \action outgoing, by requiring that if there exist more than \numoutact transitions outgoing with action \action, at least two of them are the same. It does so by enforcing that the states in which the transitions end are in fact the same. The reasoning about the equality of the \grpfctN values, the obtained equivalence classes, and the resulting set of states $\states'$ of \viewN is analogous to \viewminoutaction.

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActMaxAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewmaxoutaction(\action,1)$ on it (right)}
	\label{fig:outActMaxAfter} 
\end{figure}

\begin{exmp}
	In Figure \ref{fig:outActMaxAfter} we can observe the \viewN $\viewmaxoutaction(\action,1)$ on \chgph. In the simplified representation of \achgphN on the left the action \action is outgoing zero times from $\state_5, \state_6$, one time from $\state_3, \state_4$ and two times from $\state_1, \state_2$. Hence, $\state_3, \dots, \state_6$ are not grouped but shown, and states $\state_1$ and $\state_2$ are grouped.
\end{exmp}

Since we have already defined \grpfctsN and hence \viewsN for a required minimum and maximal amount of times an action has to be outgoing it is now easily possible to define a \viewN that groups states where the amount of outgoing actions is at least \numoutact and at most \numoutactb. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN 
	\viewspanoutaction is defined by its \grpfctN where $\gfctsubspanoutaction : \smstates \to \imggrp$ with

	\[
	\gfctsubspanoutaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]
	and $\numoutactb, \numoutact \in \natnums$ are the minimum and maximum number of transitions with action \action for a state to be grouped. The predicates \predminoutact and \predmaxoutact are the predicates from Definition \ref{def:minoutaction} and Definition \ref{def:viewmaxoutaction} respectively.
\end{definition}

For a given $\state \in \states$, the expressions $\exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact$ and $\forall \state_1, \dots, \state_{\numoutactb+1} \in \states: \predmaxoutact[\numoutactb]$ from Definition \ref{def:minoutaction} and Definition \ref{def:viewmaxoutaction} require that \state has a minimum and maximum amount of outgoing transitions with an action \action. Hence, the conjunction will be true for states where the amount of outgoing transitions with action \action is element of the set $\{\numoutactb, \numoutact+1, \dots, \numoutact-1, \numoutact\}$. We will write that the number of outgoing actions is \emph{in the span}. For a given state \state and action \action, for convenience we set

\begin{align*}
	\formoutact:= &\;\exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb] \\
	&\land \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact
\end{align*}

\formoutact is true \iffN the number of outgoing actions is in the span. For $\state_1, \state_2 \in \states$ it is $\gfctspanoutaction(\state_1) = \gfctspanoutaction(\state_2)$ \iffN $\formoutact[\state_1] \land \formoutact[\state_2]$ or $\state_1 = \state_2$. By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are 
\begin{alignat*}{3}
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \remelem\} = \{\state\} \quad\quad\quad\quad\quad &&\text{if } \formoutact \text{ true} \\
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \notppty\} &&\text{otherwise}	
\end{alignat*}

The new set of states $\states'$ of the \viewN \viewspanoutaction is the union of the equivalence classes of the equivalence relation \eqrelview on the set of states \states of the original \chgphN. Hence it is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where
\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states, \, \formoutact \text{ true}\} \\
	&\;= \{\{\state\} \mid \state \in \states, \, \gfctspanoutaction(\state) = \remelem\} = \nogroupstates \\
	\states_2 &:= \{\{\state \in \states \mid \formoutact \text{ false}\}\} = \{\{\state \in \states \mid \gfctspanoutaction(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActSpanBefore}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewspanoutaction(1, \action, 1)$ on it (right)}
	\label{fig:outActSpan}
\end{figure}
\begin{exmp}
	In Figure \ref{fig:outActSpan} we can observe the \viewN $\viewspanoutaction(1, \action, 1)$ on \mdp. It shows states that have the action \action at least one time outgoing and at most 1 one time. Hence, it does not group states, where the action \action is outgoing exactly once. All all remaining states are grouped. In the simplified representation of \achgphN on the left, the action \action is outgoing zero times from $\state_5, \state_6$, one time from $\state_3, \state_4$ and two times from $\state_1, \state_2$. Hence, $\state_4, \dots, \state_5$ are not grouped but shown, and the remaining states $\state_1, \state_2, \state_5, \state_6$ are grouped.
\end{exmp}


%The \viewsN above can be combined with \parllcompN. The thereby obtained \viewN requires that the respective conditions of all the combined \viewsN are met. In this sense it is a conjunctive combination.

Instead of making requirements on states and grouping them based on whether they meet those requirements, it is also possible to group states that are very similar or even identical with respect to their outgoing actions. First, we will consider the case where the outgoing actions and their set are identical.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. The \viewN \viewstrongoutactident is defined by its \grpfctN \gfctstrongoutactident where $\gfctsubstrongoutactident : \smstates \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numoutact) \mid \action \in \actions, n = |\{ (\state, \action, \state') \in \trans\}|\}
	\]
	and $\imggrp := \actions \times \natnums \cup \remset$.
\end{definition}

The \grpfctN assigns a set of pairs to each state. For each action in \actions, one pair is contained, declaring the number of times the action is outgoing from that state. Note that $n$ is zero if an action is not outgoing from a state.
%Note that a pair is contained in the set for each action $\action \in \actions$. In case there is no outgoing transition from state \state with an action \action it is $(\action, 0) \in \gfctstrongoutactident$. For $\state_1, \state_2 \in \states$ it is $\gfctstrongoutactident(\state_1) = \gfctstrongoutactident(\state_2)$ \iffN $\state_1$ and $\state_2$ are mapped to the same set of pairs. 
By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are 
\[
	\eqclassv := \{\state' \in \states \mid \gfctstrongoutactident(\state') = \gfctstrongoutactident(\state) = \{(\action_1, \numoutact_1), \dots, (\action_l, \numoutact_l)\}\} \text{ where } l = |\actions|
\]
By Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewstrongoutactident. All other components of \viewstrongoutactident are structured as usual according to the definition \ref{def:view}.

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}		
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongAfter}
	\end{minipage}
	
	\caption{Simplified representations of \mdp (left) and the \viewN \viewstrongoutactident on it (right)}
	\label{fig:outActIdentStrongAfter}

\end{figure}

\begin{exmp}
	In Figure \ref{fig:outActIdentStrongAfter} we can observe the \viewN $\viewstrongoutactident$ on \mdp (both simplified representations). 
For \viewstrongoutactident it is \gfctstrongoutactident :
\begin{alignat*}{3}
	&\state_1 \mapsto \{(\action,2), (\actionb,1), (\actionc,1)\} \quad\quad\quad\quad\quad\quad &&\state_4 \mapsto \{(\action,1), (\actionb,0), (\actionc,0)\} \\
	&\state_2 \mapsto \{(\action,2), (\actionb,1), (\actionc,1)\} \quad\quad\quad\quad && \state_5 \mapsto \{(\action,0), (\actionb,0), (\actionc,1)\} \\
	&\state_3 \mapsto \{(\action,1), (\actionb,1), (\actionc,1)\} \quad\quad\quad\quad && \state_6 \mapsto \{(\action,0), (\actionb,0), (\actionc,1)\}	
\end{alignat*}
because these are number of corresponding outgoing actions from each state. We see that the sets are equal for $\state_1$ and $\state_2$ and for $\state_5$ and $\state_6$. So these two pairs are grouped into new states each. The remaining states are not grouped with any other state. The equivalence classes containing them are singleton sets.
%\begin{minipage}{.45\textwidth}
%\begin{align*}
%	\state_1 &\mapsto \{(\action,2), (\actionb,1), (\actionc,1)\} \\
%	\state_2 &\mapsto \{(\action,2), (\actionb,1), (\actionc,1)\} \\
%	\state_3 &\mapsto \{(\action,1), (\actionb,1), (\actionc,1)\} \\	
%\end{align*}
%\end{minipage}
%\begin{minipage}{.55\textwidth}
%\begin{align*}
%	\state_4 &\mapsto \{(\action,1), (\actionb,0), (\actionc,0)\} \\
%	\state_5 &\mapsto \{(\action,0), (\actionb,0), (\actionc,1)\} \\
%	\state_6 &\mapsto \{(\action,0), (\actionb,0), (\actionc,1)\} \\
%\end{align*}
%\end{minipage}
\end{exmp}

The \viewN \viewstrongoutactident, as well as \viewminoutaction, \viewmaxoutaction, \viewspanoutaction were originally motivated by transition systems in which there are no probabilities, but multiple actions starting from a single state may occur. Since \mdpsN can model transition systems, they were included. For \mdpsN with proper probability distributions, counting outgoing actions may be less helpful. Instead, one could disregard the amount of times an action is outgoing and only be interested in states that have the same options for the nondeterministic choice before the probabilistic one.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. The \viewN \viewweakoutactident is defined by its \grpfctN \gfctweakoutactident where $\gfctsubweakoutactident : \smstates \to \imggrp$ with
	\[
	\state \mapsto \outacts(\state)
	\]
	and $\imggrp := \actions \cup \remset$.
\end{definition}

For $\state_1, \state_2 \in \states$ it is $\gfctweakoutactident(\state_1) = \gfctweakoutactident(\state_2)$ \iffN they are mapped to the same set of actions. Hence the equivalence classes of \eqrelview are
\[
	\eqclassv = \{ \state' \in \states \mid \gfctweakoutactident(\state') = \gfctweakoutactident(\state) =: \{\action_1, \dots, \action_l\}\} \text{ where } l \leq |\actions|.
\]
By Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewweakoutactident.

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}				
		\hspace{5mm}
		\input{./04/images/actions/outActIdentWeakAfter}
	\end{minipage}	
	\caption{Simplified representations of \mdp (left) and the \viewN \viewweakoutactident on it (right)}	
	\label{fig:outActIdentWeakAfter} 	
\end{figure}

\begin{exmp}
	In Figure \ref{fig:outActIdentWeakAfter} we can observe the \viewN $\viewweakoutactident$ on \chgph (both simplified representations). 
For \viewweakoutactident it is \gfctweakoutactident :
\begin{alignat*}{3}
	&\state_1 \mapsto \{\action, \actionb, \actionc\} \quad\quad\quad\quad\quad\quad\quad\quad &&\state_4 \mapsto \{\action\}\\
	&\state_2 \mapsto \{\action, \actionb, \actionc\} &&\state_5 \mapsto \{\actionc\}\\
	&\state_3 \mapsto \{\action, \actionb, \actionc\} &&\state_6 \mapsto \{\actionc\}
\end{alignat*}
because these are the corresponding outgoing actions from each state. We see that the sets are equal for $\state_1,\state_2$ and $\state_3$ and for $\state_5$ and $\state_6$. Hence, the state set of the \viewN \viewweakoutactident on \chgph has the state set $\{\{\state_1, \state_2, \state_3\}, \{\state_4\}, \{\state_5, \state_5\}\}$.
\end{exmp}
Apart from the option of directly considering one or a set of outgoing actions with possible quantities it is also possible to only consider the quantity of outgoing actions without regarding any specific action.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewoutactsetsize is defined by its \grpfctN \gfctoutactsetsize where $\gfctsuboutactsetsize : \smstates \to \imggrp$ with
	\[
	\state \mapsto |\outacts(\state)|
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

%For $\state_1, \state_2 \in \states$ it is $\gfctoutactsetsize(\state_1) = \gfctoutactsetsize(\state_2)$ \iffN they are mapped to the same set of actions. 

\noindent By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are 
\begin{align*}
	\eqclassv[\state] = \{ \state \in \states \mid \gfctoutactsetsize(\state') = \gfctoutactsetsize(\state)\} = \{ \state \in \states \mid \outacts(\state') = \outacts(\state)\}
\end{align*}

\noindent By Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewweakoutactident.

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}						
		\centering
		\input{./04/images/actions/outActSetSizeAfter}
	\end{minipage}	
	\caption{Simplified representations of \mdp (left) and the \viewN \viewoutactsetsize on it (right)}	
	\label{fig:outActSetSize} 	
\end{figure}

\begin{exmp}
	In Figure \ref{fig:outActSetSize} we can observe the \viewN $\viewoutactsetsize$ on \chgph. In the simplified representation of \achgphN on the states $\state_1, \state_2, \state_3$ have the outgoing actions $\action, \actionb, \actionc$, the state $\state_4$ has the outgoing action \action and the state $\state_5, \state_6$ have the outgoing action \actionc. Hence, the number of outgoing actions for $\state_1, \state_2, \state_3$ is three and for $\state_4, \state_5, \state_6$ is one. Therefore, each of these states becomes a new single state in the \viewN \viewoutactsetsize.
\end{exmp}

The notion of the \viewN \viewoutactsetsize is similar to utilize the outdegree, with the difference being here that ougoing transitions with the same action are considered as one single edge. This reflects on the options available for nondeterminism in this state.

The special case where there is only a single outgoing action is worth a distinct \viewN, since it hides all non-deterministic choices, but nothing more.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewoutactsingle is defined by its \grpfctN \gfctoutactsingle where $\gfctsuboutactsingle : \smstates \to \imggrp$ with
	\[
	\gfctsuboutactsingle(\state) =
	\begin{cases}
		\hasppty, &\text{if } |\outacts(\state)| = 1 \\ 
		\remelem, &\text{otherwise}
	\end{cases}
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

Note that this \viewN is disregarding \notppty and hence groups states that \emph{have} the property. This version was chosen because the intention of the \viewN is to hide \states in which there is no nondeterministic choice of an action. 

\noindent By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are 
%Two states $\state_1, \state_2 \in \states$ are grouped \iffN $\gfctoutactsingle(\state_1) = \gfctoutactsingle(\state_2)$. Hence the the equivalence classes of \eqrelview are:
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \remelem\} = \{\state\} &\text{if } |\outacts(\state)|=1 \\
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \notppty\} &\text{otherwise}	
\end{align*}
\noindent Thereby we obtain the \viewN $\viewminoutaction$ for a given \chgphN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where 

\begin{align*}
	\states_1 &:= \{\{ \state \in \states \mid |\outacts(\state)| = 1\}\} = \{\{\state \in \states \mid \gfctminoutaction(\state) = \hasppty\}\} \text{  and} \\
	\states_2 &:= \{\{\state\} \mid \state \in \states, \mid |\outacts(\state)| \neq 1\}\} = \{\{\state\} \mid \state \in \states, \, \gfctminoutaction(\state) = \remelem\}\} = \nogroupstates[\states_1].
\end{align*}

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}						
		\centering
		\input{./04/images/actions/outActSingleAfter}
	\end{minipage}	
	\caption{Simplified representations of \mdp (left) and the \viewN \viewoutactsetsize on it (right)}	
	\label{fig:outActSingle} 	
\end{figure}

\begin{exmp}
	In Figure \ref{fig:outActSingle} we can observe the \viewN $\viewoutactsingle$ on \chgph. In the simplified representation of \achgphN, the states $\state_5$ and $\state_6$ are the only states with only one outgoing action. Hence, these two are grouped and the remaining four states are not grouped with any other state, but shown.
\end{exmp}

\subsubsection{Incoming Actions}
Analogous to outgoing actions, \viewsN utilzing incoming actions are feasible. Since there is no difference other than the definitions themselves, we only provide the definitions.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewhasinaction is defined by its \grpfctN \gfcthasinaction where $\gfctsubhasinaction : \smstates \to \imggrp$ with
	\[
	\gfctsubhasinaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state' \in \states: (\state', \action, \state) \in \trans \\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]
	and $\imggrp := \imggrpbinview$.	
	\label{def:mininaction}
\end{definition}	


\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewmininaction is defined by its \grpfctN \gfctmininaction where $\gfctsubmininaction : \smstates \to \imggrp$ with
	\[
	\gfctsubmininaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state_1, \dots, \state_\numinact \in \states: \predmininact\\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]
	where $\imggrp := \imggrpbinview$,
%	 $\numinact \in \natnums$ 
	 is the minimum amount of times a transition with action \action has to be incoming in order to be grouped with the other states and
	\[
	\predmininact := ((\state_1, \action, \state), \dots, (\state_\numinact, \action, \state) \in \trans) \land |\{\state_1, \dots, \state_\numinact\}| = \numinact
	\]
	is a first order logic predicate.
	\label{def:viewmaxinaction}
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewmaxinaction is defined by its \grpfctN \gfctmaxinaction where $\gfctsubmaxinaction : \smstates \to \imggrp$ with
	\[
	\gfctsubmaxinaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]	
	where $\imggrp := \imggrpbinview$
%	$\numinact \in \natnums$ 
	 is the maximum number of times a transition with action \action may be incoming and 
	\[
	\predmaxinact := ((\state_1, \action, \state), \dots, (\state_{\numinact+1}, \action, \state) \in \trans) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numinact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN 
	\viewspaninaction is defined by its \grpfctN where $\gfctsubspaninaction : \smstates \to \imggrp$ with
	\[
	\gfctsubspaninaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state_1, \dots, \state_\numinactb \in \states: \predmininact[\numinactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
			\notppty,     	& \text{otherwise}
		\end{cases}
	\]
	where $\imggrp := \imggrpbinview$
%	\actions \cup \remset$ 
	and $\numinactb, \numinact \in \natnums$ are the minimum and maximum number of transitions with action \action in order for state to be grouped. The predicates \predmininact and \predmaxinact are the predicates from Definition \ref{def:mininaction} and Definition \ref{def:viewmaxinaction} respectively.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewstronginactident is defined by its \grpfctN \gfctstronginactident where $\gfctsubstronginactident : \smstates \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numinact) \mid \action \in \actions, \numinact \text{ is the number of times that \action is incoming from } \state\}
	\]
	and $\imggrp := (\actions \times \natnums_0) \cup \remset$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewweakinactident is defined by its \grpfctN \gfctweakinactident where $\gfctsubweakinactident : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\action \in \actions \mid \exists \state' \in \states : (\state', \action, \state) \in \trans\} 	
	\]
	and $\imggrp := \actions\cup \remset$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewinactsetsize is defined by its \grpfctN \gfctinactsetsize where $\gfctsubinactsetsize : \smstates \to \imggrp$ with
	\[
	\state \mapsto |\{\action \in \actions \mid \exists \state' \in \states : (\state', \action, \state) \in \trans\}|
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewinactsingle is defined by its \grpfctN \gfctinactsingle where $\gfctsubinactsingle : \smstates \to \imggrp$ with
	\[
	\gfctsubinactsingle(\state) =
	\begin{cases}
		\hasppty, &\text{if } |\inacts(\state)| = 1 \\ 
		\remelem, &\text{otherwise}
	\end{cases}
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

\subsubsection{Variables}
The concept of variables is not part of the definitions of neither \tsN, MCs or \mdpsN even though, it is of great relevance in practice. We will introduce and discuss this concept before utilizing it for \viewsN.

Since states describe some information about a system at a certain moment of its behavior, the information they carry is usually not atomic, but rather consists of several pieces. For instance when considering a computer program at a given moment during execution all of its currently available variables will have some value, the stack will have a certain structure and the program counter will point to a certain instruction. Systems in general have several properties at a given moment of their behavior, which together constitute the current state of the system. That is, in practice, each state is actually derived from a possible variable assignment. Choosing the respective variable assignment as state representation would result in rather complex state objects. Therefore, the values of the variables are usually stored in a separate data structure and a simple identifier such as an integer represents the actual state. When formalizing this in practice used approach several options come into consideration. Available \mdpN components such as atomic propositions or the set of states could be used to hold this information. There could be a subset of atomic propositions whose elements declare that a certain variable has a certain value. To achieve unambiguous variable values, care had to be taken that for each variable in each state there was only one atomic proposition declaring its value. The set of states could be used in the sense that the states themselves are complex objects containing the information. We will formalize the variables with a set of variables and an evaluation function induced by the \mdpN. Although this approach is not based on \mdpN components, it is practical and convenient to work with.
%Firstly there is the option of declaring the states as complex objects that contain this information. This would be possible because the set of states is not further specified. Accessing this information stored within a state would be rather tedious because there is no already existing entity to properly accomplishing the access. Hence this option was not further explored. The second option is to require that all possible assignments of all variables are included in the atomic propositions. The labeling function would then assert exactly one atomic proposition for each variable for each state, that specifies what the current value of that variable is. Although this would be possible, for simplicity we chose that variables and its values are provided in addition to the \mdpN. Obviously they are to be understood as derived and therefore dependent on the system, that the \mdpN has been derived from. By no means the set of variables and its evaluation are arbitrary.


%Variables are used to represent states (in more detail). 
%
%For example an \mdpN could be used to model a computer program with human interaction. Every state of the MDP refers an overall state of the program during execution time. In this state of the program, its variables will have specific values. We may want to retain the information about the variable's values of the program instead of only assigning a state $\state \in \states$ that refers to the state of the program. Variables and its current values are not only relevant to computer programs but also other systems. Many of those other systems rely on some kind of global state during execution, which can be expressed with variables and values assigned to them. Since there exists no explicit component to retain this information the notion of variables is used to store it.
%
%\redcomment{OLD: Since transitions systems MCs and MDPs in practice are used to model, analyze and check real world systems it is very practical to not only name states but also describe the properties of the state in more detail. For a basic notion variables are to be imagined as a set of variables that may have different values in different states thereby describing the characteristics of the state more thoroughly. \purpcomment{ADDED TO OLD: In practice most often they arise naturally for example as variables of a computer program that is to be modeled with an \mdpN.}} 
%
%Because of the vast importance in practical applications we will consider some \viewsN that utilize them. To do so and being able to describe them formally we define and formalize the notion of variables by considering them as a subset of the atomic propositions \atomicprops that is assigned a value by a function.

\begin{definition}
	Let $\mdp$ be an \mdpN. The set $\vars$ is called \emph{variables} (of \mdp). It contains all variables induced by \mdp.
\end{definition}

\begin{definition}
	Let $\mdp = \mdptuple$ be an \mdpN and \varevalimgset be an arbitrary set. The by im induced function $\vareval : \states \times \vars \to \varevalimgset$ is called \emph{variable evaluation function}.
\end{definition} 

For this thesis \vars refers to the set of variables declared in the \prism file and \vareval to their values.
%Most of the time we will use \vareval to refer to the variable evaluation function. 
When we speak about the value of a variable in a state we refer to the image of $\vareval$ for that state and variable. The set \varevalimgset is arbitrary so that arbitrary values can be assigned to a variable. Speaking in terms of computer science and programming this loosens as an example the restriction of only being able to assign numbers and no booleans. The most apparent idea for a \viewN utilizing variables is to group states that meet some requieent regarding the values of the variables.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$, $\var \in \vars$ and $\varval \in \varevalimg$. The \viewN \viewparamvalueseq is defined by its \grpfctN \gfctparamvalueseq where $\gfctsubparamvalueseq : \smstates \to \imggrp$ with
	\[
	\gfctsubparamvalueseq(\state) =
	\begin{cases}
			\remelem, &\text{if } \vareval(\state, \var) = \varval\\
			\notppty, &\text{otherwise}
	\end{cases}
	\]
	where $\imggrp := \imggrpbinview$.
\end{definition}

\noindent The \viewN \viewparamvalueseq shows states where a given variable has a given value. 
%For $\state_1, \state_2$ it is $\gfctparamvalueseq(\state_1) = \gfctparamvalueseq(\state_2)$ \iffN $\vareval(\state_1, \var) = \vareval(\state_2, \var)$ or $\state_1 = \state_2$. The obtained equivalence classes are
By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are
\begin{alignat*}{3}
	\eqclassv &= \{\state \in \states \mid \gfctparamvalueseq(\state) = \remelem\} = \{\state\} \quad\quad\quad\quad &&\text{if \vareval(\state, \var) = \varval} \\
	\eqclassv &= \{\state \in \states \mid \gfctparamvalueseq(\state) = \notppty\} &&\text{otherwise}
\end{alignat*}

\noindent The set of states $\states'$ of \viewparamvalueseq is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where
\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states, \, \vareval(\state, \var) = \varval\} \\
	&\;= \{\{\state\} \mid \state \in \states, \, \gfctparamvalueseq(\state) = \remelem\} = \nogroupstates \\
	\states_2 &:= \{\{\state \in \states \mid \vareval(\state, \var) \neq \varval\}\} = \{\{\state \in \states \mid \gfctparamvalueseq(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[!htb]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}		
		\input{./04/images/variables/varsBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/variables/varsValEqAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp with the state set $\states = \{\varstyle{x}{y} \mid x,y \in \{0, 1, 2\}\}$ (left) and the \viewN $\viewparamvalueseq(y=1)$ on it (right)}
	\label{fig:varsValEq} 
\end{figure}

\begin{exmp}
	In Figure \ref{fig:varsValEq} we can observe the \viewN of $\viewparamvalueseq(y=1)$ on \chgph, in which states with $y=1$ are not grouped, but all the remaining ones.
\end{exmp}

%Analogously a \viewN that requires inequality instead of equality is feasible.

%\begin{definition}
%	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$, $\var \in \vars$ and $\varval \in \varevalimg$. The \viewN \viewparamvaluesneq is defined by its \grpfctN \gfctparamvaluesneq where $\gfctsubparamvaluesneq : \smstates \to \imggrp$ with
%	\[
%	\gfctsubparamvaluesneq(\state) =
%	\begin{cases}
%			\remelem, &\text{if } \vareval(\state, \var) \neq \varval\\
%			\notppty, 	&\text{otherwise}
%		\end{cases}
%	\]
%	where $\imggrp := \imggrpbinview$.
%\end{definition}

If states are to be grouped with a requirement that multiple variables be equal to or not equal to specified values, this can be accomplished by using \parllcompN. For even more flexibility, a \viewN may be employed, which also allows a combination of requirements on variables in a disjunctive manner. To extend this idea to its full potential, we will define a \viewN that allows requirements to be expressed using a disjunctive normal formal (DNF). To formalize this \viewN more efficiently, we will write $\varstate[,i]$, short for $\vareval(\state, \var_i)$, where $x_i \in \vars$ and $i \in \natnums$. We define the symbol \eqorneq to be an element of the set $\{=,\neq\}$. That is, whenever it is used, each time it is written, it is a substitute for either the symbol $=$ or $\neq$. It allows to write one symbol whenever $=$ and $\neq$ could or should be possible. Furthermore, for this context we consider $(\varstate[,i] = \varval)$ as a literal and $(\varstate[,i] \neq \varval)$ as its negation. We write $(\varstate[,i] \eqorneq \varval)$ for a literal that may or may not be negated.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and 
	\begin{align*}
		c(s) = &((\varstate[,i_1] \eqorneq \varval_{i_1}) \land \dots \land (\varstate[,i_{l_1}] \eqorneq \varval_{i_{l_1}})) \; \lor \\
		&((\varstate[,i_{l_1+1}] \eqorneq \varval_{i_{l_1+1}}) \land \dots \land (\varstate[,i_{l_2}] \eqorneq \varval_{i_{l_2}})) \; \lor \\
		&\dots \\ 
		&((\varstate[,i_{(l_{m-1})+1}] \eqorneq \varval_{i_{(l_{m-1})+1}}) \land \dots \land (\varstate[,i_{l_m}] \eqorneq \varval_{i_{l_m}}))
	\end{align*}
	
	proposition logical formula in disjunctive normal form where
	\begin{itemize}
		\item $\varstate[,i_k], a_{i_k} \in \varevalimg$ with $i_k\in \natnums$ and $k \in \{1, \dots, l_m\}$
		\item $l_1 < l_2 < \dots < l_m$ are natural numbers and $m$ is the number of clauses in $c(s)$
	\end{itemize}		
	The \viewN \viewparamdnf is defined by its \grpfctN \gfctparamdnf where $\gfctsubparamdnf : \smstates \to \imggrp$ with
	\[
	\gfctsubparamdnf(\state) =
	\begin{cases}
			\remelem, &\text{if } d(s) \text{ is true}\\
			\notppty, 	&\text{otherwise}
		\end{cases}
	\]
	where $\imggrp := \{\group, \remelem\}$.
\end{definition}

The DNF allows us to specify a constraint on variables in a disjunctive normal form. States are mapped to the same value depending on whether they satisfy this constraint.
%The \viewN \viewparamdnf groups states that share the same value for a given variable. For $\state_1, \state_2$ it is $\gfctparamdnf(\state_1) = \gfctparamdnf(\state_2)$ \iffN $\vareval(\state_1, \var) = \vareval(\state_2, \var)$ or $\state_1 = \state_2$. 
%The obtained equivalence classes are
By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctparamdnf(\state) = \remelem\} = \{\state\} &\text{if } d(s) \text{ true} \\
	\eqclassv &= \{\state \in \states \mid \gfctparamdnf(\state) = \notppty\} &\text{otherwise}
\end{align*}

\noindent The set of states $\states'$ of \viewparamdnf is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where
\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states, \, d(s) \text{ true}\} = \{\{\state\} \mid \state \in \states, \, \gfctparamdnf(\state) = \remelem\} = \nogroupstates \\
	\states_2 &:= \{\{\state \in \states \mid d(s) \text{ false}\}\} = \{\{\state \in \states \mid \gfctparamdnf(\state) = \notppty\}\}.
\end{align*}
\begin{figure}[!htb]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}		
		\input{./04/images/variables/varsBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/variables/varsDnfAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp $\states = \{\varstyle{x}{y} \mid x,y \in \{0, 1, 2\}\}$ (left) and the \viewN $\viewparamdnf(d(\state))$ where $d(s) = ((x=0) \land (y=0)) \lor ((x=1) \land (y=1)) \lor ((x=2) \land (y=2))$ on it (right)}
	\label{fig:varsDnf} 
\end{figure}

\noindent Similarly, a \viewN based on a conjunctive normal formal can be defined that may be more convenient, depending on the requirement/restriction.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and 
	\begin{align*}
		c(s) = &((\varstate[,i_1] \eqorneq \varval_{i_1}) \lor \dots \lor (\varstate[,i_{l_1}] \eqorneq \varval_{i_{l_1}})) \; \land \\
		&((\varstate[,i_{l_1+1}] \eqorneq \varval_{i_{l_1+1}}) \lor \dots \lor (\varstate[,i_{l_2}] \eqorneq \varval_{i_{l_2}})) \; \land \\
		&\dots \\ 
		&((\varstate[,i_{(l_{m-1})+1}] \eqorneq \varval_{i_{(l_{m-1})+1}}) \lor \dots \lor (\varstate[,i_{l_m}] \eqorneq \varval_{i_{l_m}}))
	\end{align*}
	
	proposition logical formula in disjunctive normal form where
	\begin{itemize}
			\item $\varstate[,i_k], a_{i_k} \in \varevalimg$ with $i_k\in \natnums$ and $k \in \{1, \dots, l_m\}$
			\item $l_1 < l_2 < \dots < l_m$ are natural numbers and $m$ is the number of clauses in $c(s)$
	\end{itemize}
	The \viewN \viewparamcnf is defined by its \grpfctN \gfctparamcnf where $\gfctsubparamcnf : \smstates \to \imggrp$ with
	\[
	\gfctsubparamcnf(\state) =
	\begin{cases}
			\remelem, &\text{if } c(\state) \text{ is true}\\
			\notppty, 	&\text{otherwise}
		\end{cases}
	\]
	where $\imggrp := \imggrpbinview$.
\end{definition}

The only difference between the \viewN \viewparamcnf and the \viewN \viewparamdnf is whether the respective formulas are in conjunctive or disjunctive normal form. Since any formula in conjunctive normal form can be transformed into a formula in disjunctive normal form, and vice versa \cite[Theorem 4.12]{Baier2011}, neither of the \viewsN can perform an action that the other cannot. Thus there is no difference in expressiveness, but there may be a difference in size. Therefore, both \viewsN have been implemented and formalized. For finite \chgphsN they provide an interface to perform any possible grouping on the state set using parameter values. Equality, equivalence classes, and the new state set behave and are constructed analogously to the \viewN \viewparamdnf.

The \viewsN discussed above reduce the \chgphN in a very precise but also manual manner, because it not only dictates the variable but also its value. A more general approach is to specify only the variable but not its value. This way states will be grouped that have the same value for that variable, but without any specification about the value for that variable.
%This idea could be achieved with a \viewN based on the \grpfctN $\grpfct[\varval_1 ]$%\pll \dots \pll \gfctparamvalueseqopt[\varval_n]]$ with $\redcomment{\vareval(\states, \var)} = \{\varval_1, \dots, \varval_n\}$ and $|\vareval(\states,\var)| = n$. This grouping function just groups on every possible value for the variable \var. Since this is \redcomment{not very practical} we define a \viewN that achieves this result in a more direct and more efficient way.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $x \in \vars$. The \viewN \viewparamvalident is defined by its \grpfctN \gfctparamvalident where $\gfctsubparamvalident : \smstates \to \imggrp$ with
	\[
	\state \mapsto (x,\vareval(\state,\var))
	\]
	and $\imggrp := \{\{x\} \times \varevalimg\} \cup \{\remelem\}$.
\end{definition}

This grouping function maps each state to a pair containing the given variable and its value in that state. The variable is included to enable composition with several \viewparamvalident. Hence for $\state_1, \state_2 \in \states$ it is $\gfctparamvalident(\state_1) = \gfctparamvalident(\state_2)$ \iffN they are mapped to the same value $\varval \in \imggrp$. Hence the equivalence classes of \eqrelview are
\[
\eqclassv = \{ \state' \in \states \mid \vareval(\state') = \vareval(\state)\}.
\]
By Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewparamvalident.

\begin{figure}[!htb]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}		
		\input{./04/images/variables/varsBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/variables/varValIdentAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp $\states = \{\varstyle{x}{y} \mid x,y \in \{0, 1, 2\}\}$ (left) and the \viewN $\viewparamvalident(x)$ on it (right).}
	\label{fig:varValIdent} 
\end{figure}

\begin{exmp}
	In Figure \ref{fig:varValIdent} we can observe the \viewN of $\viewparamvalident$ on \chgph. States are grouped in which $x$ has the same value. It is $x \in \{0, 1, 2\}$. The states $\varstyle{0}{0}, \varstyle{0}{1},\varstyle{0}{2}$ are mapped to the pair $(x,0)$, because in all of them it is $x=0$. In the same way $\varstyle{1}{0}, \varstyle{1}{1},\varstyle{1}{2}$ are grouped due to $x=1$ and $\varstyle{2}{0}, \varstyle{2}{1},\varstyle{2}{2}$ due to $x=2$.
\end{exmp}
\subsubsection{Property Values and Model Checking Results}
Apart from direct and indirect components of an \mdpN there are other values associated with states. These can be given by a reward structure or be results of model checking. A reward structure simply assigns values to each state. Model checking results are also available per state. 
%Although we do not want to go into detail with model checking in this thesis values determined by it are minimal and maximal probabilities or expected values (e.g. of rewards). 
We abstract from the exact type of value or its origin and formalize this notion with an arbitrary function that assigns a value to each state and utilizes it to define a \viewN. Note that there can be multiple such functions (e.g., a reward structure and multiple model checking results) for an \chgphN.

\begin{definition}
	The function $\propfct : \states \to \realnums$ is called \emph{property function}. It maps each state to a property value.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$, $r \in \realnums$ a granularity, $\propfct : \states \to \realnums$ a property function given and $Z =\bigcup_{i \in \integers}Z_i$ an by $r$ induced partition on \realnums where
	\[
		Z_i = 
		\begin{cases}
			[i \cdot r - \frac{r}{2}, i \cdot r + \frac{r}{2}), &\text{if } i > 0 \\
			(i \cdot r - \frac{r}{2}, i \cdot r + \frac{r}{2}), &\text{if } i = 0 \\
			(i \cdot r - \frac{r}{2}, i \cdot r + \frac{r}{2}]&\text{if } i < 0
		\end{cases}
%		\begin{cases}
%			[z_{min}, z_{min} + \frac{r}{2}), &\text{if } i=1 \\
%			[i \cdot r - \frac{r}{2}, i \cdot r + \frac{r}{2}), &\text{if } i\in\{2,\dots, n-1\} \\
%			(z_{max}-\frac{r}{2}, z_{max}, &\text{if } i = n
%		\end{cases}
	\]
%	where 
%\begin{align*}
%	z_{min} &= \min\propfct[\states] - (\min\propfct[\states] \text{ mod } r) \\
%	z_{max} &= \max\propfct[\states] - (\max\propfct[\states] \text{ mod } r) + \frac{r}{2}
%\end{align*}	
	The \viewN \viewprop is defined by its \grpfctN \gfctprop where $\gfctsubprop : \smstates \to \imggrp$ with
	\[
	\state \mapsto r \cdot i \quad\quad\quad \text{where } \propfct(\state) \in Z_i \in Z
	\]
	and $\imggrp = \realnums \cup \remset$.
\end{definition}

The smaller the granularity $r$, the more elements the partition has, and vice versa. In the implementation, for each state \state, the value $r \cdot i$ of $\propfct(\state)$ is determined directly by rounding. The formalization as in the definition above was chosen because it clearly formalizes the rounding behavior. Two states $\state_1, \state_2$ are grouped if $\gfctprop(\state_1) = \gfctprop(\state_2)$. Thus, the resulting equivalence classes are
\begin{align*}
	\eqclassv &= \{\state' \in \states \mid \gfctprop(\state') = \gfctprop(\state) =: r \cdot i\} \\
	&= \{\state' \in \states \mid \propfct(\state), \propfct(\state') \in Z_i\}
\end{align*}

\noindent By Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewprop.

\begin{figure}[!htb]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}
		\input{./04/images/property/propBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/property/propAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewprop(0.4)$ on it (right)}
	\label{fig:PropBeforeAfter} 
\end{figure}
\pagebreak
\begin{exmp}
	In Figure \ref{fig:PropBeforeAfter} we observe the \viewN $\viewprop(0.4)$ on \chgph. The by $r=0.4$ partition is $Z = \bigcup_{i \in \integers} Z_i$ where
\[
Z_i = 
\begin{cases}
	[i \cdot 0.4 - 0.2, i \cdot 0.4 + 0.2) \:\!= [0.4i - 0.2, 0.4i + 0.2) , &\text{if } i > 0 \\
	(i \cdot 0.4 - 0.2, i \cdot 0.4 + 0.2) = (-0.2, 0.2), &\text{if } i = 0 \\
	(i \cdot 0.4 - 0.2, i \cdot 0.4 + 0.2] \:\!= (0.4i - 0.2, 0.4i + 0.2], &\text{if } i < 0 \\
\end{cases}
\]
It is 
\begin{alignat*}{3}
	\propfct(\state_4)=-0.6, \propfct(\state_8)=-0.95, \propfct(\state_9) = -0.99 &\in Z_{-2} &&= [-1.8, -2.2) \\
%	[0.4 \cdot (-2) - 0.2, 0.4 \cdot (-2) + 0.2) = \\
	\propfct(\state_1)=0.1, \propfct(\state_{10})=0.15 &\in Z_0 &&= (-0.2, 0.2)\\
	\propfct(\state_2)=0.2, \propfct(\state_3)=0.41, \propfct(\state_6) = 0.59 &\in Z_1 &&= [0.2, 0.6) \\
%	= [0.4 \cdot 1 - 0.2, 0.4 \cdot 1 + 0.2) \\
	\propfct(\state_5)=0.93, \propfct(\state_{7})=2.06 &\in Z_5 &&= [1.8, 2.2) \\
%	= [0.4 \cdot 5 - 0.2, 0.4 \cdot 5 + 0.2) = [1.8, 2.2)\\	
\end{alignat*}
Hence it is
\begin{alignat*}{3}
 	\gfctprop(\state_4) = \gfctprop(\state_{8}) = \gfctprop(\state_{9}) &= 0.4\cdot(-2) &&= -0.8 \\
 	\gfctprop(\state_1) = \gfctprop(\state_{10}) &= 0.4\cdot0 &&= 0 \\
 	\gfctprop(\state_2) = \gfctprop(\state_{3}) = \gfctprop(\state_{6}) &= 0.4\cdot1 &&= 0.4 \\
 	\gfctprop(\state_5) = \gfctprop(\state_{7}) &= 0.4\cdot5 &&= 2 \\
\end{alignat*}
and states are grouped as displayed in the simplified representation of \viewprop.
\end{exmp}

\subsection{Views Utilizing the MDP Graphstructure}
\subsubsection{Distance}
Looking at distances in a graph can be very helpful to get an overview of a graph. Likewise it helps a lot with understanding the structure of \achgphN. In order to consider the distance between states in a \achgphN we need to formalize it. For this we will introduce \emph{paths}, which are conceptually very similar to execution fragments \cite[Def. 2.4.]{Baier2008}.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A (simple and finite) \emph{path} \path is a sequence \pathsecfull alternating between states and actions where $n \in \natnums, \{\state_1, \dots, \state_{n}\} \subseteq \states$ is a set of distinct states, $\{\action_1, \dots, \action_{n}\} \subseteq \actions$ and for all $i \in \{1, \dots, n\}$ it is $(\state_i,\action_i, \state_{i+1}) \in \trans$. 
	
	\noindent
	It is $\pfirst(\path) := \state_1$ and $\plast(\path) := \state_n$ and \pathset the set of all paths in \chgph.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A (simple and finite) \emph{undirected path} \pathbi is a sequence \pathsecfull alternating between states and actions where $n \in \natnums, \{\state_1, \dots, \state_{n}\} \subseteq \states$ is a set of distinct states, $\{\action_1, \dots, \action_{n}\} \subseteq \actions$ and for all $i \in \{1, \dots, n\}$ it is $(\state_i,\action_i, \state_{i+1}) \in \trans$ or $(\state_{i+1},\action_i, \state_{i}) \in \trans$. 
	
	\noindent
	It is $\pfirst(\pathbi) := \state_1$ and $\plast(\pathbi) := \state_n$ and \pathbiset the set of all undirected paths in \chgph.
\end{definition}

\begin{definition}
	\sloppy
	Let $\chgph = \chgphtuple$ be \achgphN and \path = \pathsecfull be a path in \chgph. The number $n =: \lenpath(\path)$ is called \emph{length} of the path \path. It corresponds to the number of transitions taken.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The \emph{distance} from a set of states $\states_1 \subseteq \states$ to a disjoint set of states $\states_2 \subseteq \states$ is length of the shortest path from a state $\state_1 \in \states_1$ to a $\state_2 \in \states_2$ or infinity if no such path exists. That is, if $\states_1 \cap \states_2 = \emptyset$ it is		
	\[
		\distpath(\chgph, \states_1, \states_2) := 
		\begin{cases}
			\min\{\lenpath(\path) \mid \path \in P_{\states_1 \to \states_2}\}, &\text{if } P_{\states_1 \to \states_2} \neq \emptyset \\
			\infty, &\text{otherwise}
		\end{cases}
	\]
	where $P_{\states_1 \to \states_2} := \{\path \in \pathset \mid \pfirst(\path) \in \states_1, \; \plast(\path) \in \states_2\}$. \\
	\noindent
	If $\states_1 \cap \states_2 \neq \emptyset$, it is $\distpath(\chgph, \states_1, \states_2) := 0$.
	\label{def:distance}
\end{definition}

%\begin{definition}
%	Let $\chgph = \chgphtuple$ be \achgphN. The \emph{reverse distance} from a set of states $\states_1 \subseteq \states$ to a disjoint set of states $\states_2 \subseteq \states$ is the length of the shortest path from a state $\state_2 \in \states_2$ to a $\state_1 \in \states_1$ or infinity if no such path exists. That is, if $\states_1 \cap \states_2 = \emptyset$ it is		
%	\[
%	\distpathrev(\chgph, \states_1, \states_2) := 
%	\begin{cases}
%		\min\{\lenpath(\path) \mid \path \in P_{\states_1 \leftarrow \states_2}\}, &\text{if } P_{\states_1 \leftarrow \states_2} \neq \emptyset \\
%		\infty, &\text{otherwise}
%	\end{cases}
%	\]
%	where $P_{\states_1 \leftarrow \states_2} := \{\path \in \pathset \mid \plast(\path) \in \states_1, \; \pfirst(\path) \in \states_2\}$. \\
%	\noindent
%	If $\states_1 \cap \states_2 \neq \emptyset$, it is $\distpathrev(\chgph, \states_1, \states_2) := 0$.
%\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The \emph{undirected distance} between disjoint $\states_1, \states_2 \subseteq \states$ is the length of the shortest undirected path from a state $\state_1 \in \states_1$ to a state $\state_2 \in \states_2$ or infinity if no such path exists. That is, if $\states_1 \cap \states_2 = \emptyset$ it is		
	\[
	\distpathbi(\chgph, \states_1, \states_2) := 
	\begin{cases}
		\min\{\lenpath(\pathbi) \mid \pathbi \in P_{\states_1 - \states_2}\}, &\text{if } P_{\states_1 - \states_2} \neq \emptyset \\
		\infty, &\text{otherwise}
	\end{cases}
	\]
	where $P_{\states_1 - \states_2} := \{\pathbi \in \pathbiset \mid \pfirst(\pathbi) \in \states_1, \; \plast(\pathbi) \in \states_2\}$. \\
	\noindent
	If $\states_1 \cap \states_2 \neq \emptyset$, it is $\distpathbi(\chgph, \states_1, \states_2) := 0$.
\end{definition}

For a given \chgphN \chgph with state set \states and $\state \in \states, \smstates \subseteq \states$ we write $\distpath(\mdp, \smstates, \state)$ for $\distpath(\mdp, \smstates, \{\state\})$ and $\distpath(\mdp, \state, \smstates)$ for $\distpath(\mdp, \{\state\}, \smstates)$. We do the same for \distpathbi. The symbol $\infty$ is used to indicate that there is no path and therefore the distance is "infinite". We will compare against the symbol with equality to rule out whether there is a path from one set of states to the other.
To apply the notion of distance to the entire \mdpN graph with a view, it must be done in a way where a distance is computed for each state. Therefore, some set of states is needed, from which the distance for the remaining states is measured. Such a set could be for example the set of initial states or any other set of interest. In each \viewN using distance it is denoted by $\bar{\states}$. We will also consider a granularity $\grandist \in \natnums$. The following \viewN groups states that are reachable with the same number of transitions $\bar{\states} \subseteq \states$ considering the granularity \grandist.

\begin{definition}
		Let $\chgph = \chgphtuple$ be \achgphN, $\bar{\states} \subseteq \smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewdistance is defined by its \grpfctN \gfctdistance where $\gfctsubdistance : \smstates \to \imggrp$ with 
		\[
		\gfctdistance(\state) =
		\begin{cases}
			 \distval - (\distval \text{ mod } n), &\text{if } d \neq \infty \\
			 \infty, &\text{otherwise}
		\end{cases}		
		\]
		where $\distval = \distpath(\chgph,\bar{\states}, \state)$ and $\imggrp = \natnums \cup \{\infty\} \cup \remset$.
\end{definition}

The number $n$ from the definition is the granularity of the distance cluster. For example, if the granularity is two ($n = 2$), the expression $d - (d \text { mod } n)$ evaluates to $0 - 0 = 0$ for $d = 0$, to $1 - 1 = 0$ for $d = 1$, to $2 - 0 = 2$ for $d = 2$, and to $3 - 1 = 2$ for $d = 3$, where the subtrahend is $d \text { mod } 2$. We see that \gfctdistance maps $\distpath(\chgph,\smstates, \state)$, if not infinite, to the next smaller natural number divisible by $n$, which means that the granularity causes $\gfctdistance(\state)$ to be a multiple of $n$.

%In \viewdistance two states $\state_1, \state_2 \in \states$ are grouped \iffN $\gfctdistance(\state_1) = \gfctdistance(\state_2)$. Hence the equivalence classes in \eqrelview are 
By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are
\begin{alignat*}{3}
	\eqclassv &= \{\state' \in \states \mid \gfctdistance(\state') = \gfctdistance(\state) = \tilde{d} \in \natnums\} \quad\quad\quad &&\text{if } \distpath(\chgph, \bar{\states}, \state) \neq \infty \\
	\eqclassv &= \{\state \in \states \mid \gfctdistance(\state) = \infty\} &&\text{otherwise } 
\end{alignat*}
Thereby the obtained set of states $\states'$ of \viewparamvalueseq is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where
\begin{align*}
	\states_1 &:= \{\{\state \in \states \mid \distpath(\chgph, \bar{\states}, \state) = \distval - (\distval \text{ mod } n) =: \tilde{d} \neq \infty\} \mid \tilde{d} \in \gfctdistance[\states]\} \\
	&\;= \{\{\state \in \states \mid \gfctdistance(\chgph, \bar{\states}, \state) = \distval - (\distval \text{ mod } n) =: \tilde{d} \neq \infty\} \mid \tilde{d} \in \gfctdistance[\states]\} \text{ and}\\
	\states_2 &:= \{\{\state \in \states \mid \distpath(\chgph, \bar{\states}, \state) = \infty\}\} = \{\{\state \in \states \mid \gfctdistance(\state) = \infty\}\}.
\end{align*}

\begin{figure}[!htb]
	\begin{minipage}{.45\textwidth}
		%		\hspace{5mm}		
		\input{./04/images/distance/distBefore}
	\end{minipage}%
	\begin{minipage}{.20\textwidth}
		\input{./04/images/distance/distForwAfter}
	\end{minipage}
	\hspace{-6pt}
	\begin{minipage}{.35\textwidth}
%		\hspace{30mm}
		\vspace{1.7mm}
		\input{./04/images/distance/distForwGran2After}
	\end{minipage}	
	\caption{Simplified representations of \mdp (left), the \viewsN $\viewdistance(\{\state_1, \state_6\}, 1)$ (middle) and $\viewdistance(\{\state_1, \state_6\}, 2)$ on it (right).}
	\label{fig:Distance} 
\end{figure}

\begin{exmp}
	In Figure \ref{fig:Distance} we can observe the \viewsN $\viewdistance(\{\state_1, \state_6\}, 1)$ (middle) and $\viewdistance(\{\state_1, \state_6\}, 2)$ (right) on \chgph. It is
\begin{alignat*}{4}
	\distpath(\chgph, \{\state_1, \state_6\}, \state_i) &= 0 \text{ for } i \in \{1,6\}, \quad &&\distpath(\chgph, \{\state_1, \state_6\}, \state_i) = 1 \text{ for } i \in \{2,3,7,8\},\\
	\distpath(\chgph, \{\state_1, \state_6\}, \state_i) &= 2 \text{ for } i = 4, \quad &&\distpath(\chgph, \{\state_1, \state_6\}, \state_i) = \infty \text{ for } i \in \{5,9,10\}
\end{alignat*}
This is how we obtain, the set of states of $\viewdistance(\{\state_1, \state_6\}, 1)$ as displayed in the figure. For $\viewdistance(\{\state_1, \state_6\}, 2)$ (right) the states $\{\state_1, \state_6\}$ and $\{\state_2, \state_3, \state_7, \state_8\}$ of $\viewdistance(\{\state_1, \state_6\}, 1)$ (middle) merge into one, as $\gfctdistance(\state_i) = 0 - (0 \text{ mod } 2) = 0 = 1 - (1 \text{ mod } 2) = \gfctdistance(\state_j)$ for $j \in \{1,6\}$ and $i \in \{2,3,7,8\}$. displayed in the figure. For $\viewdistance(\{\state_1, \state_6\}, 2)$ (right) the states $\{\state_1, \state_6\}$ and $\{\state_2, \state_3, \state_7, \state_8\}$ of $\viewdistance(\{\state_1, \state_6\}, 1)$ (middle) merge into one, as $\gfctdistance(\state_i) = 0 - (0 \text{ mod } 2) = 0 = 1 - (1 \text{ mod } 2) = \gfctdistance(\state_j)$ for $j \in \{1,6\}$ and $i \in \{2,3,7,8\}$.
\end{exmp}

The \viewN \viewdistance groups states that are reachable with the same number of transitions from a given set of states. It can be used to give a perspective on the structure of an \mdpN, but cannot be used to deduce how a state or set of states was reached. How a given state was reached is a common case of interest, since there are states in a system that should be reached and others that should not or even must not be reached. To provide an aid to investigating how a state was reached, we define a \viewN that groups states that have the same distance from a given state when traversing transitions backwards.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\bar{\states} \subseteq \smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewdistancerev is defined by its \grpfctN \gfctdistancerev where $\gfctsubdistancerev : \smstates \to \imggrp$ with 
	\[
	\gfctdistancerev(\state) =
	\begin{cases}
		\distval - (\distval \text{ mod } n), &\text{if } d \neq \infty \\
		\infty, &\text{otherwise}
	\end{cases}		
	\]
	where $\distval = \distpath(\chgph,\state,\bar{\states})$ and $\imggrp = \natnums \cup \{\infty\} \cup \remset$.
\end{definition}

Note that the only difference between \viewdistancerev and \viewdistance is that it is $\distpath(\chgph,\state,\bar{\states})$ instead of $\distpath(\chgph,\bar{\states}, \state)$. By definition \ref{def:distance} this declares that paths from \state to $\bar{\states}$ are considered instead of paths from $\bar{\states}$ to \state. Thus, the distance from the set $\bar{\states}$ is measured by traversing transitions backwards. This causes states that reach $\bar{\states}$ with the same number of transitions to be grouped together. Nevertheless, on a formal level, equality, equivalence classes, and the new state set behave and are constructed analogously to the \viewN \viewdistance.

For cases where the direction of transitions is of no further importance we define a \viewN \viewdistancebi utilizing \distpathbi. This, causes that the direction of that transitions regularly have is ignored.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\bar{\states} \subseteq \smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewdistancebi is defined by its \grpfctN \gfctdistancebi where $\gfctsubdistancebi : \smstates \to \imggrp$ with 
	\[
	\gfctdistancebi(\state) =
	\begin{cases}
		\distval - (\distval \text{ mod } n), &\text{if } d \neq \infty \\
		\infty, &\text{otherwise}
	\end{cases}		
	\]
	where $\distval = \distpathbi(\chgph,\bar{\states}, \state)$ and $\imggrp = \natnums \cup \{\infty\} \cup \remset$.
\end{definition}

The only difference of \viewdistancebi to \viewdistance is that \distpathbi is used instead of \distpath. Hence, we omit explaining behavior and construction of equality, equivalence classes and the new state set.

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\hspace{15mm}		
		\centering \input{./04/images/distance/distRevAfter}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{10mm}		
		\centering \input{./04/images/distance/distBiAfter}
	\end{minipage}	
	\caption{Simplified representations of the \viewsN $\viewdistancerev(\{\state_1, \state_6\}, 1)$ (middle) and $\viewdistancebi(\{\state_1, \state_9\}, 1)$ (right) on the \chgph from Figure \ref{fig:Distance}.} 
	\label{fig:DistanceRevBi} 
\end{figure}

In the implementation, a simple breadth-first search is used to determine the distance values from a given state set to each state. There is no need for an algorithm like Dijkstra, since the weights on the edges are probabilities, not values that can be interpreted as cost or distance. The implementation ensures that for each state $\state$ there is a pair $(\state, \distval)$ in \fctdistdefault, i.e. $\infty$ if there is no path to a given state. The Java code of the grouping function for the \viewsN based on distance can be found in the appendix (\ref{apx:distancejava}). All three views are implemented in a single Java class and thus share their grouping function. The results of which grouping function are computed, depends on the value of the enum \texttt{direction}. It is set when an instance of the view is created.

\subsubsection{Cycles}
A cycle is a structure that can exist in any graph. The concept of cycles is not limited to \chgphsN or related models used in model checking. The goal of this thesis is to discuss \viewsN that use domain-specific knowledge or general concepts that are of particular relevance when exploring \achgphN. In general, cycles are worth exploring because they can lead to unwanted infinite results in model checking. In addition, when exploring \viewsN, the concept of cycles can be adapted to include \mdpsN properties. To formalize \viewsN based on cycles, we need to formalize the cycle concept itself. We will define it in a way that best suits our specific domain.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A (simple) \emph{cycle} \cycle in \chgph is a sequence \cyclesecfull alternating between states and actions where $n \in \natnums, \{\state_0, \dots, \state_{n-1}\} \subseteq \states$ is a set of distinct states, $\{\action_0, \dots, \action_{n-1}\} \subseteq \actions$ and for all $i \in \{0, \dots, n-1\}$ it is $(\state_i,\action_i, \state_{i+1 \text{ mod }n}) \in \trans$.
\end{definition}

%When the actions in the cycle are of no further importance, we will omit them only writing a sequence of states. 
In the following let $\cycle = \cyclesecfull$ be a cycle. For convenience we will write $\state \in \cycle$ if the state is contained in the cycle \cycle and $\action \in \cycle$ if the action is contained in in the cycle \cycle. In words we will both write a state or action is \emph{on} or \emph{in} the cycle.

\begin{definition}
	Let \cycle be an cycle in \chgph and \states be the states set of \chgph. The number $|\{\state \in \states \mid \state \in \cycle\}| =: \lencycle(\cycle)$ is called the \emph{length} of a cycle. 
\end{definition}

\begin{definition}
	Let $\chgph$ be an \chgphN. The set $\cycleset := \{ \cycle \mid \lencycle(\cycle) \geq n\}$ declares the set of all cycles in \chgph with a length of at least $n$.
\end{definition}
%and Tiernan - $O(V.constV)$ CITATION!!}

With the formalization now complete, we will proceed to introduce several \viewsN that leverage the concept of cycles. Firstly, we will present \viewsN that make use of the overall cycle concept, and secondly, we'll integrate the cycle concept with specific knowledge about the subject. Cycles, in a general sense, are intriguing because unintended cycles can often result in infinite values when checking models. In many instances, these infinite values in model checks are undesired and stem from flawed model construction. Detecting these cycles can be helpful in diagnosing \achgphN. Therefore, creating a \viewN that solely identifies existing cycles is achievable.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewhascycle is defined by its \grpfctN \gfcthascycle where $\gfctsubhascycle : \smstates \to \imggrp$ with
	\[
	\gfctsubhascycle(\state) =
	\begin{cases}
			\remelem, &\text{if } \exists \cycle \in \cycleset : \state \in \cycle \\
			\notppty, &\text{otherwise}
		\end{cases}
	\]
	and $\imggrp = \{\group, \remelem\}$.
\end{definition}

This \viewN groups all states that are contained in a cycle with a length of at least $n$. Thus, this \viewN can also find self-loops for $n \in \natnums$. Note that the affinity of a state to one or more corresponding cycles is lost. 
%For $\state_1, \state_2$ they are grouped $\gfcthascycle(\state_1) = \gfcthascycle(\state_2) \neq \remelem$. Hence, the obtained equivalence classes are
\noindent By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are
\begin{alignat*}{3}
	\eqclassv &= \{\state \in \states \mid \gfcthascycle(\state) = \remelem\} = \{\state\} \quad\quad\quad\quad&&\text{if } \exists \cycle \in \cycleset : \state \in \cycle \\
	\eqclassv &= \{\state \in \states \mid \gfcthascycle(\state) = \notppty\} &&\text{otherwise}
\end{alignat*}

\noindent The set of states $\states'$ of \viewhascycle is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states, \,\text{if } \exists \cycle \in \cycleset : \state \in \cycle\} \\
	&\;= \{\{\state\} \mid \state \in \states, \, \gfcthascycle(\state) = \remelem\} = \nogroupstates \\
	\states_2 &:= \{\{\state \in \states \mid \text{if } \exists \cycle \in \cycleset : \state \in \cycle \}\} = \{\{\state \in \states \mid \gfcthascycle(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[!htb]
	\centering
	\input{./04/images/cycles/cyclesBefore}			
	\caption{Simplified representation of \mdp}
	\label{fig:cyclesBefore} 
\end{figure}

\begin{figure}[!htb]
	\centering
	\input{./04/images/cycles/cyclesAfterHas}
	\caption{Simplified representations of the \viewN \viewhascycle on \chgph from Figure \ref{fig:cyclesBefore}. The states $\state_{12}$ and $\state_{13}$ are grouped since they are the only states not on a cycle.}
	\label{fig:cycleAfterHas} 
\end{figure}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewexactcycle is defined by its \grpfctN \gfctexactcycle where $\gfctsubexactcycle : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\cycle \in \cycleset \mid \state \in \cycle\}
	\]
	
	and $\imggrp = \powerset{\cycleset}\cup \remset.$
	\label{def:exactcycleview}
\end{definition}

This \viewN groups states that have the same set of cycles they are contained in. Thus if $\cycle_1$ and $\cycle_2$ are distinct cycles and $\state_1, \state_2 \in \cycle_1$ and $\state_1 \in \cycle_2$ but $\state_2 \notin \cycle_2$ they are not grouped. It suffices that a state is on one cycle that the other one is not on, in order for the states not being grouped. In graphs with many cycles this can lead to little grouping.

%Two states $\state_1, \state_2$ are grouped if $\gfctexactcycle(\state_1) = \gfctexactcycle(\state_2) \neq \remelem$. Hence, the obtained equivalence classes are
\noindent By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are
\begin{align*}
	\eqclassv &= \{\state' \in \states \mid \gfctexactcycle(\state') = \gfctexactcycle(\state) = \{\cycle_1, \dots, \cycle_n\} \subseteq \cycleset\}
\end{align*}
\noindent By Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewexactcycle.

%\redcomment{GREEDY APPROACHES (STATE ON SINGLE CYCLE), AND SET APPROACH s $\to$ $C_1 \cup C_2$ omitted because not sure if needed}

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
%		\hspace{5mm}
		\input{./04/images/cycles/cyclesAfterExact0}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/cycles/cyclesAfterExact5}
	\end{minipage}
	\caption{\viewNC $\viewexactcycle(2)$ (left) and \viewN $\viewexactcycle(5)$ (right) on \chgph from Figure \ref{fig:cyclesBefore}}
	\label{fig:cycleAfterExtact} 
\end{figure}

\begin{exmp}
	In Figure \ref{fig:cycleAfterExtact} we can observe the \viewsN of $\viewexactcycle(2)$ and $\viewexactcycle(5)$ on \chgph from Figure \ref{fig:cyclesBefore}. In the simplified representation of \achgphN, we find six cycles of size at least two:
\begin{align*}
	\cycle_1 &= (\state_1, \action, \state_2, \action, \state_3, \actionb, \state_4, \actionb, \state_5, \actionb, \state_6, \actionb, \state_7, \action, \state_8, \actionb, \state_1) \\
	\cycle_2 &= (\state_1, \action, \state_2, \action, \state_3, \action, \state_7, \action, \state_8, \actionb, \state_1) \\
	\cycle_3 &= (\state_3, \actionb, \state_4, \actionb, \state_5, \actionb, \state_6, \actionb, \state_7, \actionb, \state_3) \\
	\cycle_4 &= (\state_7, \actionc, \state_9, \actionc, \state_{10}, \actionc, \state_{11}, \actionc, \state_7) \\
	\cycle_5 &= (\state_1, \action, \state_2, \actionc, \state_7, \action, \state_8, \actionb, \state_1) \\
	\cycle_6 &= (\state_3, \action, \state_7, \actionb, \state_3)
\end{align*}
\viewNC $\viewexactcycle(2)$ results as displayed as in the simplified representation on the left because because the following states are contained in exactly these cycles
\begin{align*}
	\state_1, \state_2, \state_8 &\text{ in } \cycle_1, \cycle_2, \cycle_5 \\
	\state_3 &\text{ in } \cycle_1, \cycle_2, \cycle_3, \cycle_5, \cycle_6 \\
	\state_7 &\text{ in } \cycle_1, \cycle_2, \cycle_3, \cycle_4, \cycle_5, \cycle_6 \\
	\state_4, \state_5, \state_6 &\text{ in } \cycle_1, \cycle_3 \\
	\state_9, \state_{10}, \state_{11} &\text{ in } \cycle_4
\end{align*}
and $\state_{12}$ and $\state_{13}$ are contained in no cycle of size at least two, i.e. $\gfctexactcycle(\state_{12}) = \gfctexactcycle(\state_{13}) = \emptyset$. For the $\viewexactcycle(5)$ it is $\cycle_{\chgph, 5} = \{\cycle_1, \cycle_2, \cycle_3\}$. Thereby we have the following states being exactly contained in these cycles:
\begin{align*}
	\state_1, \state_2, \state_8 &\text{ in } \cycle_1, \cycle_2 \\
	\state_3 &\text{ in } \cycle_1, \cycle_2, \cycle_3 \\
	\state_7 &\text{ in } \cycle_1, \cycle_2, \cycle_3 \\
	\state_4, \state_5, \state_6 &\text{ in } \cycle_1, \cycle_3
\end{align*}
and $\gfctexactcycle(\state) = \emptyset$ for all remaining states \state.
\end{exmp}

The above \viewN might be useful when having found cycles to see what cycles specifically exist. It may be interesting to find cycles consisting only of transitions of the same action. The following \viewN accomplishes that.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewexactactcycle is defined by its \grpfctN \gfctexactactcycle where $\gfctsubexactactcycle : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\cycle \in \cycleset \mid \state \in \cycle, \tilde{\action} \in \cycle, \forall \action \in \cycle : \action = \tilde{\action} \}
	\]
	
	and $\imggrp = \powerset{\cycleset} \cup \remset.$
\end{definition}

The \viewN specializes the \viewN from Definition \ref{def:exactcycleview} in the sense that it additionally requires for all $\cycle \in \gfctexactcycle$ that all actions occurring in the cycle are the same. The reasoning about the equality of the \grpfctN values, the obtained equivalence classes and the resulting set of states $\states'$ of the \viewN is analogous to \viewexactcycle and thus omitted.

\begin{figure}[!htb]
	\centering	
	\input{./04/images/cycles/cyclesAfterExactAct0}	
	\caption{Simplified representation of the \viewN \viewcycleset on \mdp from Figure \ref{fig:cyclesBefore}}
	\label{fig:cycleAfterExactAct2}
\end{figure}

\begin{exmp}
	In Figure \ref{fig:cycleAfterExactAct2} the simplified representation of $\viewexactactcycle(2)$ on \chgph from Figure \ref{fig:cyclesBefore} can be observed. From cycles listed in the discussion of Figure \ref{fig:cycleAfterExtact} only $\cycle_3$ and $\cycle_4$ consist of transitions with the same actions, i.e. only $\cycle_3, \cycle_4 \in \gfctexactactcycle[\states]$ for $n = 2$. The \viewN \viewexactactcycle in Figure \ref{fig:cycleAfterExactAct2} results because the following states are contained in exactly these cycles

\begin{align*}
	\state_3, \state_4, \state_5, \state_6 &\text{ in } \cycle_3 \\
	\state_7 &\text{ in } \cycle_3, \cycle_4 \\
	\state_9, \state_{10}, \state_{11} &\text{ in } \cycle_4
\end{align*}
and for all remaining states \states it is $\gfctexactactcycle(\state) = \emptyset$.
\end{exmp}

When discussing the \viewN \viewexactcycle from the Definition \ref{def:exactcycleview}, we noted that little grouping can occur when mapping to the set of cycles in which the state is contained. Therefore, we provide the definition and implementation of a \viewN that groups states even if their set of cycles is not the same, but there is enough similarity in the cycles they are on. This may be useful for finding clusters of cycles.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewcycleset is defined by its \grpfctN \gfctcycleset where $\gfctsubcycleset : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\smstate \in \states \mid \state, \smstate \in \cycle \in \cycleset\}
	\]
	and $\imggrp = \states \cup \remset.$
\end{definition}
With this \viewN each state \state is mapped to the set of states. The set contains all the states from cycles, where the state \state is contained. By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are By Definition \ref{def:eqrelview} the equivalence classes of \eqrelview on \states are
\begin{align*}
	\eqclassv &= \{\state' \in \states \mid \gfctexactcycle(\state') = \gfctexactcycle(\state) = \{\state_1, \dots, \state_n\} \subseteq \{\cycle_1, \dots, \cycle_n\} \subseteq \cycleset\}
\end{align*}
\noindent By Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewexactcycle.
\begin{figure}[!htb]
	\centering
	\input{./04/images/cycles/cyclesAfterSet0}
	\caption{Simplified representation of the \viewN $\viewcycleset(2)$ on \mdp from Figure \ref{fig:cyclesBefore}} 
	\label{fig:cycleAfterSet0} 
\end{figure}
\begin{exmp}
	In Figure \ref{fig:cycleAfterSet0} the simplified representation of $\viewcycleset(2)$ on \chgph from Figure \ref{fig:cyclesBefore} can be observed. Since it is $n=2$ we consider the same cycles as in the discussion of Figure \ref{fig:cycleAfterExtact}. 
%It is $\state_1, \dots, \state_8 \in \cycle_1$. 
For $i \in \{1, \dots, 8\}$ it is $\gfctcycleset(\state_i) \subseteq \{\state_1, \dots, \state_8\}$, because they are all on cycle $\cycle_1$. For $\state \in \{\state_1, \dots, \state_8\} \setminus \{\state_7\}$ there is no cycle containing any other state than $\{\state_1, \dots, \state_8\}$. Thus, for $i \in \{1, \dots, 8\}$ it is $\gfctcycleset(\state_i) = \{\state_1, \dots, \state_8\}$. For the state $\state_7$ it is $\gfctcycleset(\state_7) = \states \setminus \{\state_{12}, \state_{13}\}$ because of $\state_7 \in \cycle_1,\cycle_4$ and $\state_{12}, \state_{13}$ are contained in no cycle of length at least two. Also because $\state_{12}, \state_{13}$ are contained in no cycle of length at least two it is $\gfctcycleset(\state_{12}) = \gfctcycleset(\state_{13}) = \emptyset$. Obviously for $\state_9, \state_{10}, \state_{11}$ it is $\gfctcycleset(\state_i) = \{\state_7, \state_9, \state_{10}, \state_{11}\}$ because it is only $\state_9, \state_{10}, \state_{11} \in \cycle_4$ as $\state_7$ denies them being on any other (\emph{simple}) cycle. Thereby the grouping results in a \viewN as depicted as simplified representation in Figure \ref{fig:cycleAfterSet0}.
\end{exmp}

In practice, there are several cycle-finding algorithms to determine the set $\cycleset_{\chgph,0}$. The actual implementation is based on algorithms of the Java library \jgrapht \cite{Michail2020}, namely the Szwarcfiter and Lauer algorithm \cite{Szwarcfiter1976}. It has a theoretical complexity of $O(V+EC)$. If in $\cycleset_{\chgph,n}$ $n$ was greater than one, then the cycles found are filtered, keeping those with a minimum length of $n$.

\subsubsection{Strongly Connected Components}
Strongly connected components (\sccsN) are interesting when exploring \achgphN because they group states where some complex operation may happen. Moreover, finding strongly connected components is much more efficient than finding cycles. Since every cycle is also a strongly connected component, finding strongly connected components can be seen as finding a set containing cycles. Therefore, we want to consider a \viewN that uses strongly connected components. Contrary to most definitions, we will not define \sccN as a subgraph, but only as the set of its nodes - specifically, in our context, a set of states. The definition is written in terms of \achgphN.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. A set $\scc \subseteq \states$ is called \emph{strongly connected component} if for all $\state, \state' \in \scc$ either it holds
	\[
		\exists \path \in \pathset : \pfirst(\path) = \state \land \; \plast(\path) = \state'
	\]
	{\centering{or}}
	\[
	 \state = \state'\text{.}
	\]
	
%	\begin{align*}
%			\scc = \{\state_1 \in \states \mid & \; \forall \state' \in \scc : \exists n \in \natnums, \exists \; \! (\state_1, \action_1, \state_2, \action_2 \dots, \state_n, \action_n, \state') \\
%			&\text{ where } (\state_n, \action_n, \state') \in \trans \land \forall i \in \{1, \dots, n-1\} : (\state_i, \action_i, \state_{i+1}) \in \trans \}
%	\end{align*}
%	That is for every state in the set there has to exist a sequence of transitions to every other state of the set. The state itself is always considered a reachable by itself, i.e. there does not need to exist a self loop. In consequence, each state is contained in stronlgy connected component namely at least in the one that only contains the state. 
	\noindent
	The set of all strongly connected components of \chgph containing at least $n$ states is denoted by \setscc.
\end{definition}

Since the strong connection is an equivalence relation, the \sccsN are equivalence classes and thus disjoint. To find \sccsN, Tarjan and Sahir's algorithm is the classic \cite{Sharir1981}. It has a theoretical complexity of $O(n)$. The implementation uses an improved variant of Gabow's \cite{Gabow2000}, provided by the \jgrapht library.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewscc is defined by its \grpfctN \gfctscc where $\gfctsubscc : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\scc \in \setscc \mid \state \in \scc\}
	\]
	and $\imggrp = \setscc \cup \remset$.
\end{definition}

This \viewN groups all states together that are in the same \sccN. Note that for all states \state, \gfctscc(\state) is a singleton set because \sccsN are disjoint. That is, each state is mapped to the set only containing only its strongly connected component, or to the empty set if its \sccN has less than $n$ elements. In the \viewN \viewscc two states $\state_1, \state_2 \in \states$ are grouped if $\gfctscc(\state_1) = \gfctscc(\state_2) \neq \remelem$. Hence the equivalence classes are:
\begin{align*}
	\eqclassv &= \{\state' \in \states \mid \gfctscc(\state') = \gfctscc(\state) =: \scc \in \setscc\} \quad\quad\quad \text{for } \state \in \scc
\end{align*}
By Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewexactcycle.

\begin{figure}[!htb]
	\begin{minipage}{.55\textwidth}
		\hspace{5mm}
		\input{./04/images/sccs/sccBefore}
	\end{minipage}
	\begin{minipage}{.5\textwidth}
%		\hspace{5mm}
		\input{./04/images/sccs/sccAfter}
	\end{minipage}
		\caption{Simplified representations of \mdp (left) and the \viewN $\viewscc(2)$ on it (right)}
		\label{fig:sccMin2} 
\end{figure}

\begin{exmp}
	\sloppy In Figure \ref{fig:sccMin2} the simplified representation of $\viewscc(2)$ (right) on \chgph (left) can be observed.. The \sccsN in \chgph are $\{\state_1\}, \{\state_2, \state_3, \state_4, \state_5\}, \{\state_6, \state_7, \state_8, \state_9\}, \{\state_{10}, \state_{11}, \state_{12}\}$ and $\{\state_{13}\}$. Because the \sccN of state $\state_{13}$ has not cardinality two but one it is mapped to the empty set and would be grouped with any other \state whoms strongly connected component has less than two elements.
\end{exmp}

\noindent A special kind of strongly connected components are the bottom strongly connected components. They can be interesting for deadlock detection and liveness analysis.

\begin{definition}
	Let \scc be a \sccN. A \emph{bottom strongly connected component} (\bsccN) is a \sccN where it holds that:
	\[
	\forall \state \in \scc : \forall (\state, \action, \state') \in \trans : \state' \in \scc
	\]
%	\[
%	\forall \state \in \scc : \bigsum{t \in \scc} \trans(\state, t) = 1
%	\]
	That is, from \scc there is no state reachable outside of \scc. The set of all bottom strongly connected components of \chgph, that contain at least $n$ states, is denoted with \setbscc.
\end{definition}

\noindent Bottom strongly connected components are of relevance because they pose a terminal structure of an \chgph that can not be left.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. The \viewN \viewbscc is defined by its \grpfctN \gfctbscc where $\gfctsubbscc : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\scc \in \setbscc \mid \state \in \scc\}
	\]
	and $\imggrp = \setbscc \cup \remset$.
\end{definition}

The \viewN \viewbscc groups together all states that are in the same \bsccN. In a sense, it is a specialization of \viewscc, because instead of all \sccsN, the set is restricted to those where there is no outgoing transition to another \sccN. Thus, equality, equivalence classes, and the state set behave and are constructed very similarly, and will not be discussed again here.

\begin{figure}[!t]
	\begin{minipage}{.55\textwidth}
		\hspace{5mm}
		\input{./04/images/sccs/sccBefore}
	\end{minipage}
	\begin{minipage}{.5\textwidth}		
		\input{./04/images/sccs/bsccAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN \viewbscc(0) on it (right)}
	\label{fig:bsccAfter} 
\end{figure}

\begin{exmp}
	\sloppy In Figure \ref{fig:bsccAfter} the simplified representation of $\viewbscc(0)$ (right) on \chgph (left) can be observed. The \sccsN in \chgph are $\{\state_1\}, \{\state_2, \state_3, \state_4, \state_5\}, \{\state_6, \state_7, \state_8, \state_9\}, \{\state_{10}, \state_{11}, \state_{12}\}$ and $\{\state_{13}\}$. The only ones where there is no state with an outgoing transition to a state in another \sccN are $\{\state_6, \state_7, \state_8, \state_9\}$ and $\{\state_{13}\}$. Hence, these two sets of states become a new state \viewbscc while all remaining states are mapped to $\emptyset$ and thereby grouped together.
\end{exmp}

In the implementation, bottom strongly connected components are also determined using Gabow's algorithm, and then those \sccsN that have only transitions to states within the \sccN are filtered. Only the bottom strongly connected components remain.
	
\end{document} 
