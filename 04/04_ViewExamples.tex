\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}


\begin{document} 
\section{View Examples} \label{ch:viewexmp}
In this chapter we will introduce and discuss some \viewN examples created by the author. Their purpose is to understand the idea and concept of a \viewN and get to know some views that might be useful in real world applications. \\
When considering \viewsN we only want to take into account those that utilize properties of MDPs or that do computations that are also feasible on normal graphs but are of explicit relevance MDPs.
\subsection{Views Utilizing MDP Components}
In this subsection we will introduce some views the are purely based on the components of an \mdpN. Their will neither be computations on the graph-structure of an MDP nor computations using the result vector.
\subsubsection{Atomic Propositions}
One of the least involved approaches to create a view is to base it on the atomic propositions that are assigned to each state by the labeling function. The notion is to group states that were assigned the same set of atomic propositions. \redcomment{Why useful?, currently no "has AP" $\to$ maybe should be added}


%\begin{figure}[h]
%	\begin{minipage}{.6\textwidth}
%		%		\hspace{5mm}
%		\input{./04/images/ap/apBefore}
%	\end{minipage}%
%	\begin{minipage}{.5\textwidth}
%		\input{./04/images/ap/apHasAfter}
%	\end{minipage}
%	\caption{Simplified representations of \mdp (left) and the \viewN \viewatomicprops on it (right)}
%	\label{fig:apHasBeforeAfter}  
%\end{figure}


\begin{definition}	
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. The view \viewatomicprops is defined by its \grpfctN \gfctatomicprops where $\gfctsubatomicprops : \smstates \to \imggrp, {\state}\mapsto{\labelingfct(\state)}$.
\end{definition}

The grouping function is exactly the labeling function i.e. for all $\state \in \states$ it is $\gfctatomicprops(\state) := \labelingfct(\state)$. So it is $\gfctatomicprops(\state_1) = \gfctatomicprops(\state_2) \iff \labelingfct(\state_1) = \labelingfct(\state_2)$. According to Definition \ref{def:eqrelview} for $\smstate \in \states$ it is $\eqclassv[\smstate] = \{\state \in \states \mid \labelingfct(\state) = \labelingfct(\smstate)\}$.
%$\forall \state_1, \state_2 \in \states :

By this we obtain the \viewN $\viewatomicprops$ for a given \chgphN \chgph where: $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =  \bigcup_{a \in \atomicprops} \{\{\state \in \states \mid \labelingfct(\state) = a\}\}$. All other components are constructed as in Definition \ref{def:view}.

\begin{figure}[h]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}
		\input{./04/images/ap/apBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/ap/apIdentAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN \viewatomicprops on it (right)}
	\label{fig:apIdentBeforeAfter}  
\end{figure}

In Figure \ref{fig:apIdentBeforeAfter} we can observe the effect of \viewatomicprops. In the simplified representation on the left the assigned set of atomic propositions of each state are noted next to them. There are four different sets of atomic propositions: $\{\}, \{a\}, \{b\} \text{ and } \{a,b\}$. In the view on the right the states with the same set of atomic propositions have been grouped.

Although this view might seem rather simple because essentially it only performs $\gfctatomicprops := \labelingfct$ it is the most powerful one. This is because every view presented in the following is reducible to this one. That is because a \grpfctN essentially asserts an atomic proposition to every state, namely the value with respect to the considered property of a given \viewN. The reduction can be realized by replacing the labeling function with the grouping function of the resepective \viewN. That is $\labelingfct := \grpfct$ and $\atomicprops := {\grpfct}[\states]$ for some \grpfctN \grpfct. While this works it alters the underlying \chgphN.

\subsubsection{Initial States}
An a little more involved idea than directly using a given function is to utilize the set of initial states. We can group states that have a probability greater zero, that they are started from. In practice this might be useful to quickly find all initial states.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\initstates := \{\state \in \states \mid \state \in \init\}$. The \viewN \viewinitstates is defined by its \grpfctN \gfctinitstates where $\gfctsubinitstates : \smstates \to \imggrp$ with 
	
	\[
	\gfctsubinitstates(\state) =
	\begin{cases}
			\remelem,				& \text{if } \state \in \initstates \\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	and $\imggrp := \imggrpbinview$.
\end{definition}

For $\state_1,\state_2 \in \states$ it is $\gfctinitstates(\state_1) = \gfctinitstates(\state_2)$ \iffN $\state_1, \state_2 \notin \initstates$ or $\state_1 = \state_2$. According to Definition \ref{def:eqrelview} it is 
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctinitstates(\state) = \remelem\} = \{\state\} &\text{for } \state \in \initstates \text{ and} \\
	\eqclassv &= \{\state \in \states \mid \gfctinitstates(\state) = \notppty \}  &\text{for } \state \notin \initstates.
\end{align*}


By this we obtain the \viewN $\viewinitstates$ for a given \achgphN \chgph where: $\states' = \bigcup_{\state \in \states} \{\eqclassv\} = \{\state \in \states \mid \state \notin \initstates\}\cup \bigcup_{\state \in \initstates}\{\{\state\}\}$.

All other components are constructed as in Definition \ref{def:view}.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/initStates/initStatesBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/initStates/initStatesAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN \viewinitstates on it (right)}
	\label{fig:initStatesExmp}  
\end{figure}

In Figure \ref{fig:initStatesExmp} we can observe the effect of \viewinitstates. In the simplified representation of \achgphN on the left the states $\state_1$ and $\state_3$ are marked as initial states ($\state_1, \state_3 \in \initstates$). Hence these two are not grouped whereas the remaining two are grouped.


\subsubsection{Outgoing Actions}
Another crucial component of \achgphN is its set of actions \actions. Actions are used for interprocesscommunication und synchronization. In this subsection we will provide and discuss some views utilizing actions on transitions that are outgonig from a state. 
%For simplicity we will write "outgoing action \action" short for "transition with outgoing action \action" analogously we will write "incoming action \action" short for "transition with incoming action \action". We
We will write a state \state has an outgoing action \action if there exists a state $\state'$ with $(\state, \action, \state') \in \trans$. For a state \state, we say it has an incoming action \action if there exist a state $\state'$ with $(\state', \action, \state) \in \trans$.

The most apparent notion to group states is to group states that \emph{have} a given outgoing action.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewhasoutaction is defined by its \grpfctN \gfcthasoutaction where $\gfctsubhasoutaction : \states \to \imggrp$ with

	\[
	\gfctsubhasoutaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state' \in \states: (\state, \action, \state') \in \trans \\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	and $\imggrp := \imggrpbinview$. %\actions \cup \remset$.	
\end{definition}


For $\state_1,\state_2 \in \states$ it is $\gfcthasoutaction(\state_1) = \gfcthasoutaction(\state_2)$ \iffN 
there exist $\state_{a},\state_{b} \in \states$ with 
$(\state_1, \action, \state_{a}), (\state_2, \action, \state_{b}) \in \trans$ (i.e. they have \action as outgoing action). 
In accordance with Definition \ref{def:eqrelview} it is
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfcthasoutaction(\state) = \remelem\} = \{s\} &\text{if }\exists\state' \in \states : (\state, \action, \state') \in \trans \\
	\eqclassv &= \{\state \in \states \mid \gfcthasoutaction(\state) = \notppty\}  &\text{ otherwise}
\end{align*}
 %if for all $\state' \in \states : (\state,\action,\state') \notin \trans$.

Thereby we obtain the \viewN \viewhasoutaction for a given \chgphN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where
\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states,\, \exists \state' \in \states: (\state, \action, \state') \in \trans\}\} \\
	&\;= \{\{\state\} \mid \state \in \states,\, \gfctminoutaction(\state) = \remelem\} = \nogroupstates \text{   and} \\
	\states_2 &:= \{\{\state \in \states \mid \lnot \exists \state' \in \states: (\state, \action, \state') \in \trans\}\} \\
	&\;= \{\{\state \in \states \mid \gfctminoutaction(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActHasAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewhasoutaction(\action)$ on it (right)}
	\label{fig:outActHasAfter}  
\end{figure}

In Figure \ref{fig:outActHasAfter} we can observe the effect of $\viewhasoutaction(\action)$. In the simplified representation of \achgphN on the left the action \action is outgoing from states $\state_1, \state_2, \state_3$ and $\state_4$, whereas it is not outgoing from $\state_5$ and $\state_6$. Hence, $\state_1, \dots, \state_4$ are not grouped but shown, and states $\state_5$ and $\state_6$ are grouped.

Since actions are a very important part of \chgphsN and TS it seems useful to further enhance this \viewN and look at variants of it. Instead of only grouping states that only \emph{have} outgoing actions we could also quantify the amount of times that action should be outgoing.


For example we could require that a given action has to be outgoing a minimum amount of times. 

\begin{definition}	
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewminoutaction is defined by its \grpfctN \gfctminoutaction where $\gfctsubminoutaction : \smstates \to \imggrp$ with

	\[
	\gfctsubminoutaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state_1, \dots, \state_\numoutact \in \states:  \predminoutact\\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$,
	%	\actions \cup \remset$
	 $\numoutact \in \natnums$ is the minimum amount of times a transition with action \action has to be outgoing in order to be grouped with the other states and
	\[
	\predminoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_\numoutact) \in \trans) \land |\{\state_1, \dots, \state_\numoutact\}| = \numoutact
	\]
	
	is a first order logic predicate.
	\label{def:minoutaction}
\end{definition}

The predicate \predminoutact requires that there are transitions with action \action to \numoutact distinct states.

For $\state_1,\state_2 \in \states$ it is $\gfctminoutaction(\state_1) = \gfctminoutaction(\state_2)$ \iffN there exist distinct $\state_{a_1}, \dots, \state_{a_\numoutact} \in \states$ and distinct $\state_{b_1}, \dots, \state_{b_\numoutact} \in \states$ so that $(\state_1, \action, \state_{a_1}), \dots, (\state_1, \action, \state_{a_\numoutact}) \in \trans$ and $(\state_2, \action, \state_{b_1}), \dots, (\state_2, \action, \state_{b_\numoutact}) \in \trans$ or $\state_1 = \state_2$. According to Definition \ref{def:eqrelview} it is 
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctminoutaction(\state) = \remelem\} = \{\state\} &\text{if } \exists \state_1, \dots, \state_\numoutact \in \states:  \predminoutact \\ 
	\eqclassv &= \{\state \in \states \mid \gfctminoutaction(\state) = \notppty\} &\text{ otherwise}
\end{align*}

By this we obtain the \viewN $\viewminoutaction$ for a given \chgphN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where 

\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states,\, \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact\} \\
	&\;= \{\{\state\} \mid \state \in \states,\, \gfctminoutaction(\state) = \remelem\} = \nogroupstates \text{   and} \\
	\states_2 &:= \{\{\state \in \states \mid \lnot \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact\}\} \\
	&\;= \{\{\state \in \states \mid \gfctminoutaction(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActMinAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewminoutaction(\action,2)$ on it (right).}
	\label{fig:outActMinAfter}  
\end{figure}

In Figure \ref{fig:outActMinAfter} we can observe the effect of $\viewminoutaction(\action,2)$. In the simplified representation of \achgphN on the left the action \action is outgoing zero times from $\state_5, \state_6$, one time from $\state_3, \state_4$ and two times from $\state_1, \state_2$. Hence, $\state_1$ and $\state_2$ are not grouped but shown, and states $\state_3, \dots, \state_6$ are grouped.

In a similar fashion we define \viewN that groups states where at most a certain number of times a given action is outgoing. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewmaxoutaction is defined by its \grpfctN \gfctmaxoutaction where $\gfctsubmaxoutaction : \smstates \to \imggrp$ with

	\[
	\gfctsubmaxoutaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$,
%	$\numoutact \in \natnums$ 
	is the maximal number of times a transition with action \action may be outgoing and 
	\[
	\predmaxoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_{\numoutact+1}) \in \trans) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numoutact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
	\label{def:viewmaxoutaction}
\end{definition}

It ensures that if there are one more than \numoutact outgoing transitions with an action \action at least two of the states where the transitions end are in fact the same. Since this is required for all possible combinations of $\numoutact + 1$ states by the grouping function, only states that have at most \numoutact outgoing actions will be assigned with \remelem by the grouping function. The reasoning about the equality of the \grpfctN values, the obtained equivalence classes and the resulting set of states $\states'$ of the \viewN is analogous to \viewminoutaction.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActMaxAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewmaxoutaction(\action,1)$ on it (right)}
	\label{fig:outActMaxAfter} 
\end{figure}

In Figure \ref{fig:outActMaxAfter} we can observe the effect of $\viewmaxoutaction(\action,1)$. In the simplified representation of \achgphN on the left the action \action is outgoing zero times from $\state_5, \state_6$, one time from $\state_3, \state_4$ and two times from $\state_1, \state_2$. Hence, $\state_3, \dots, \state_6$ are not grouped but shown, and states $\state_1$ and $\state_2$ are grouped.

Since we already defined \grpfctsN and hence \viewsN for a required minimal and maximal amount of times an action has to be outgoing it is now easily possible to define a \viewN that groups states where the amount of outgoing actions is at least \numoutact and at most \numoutactb. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN 
	\viewspanoutaction is defined by its \grpfctN where $\gfctsubspanoutaction : \smstates \to \imggrp$ with

	\[
	\gfctsubspanoutaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$
%	\actions \cup \remset$ 
	and $\numoutactb, \numoutact \in \natnums$ are the minimal and maximal number of transitions with action \action in order for state to be grouped. The predicates \predminoutact and \predmaxoutact are the predicates from Definition \ref{def:minoutaction} and Definition \ref{def:viewmaxoutaction} respectively.
\end{definition}

We already know that for a given $\state \in \states$ the expressions $\exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact$ and $\forall \state_1, \dots, \state_{\numoutactb+1} \in \states: \predmaxoutact[\numoutactb]$ from Definition \ref{def:minoutaction} and Definition \ref{def:viewmaxoutaction} require that \state has minimal and maximal amount of outgoing transitions with an action \action respectively. Hence the conjunction will be true for states where the amount of outgoing transitions with action \action is element of the set $\{\numoutactb, \numoutact+1, \dots, \numoutact-1, \numoutact\}$. We will write for this that the number of outgoing actions is \emph{in the span}.

For a given state \state and action \action we set
\[
\formoutact:= \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb]\land \\
\forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact
\]

for convenience. \formoutact is true  \iffN the number of outgoing actions is in the span. For $\state_1, \state_2 \in \states$ it is $\gfctspanoutaction(\state_1) = \gfctspanoutaction(\state_2)$ \iffN $\formoutact[\state_1] \land \formoutact[\state_2]$ or $\state_1 = \state_2$. Then its equivalence classes are

\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \remelem\} = \{\state\} &\text{if } \formoutact \text{ true} \\
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \notppty\} &\text{ otherwise}	
\end{align*}

The new set of states $\states'$ of the \viewN \viewspanoutaction is the union of the equivalence classes of equivalence relation \eqrelview on the set of states \states of the original \chgphN. Hence it is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states, \, \formoutact \text{ true}\} \\
	&\;= \{\{\state\} \mid \state \in \states, \, \gfctspanoutaction(\state) = \remelem\} = \nogroupstates \\
	\states_2 &:= \{\{\state \in \states  \mid \formoutact \text{ false}\}\} = \{\{\state \in \states \mid \gfctspanoutaction(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActSpanBefore}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewspanoutaction(1, \action, 1)$ on it (right)}
	\label{fig:outActSpan}
\end{figure}

In Figure \ref{fig:outActSpan} we can observe the view of $\viewspanoutaction(1, \action, 1)$ on \mdp. It shows states that have the action \action at least one time outgoing and at most 1 one time. Hence, it does not group states, where the action \action is outgoing exactly once. All all remaining states are grouped. In the simplified representation of \achgphN on the left the action \action is outgoing zero times from $\state_5, \state_6$, one time from $\state_3, \state_4$ and two times from $\state_1, \state_2$. Hence, $\state_4, \dots, \state_5$ are not grouped but shown, and the remaining states $\state_1, \state_2, \state_5, \state_6$ are grouped.


%The \viewsN above can be combined with \parllcompN. The thereby obtained \viewN requires that the respective conditions of all the combined \viewsN are met. In this sense it is a conjunctive combination.

Instead of making requirements about states and group them based on whether they meet these requirements it also possible to group states that are very similar or even identical in regard to their outaction. We consider this idea with the \emph{\outactident \viewNC} in two variants: \outactidentstrong and \outactidentweak (idententiy). Firstly we will consider the variant of strong identity.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewstrongoutactident is defined by its \grpfctN \gfctstrongoutactident where $\gfctsubstrongoutactident : \smstates \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numoutact) \mid \action \in \actions, \numoutact \text{ is the number of times that \action is outgoing from } \state\}
	\]
	and $\imggrp := \actions \times \natnums_0 \cup \remset$.
\end{definition}

The \grpfctN asserts to each state a set of pairs. Note that a pair is contained in the set for each action $\action \in \actions$. In case there is no outgoing transition from state \state with an action \action it is $(\action, 0) \in \gfctstrongoutactident$. For $\state_1, \state_2 \in \states$ it is $\gfctstrongoutactident(\state_1) = \gfctstrongoutactident(\state_2)$ \iffN $\state_1$ and $\state_2$ are mapped to the same set of pairs. By Definition \ref{def:eqrelview} the obtained equivalence classes of \eqrelview are
\[
	\eqclassv := \{\state \in \states \mid \gfctstrongoutactident(\state) = \{(\action_1, \numoutact_1), \dots, (\action_l, \numoutact_l)\}\} \text{  where } l = |\actions|
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewstrongoutactident. All other components of \viewstrongoutactident are as usual structured in accordance with the Definition \ref{def:view}.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}		
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongAfter}
	\end{minipage}
	
	\caption{Simplified representations of \mdp (left) and the \viewN \viewstrongoutactident on it (right)}
	\label{fig:outActIdentStrongAfter}

\end{figure}

In Figure \ref{fig:outActIdentStrongAfter} we can observe the \viewN $\viewstrongoutactident$ on \mdp (both simplified representations). 
For \viewstrongoutactident it is \gfctstrongoutactident :

\begin{minipage}{.45\textwidth}
\begin{align*}
	\state_1 &\mapsto \{(\action,2), (\actionb,1), (\actionc,1)\} \\
	\state_2 &\mapsto \{(\action,2), (\actionb,1), (\actionc,1)\} \\
	\state_3 &\mapsto \{(\action,1), (\actionb,1), (\actionc,1)\} \\	
\end{align*}
\end{minipage}
\begin{minipage}{.55\textwidth}
\begin{align*}
	\state_4 &\mapsto \{(\action,1), (\actionb,0), (\actionc,0)\} \\
	\state_5 &\mapsto \{(\action,0), (\actionb,0), (\actionc,1)\} \\
	\state_6 &\mapsto \{(\action,0), (\actionb,0), (\actionc,1)\} \\
\end{align*}
\end{minipage}

because these are number of corresponding outgoing actions from each state. We see that the sets are equal for $\state_1$ and $\state_2$ and for $\state_5$ and $\state_6$. Hence, these two pairs are each grouped to a new to new states. The remaining states are not grouped with another state. The equivalences classes containing them are singleton sets.

As mentioned earlier a \outactidentweak variant of the \outactident \viewN is also conceivable. To ease readability for $\state \states$ we write $\outacts(\state)$ for the set $\{\action \in \actions \mid \exists \state' \in \states : (\state, \action, \state') \in \trans\}$

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewweakoutactident is defined by its \grpfctN \gfctweakoutactident where $\gfctsubweakoutactident : \smstates \to \imggrp$ with
	\[
	\state \mapsto \outacts(\state)
	\]
	and $\imggrp := \actions \cup \remset$.
\end{definition}

For $\state_1, \state_2 \in \states$ it is $\gfctweakoutactident(\state_1) = \gfctweakoutactident(\state_2)$ \iffN they are mapped to the same set of actions. Hence the equivalence classes of \eqrelview are
\[
	\eqclassv[\smstate] = \{ \state \in \states \mid \gfctweakoutactident(\state) = \gfctweakoutactident(\smstate) =: \{\action_1, \dots, \action_l\}\} \text{  where } l \leq |\actions|.
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewweakoutactident.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}				
		\hspace{5mm}
		\input{./04/images/actions/outActIdentWeakAfter}
	\end{minipage}	
	\caption{Simplified representations of \mdp (left) and the \viewN \viewweakoutactident on it (right)}	
	\label{fig:outActIdentWeakAfter}  	
\end{figure}

In Figure \ref{fig:outActIdentWeakAfter} we can observe the \viewN $\viewweakoutactident$ on \chgph (both simplified representations). 
For \viewweakoutactident it is \gfctweakoutactident :

\begin{minipage}{.45\textwidth}
	\begin{align*}
		\state_1 &\mapsto \{\action, \actionb, \actionc\} \\
		\state_2 &\mapsto \{\action, \actionb, \actionc\} \\
		\state_3 &\mapsto \{\action, \actionb, \actionc\} \\		
	\end{align*}
\end{minipage}
\begin{minipage}{.55\textwidth}
	\begin{align*}
		\state_4 &\mapsto \{\action\} \\
		\state_5 &\mapsto \{\actionc\} \\
		\state_6 &\mapsto \{\actionc\} \\		
	\end{align*}
\end{minipage}
because these are the corresponding outgoing actions from each state. We see that the sets are equal for $\state_1,\state_2$ and $\state_3$ and for $\state_5$ and $\state_6$. Hence, the state set of the \viewN \viewweakoutactident on \chgph has the state set $\{\{\state_1, \state_2, \state_3\}, \{\state_4\}, \{\state_5, \state_5\}\}$.

Apart from the option of directly considering one or a set of outgoing actions with possible quantities it is also possible to only consider the quantity of outgoing actions without regarding the any specific action.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewoutactsetsize is defined by its \grpfctN \gfctoutactsetsize where $\gfctsuboutactsetsize : \smstates \to \imggrp$ with
	\[
	\state \mapsto |\outacts(\state)|
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

For $\state_1, \state_2 \in \states$ it is $\gfctoutactsetsize(\state_1) = \gfctoutactsetsize(\state_2)$ \iffN they are mapped to the same set of actions. Hence the equivalence classes of \eqrelview are
\begin{align*}
	\eqclassv[\smstate] &= \{ \state \in \states \mid \gfctoutactsetsize(\state) = \gfctoutactsetsize(\smstate)\} \\
	&= \{ \state \in \states \mid \outacts(\state) = \outacts(\smstate)\}
\end{align*}

According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewweakoutactident.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}						
		\centering
		\input{./04/images/actions/outActSetSizeAfter}
	\end{minipage}	
	\caption{Simplified representations of \mdp (left) and the \viewN \viewoutactsetsize on it (right)}	
	\label{fig:outActSetSize}  	
\end{figure}

In Figure \ref{fig:outActSetSize} we can observe the view of $\viewoutactsetsize$ on \chgph. In the simplified representation of \achgphN on the states $\state_1, \state_2, \state_3$ have the outgoing actions $\action, \actionb, \actionc$, the state $\state_4$ has the outgoing action \action and the state $\state_5, \state_6$ have the outgoing action \actionc. Hence, the number of outgoing actions for $\state_1, \state_2, \state_3$ is three and for $\state_4, \state_5, \state_6$ is one. That is why each of these states become a new single state in the \viewN \viewoutactsetsize.

The notion of the \viewN \viewoutactsetsize is similar to utilize the outdegree, with the difference being here that ougoing transitions with the same action are considered as one single edge. This reflects on the options available for nondeterminism in this state.

The sepcialcase of there only being one single ougoing action is worth a distinct view, since it hides all nondeterministic choices, but nothing more.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewoutactsingle is defined by its \grpfctN \gfctoutactsingle where $\gfctsuboutactsingle : \smstates \to \imggrp$ with
	\[
	\gfctsuboutactsingle(\state) =
	\begin{cases}
		\hasppty, &\text{if } |\outacts(\state)| = 1 \\ 
		\remelem, &\text{otherwise}
	\end{cases}
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

Note that this view groups on states that \emph{have} the property. This is the case because the intention of the view is to hide \states in which there is no nondeterministic selection of an action.

Two states $\state_1, \state_2 \in \states$ are grouped \iffN $\gfctoutactsingle(\state_1) = \gfctoutactsingle(\state_2)$. Hence the the equivalence classes of \eqrelview are:

\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \remelem\} = \{\state\} &\text{if } |\outacts(\state)|=1 \\
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \notppty\} &\text{ otherwise}	
\end{align*}

Thereby we obtain the \viewN $\viewminoutaction$ for a given \chgphN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where 

\begin{align*}
	\states_1 &:= \{\{ \state \in \states \mid |\outacts(\state)| = 1\}\} = \{\{\state \in \states \mid \gfctminoutaction(\state) = \hasppty\}\}  \text{   and} \\
	\states_2 &:= \{\{\state\} \mid \state \in \states, \mid |\outacts(\state)| \neq 1\}\} = \{\{\state\} \mid \state \in \states, \, \gfctminoutaction(\state) = \remelem\}\} = \nogroupstates[\states_1].
\end{align*}

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/actions/outActIdentStrongBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}						
		\centering
		\input{./04/images/actions/outActSingleAfter}
	\end{minipage}	
	\caption{Simplified representations of \mdp (left) and the \viewN \viewoutactsetsize on it (right)}	
	\label{fig:outActSingle}  	
\end{figure}

In Figure \ref{fig:outActSingle} we can observe the view of $\viewoutactsingle$ on \chgph. In the simplified representation of \achgphN, the states $\state_5$ and $\state_6$ are the only states with only one outgoing action. Hence, these two are grouped and the remaining four states are not grouped with any other state, but shown.

\subsubsection{Incoming Actions}
Analogously to Outgoing Actions views of utilizing incoming actions are feasable. Since there is no difference apart from the definitions itself, we only provide the definitions.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewhasinaction is defined by its \grpfctN \gfcthasinaction where $\gfctsubhasinaction : \smstates \to \imggrp$ with

	\[
	\gfctsubhasinaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state' \in \states: (\state', \action, \state) \in \trans \\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	and $\imggrp := \imggrpbinview$.	
	\label{def:mininaction}
\end{definition}	


\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewmininaction is defined by its \grpfctN \gfctmininaction where $\gfctsubmininaction : \smstates \to \imggrp$ with

	\[
	\gfctsubmininaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state_1, \dots, \state_\numinact \in \states:  \predmininact\\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$,
%	 $\numinact \in \natnums$ 
	 is the minimum amount of times a transition with action \action has to be incoming in order to be grouped with the other states and
	\[
	\predmininact := ((\state_1, \action, \state), \dots, (\state_\numinact, \action, \state) \in \trans) \land |\{\state_1, \dots, \state_\numinact\}| = \numinact
	\]
	is a first order logic predicate.
	\label{def:viewmaxinaction}
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewmaxinaction is defined by its \grpfctN \gfctmaxinaction where $\gfctsubmaxinaction : \smstates \to \imggrp$ with

	\[
	\gfctsubmaxinaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$
%	$\numinact \in \natnums$ 
	 is the maximal number of times a transition with action \action may be incoming and 
	\[
	\predmaxinact := ((\state_1, \action, \state), \dots, (\state_{\numinact+1}, \action, \state) \in \trans) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numinact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN 
	\viewspaninaction is defined by its \grpfctN where $\gfctsubspaninaction : \smstates \to \imggrp$ with

	\[
	\gfctsubspaninaction(\state) =
	\begin{cases}
			\remelem,				& \text{if } \exists \state_1, \dots, \state_\numinactb \in \states: \predmininact[\numinactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
			\notppty,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$
%	\actions \cup \remset$ 
	and $\numinactb, \numinact \in \natnums$ are the minimal and maximal number of transitions with action \action in order for state to be grouped. The predicates \predmininact and \predmaxinact are the predicates from Definition \ref{def:mininaction} and Definition \ref{def:viewmaxinaction} respectively.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewstronginactident is defined by its \grpfctN \gfctstronginactident where $\gfctsubstronginactident : \smstates \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numinact) \mid \action \in \actions, \numinact \text{ is the number of times that \action is incoming from } \state\}
	\]
	and $\imggrp := (\actions \times \natnums_0) \cup \remset$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewweakinactident is defined by its \grpfctN \gfctweakinactident where $\gfctsubweakinactident : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\action \in \actions \mid \exists \state' \in \states : (\state', \action, \state) \in \trans\} 	
	\]
	and $\imggrp := \actions\cup \remset$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $\action \in \actions$. The \viewN \viewinactsetsize is defined by its \grpfctN \gfctinactsetsize where $\gfctsubinactsetsize : \smstates \to \imggrp$ with
	\[
	\state \mapsto |\{\action \in \actions \mid \exists \state' \in \states : (\state', \action, \state) \in \trans\}|
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

\subsubsection{Variables}
The concept of variables is not part of the definitions of neither \tsN, MCs or \mdpsN even though, it is of great importance in practice. We will introduce and discuss this concept before utilizing it for \viewsN.

Since states describe some information about a system at a certain moment of its behavior the information carried is usually not atomic but rather consists of several pieces. For instance when considering a computer program at a given moment during execution all its currently available variables will have some value, the stack will have a certain structure and the program counter points to a specific instruction. Systems in general at a certain moment of their behavior have several properties that in total pose the current state of the system. That is in practice each state is actually derived from a possible variable assertion. Choosing the respective variable assertion as state representation would result in rather complex state objects. Therefore the values of the variables are usually stored in a separate data structure and a simple identifier like an integer represents the actual state. When formalizing this in practice used approach several options com into consideration. Available \mdpN components like atomic propositions or the set of states could be used to contain this information. There could be a subset of atomic propositions that declares that a certain variable has a certain value. There had to be taken care that for each variable in each state there is only one atomic proposition declaring its value. The set of states could be used in the sense that the states itself are complex objects containing the information. Both of these options are rather tedious but possible. A third option is to define a set of variables and an evaluation function that are induced by the \mdpN.
%Firstly there is the option of declaring the states as complex objects that contain this information. This would be possible because the set of states is not further specified. Accessing this information stored within a state would be rather tedious because there is no already existing entity to properly accomplishing the access. Hence this option was not further explored. The second option is to require that all possible assertions of all variables are included in the atomic propositions. The labeling function would then assert exactly one atomic proposition for each variable for each state, that specifies what the current value of that variable is. Although this would be possible, for simplicity we chose that variables and its values are provided in addition to the \mdpN. Obviously they are to be understood as derived and therefore dependent on the  system, that the \mdpN has been derived from. By no means the set of variables and its evaluation are arbitrary.


%Variables are used to represent states (in more detail). 
%
%For example an \mdpN could be used to model a computer program with human interaction. Every state of the MDP refers an overall state of the program during execution time. In this state of the program, its variables will have specific values. We may want to retain the information about the variable's values of the program instead of only assigning a state $\state \in \states$ that refers to the state of the program. Variables and its current values are not only relevant to computer programs but also other systems. Many of those other systems rely on some kind of global state during execution, which can be expressed with variables and values assigned to them. Since there exists no explicit component to retain this information the notion of variables is used to store it.
%
%\redcomment{OLD: Since transitions systems MCs and MDPs in practice are used to model, analyze and check real world systems it is very practical to not only name states but also describe the properties of the state in more detail. For a basic notion variables are to be imagined as a set of variables that may have different values in different states thereby describing the characteristics of the state more thoroughly. \purpcomment{ADDED TO OLD: In practice most often they arise naturally for example as variables of a computer program that is to be modeled with an \mdpN.}} 
%
%Because of the vast importance in practical applications we will consider some \viewsN that utilize them. To do so and being able to describe them formally we define and formalize the notion of variables by considering them as a subset of the atomic propositions \atomicprops that is assigned a value by a function.

\begin{definition}
	Let $\mdp$ be an \mdpN. The set $\vars$ is called \emph{variables} (of \mdp). It contains all variables induced by \mdp.
\end{definition}

\begin{definition}
	Let $\mdp = \mdptuple$ be an \mdpN and \varevalimgset be an arbitrary set. The by im induced function $\vareval : \states \times \vars \to \varevalimgset$ is called \emph{variable evaluation function}.
\end{definition} 

Most of the time we will use \vareval to refer to the variable evaluation function. When we speak about the value of a variable in a state we refer to the image of $\vareval$ for that state and variable. The set \varevalimgset is arbitrary so that arbitrary values can be assigned to a variable. Speaking in terms of computer science and programming this loosens as an example the restriction of only being able to assign numbers and no booleans.

The most apparent idea for a \viewN utilizing variables is to group states that meet some requieent regarding the values of the variables.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$, $\var \in \vars$ and $\varval \in \varevalimg$. The \viewN \viewparamvalueseq is defined by its \grpfctN \gfctparamvalueseq where $\gfctsubparamvalueseq : \smstates \to \imggrp$ with
	\[
	\gfctsubparamvalueseq(\state) =
	\begin{cases}
			\remelem, &\text{if } \vareval(\state, \var) = \varval\\
			\notppty, &\text{otherwise}
	\end{cases}
	\]
	where $\imggrp := \imggrpbinview$.
\end{definition}

The \viewN \viewparamvalueseq groups states that share the same value for a given variable. For $\state_1, \state_2$ it is $\gfctparamvalueseq(\state_1) = \gfctparamvalueseq(\state_2)$ \iffN $\vareval(\state_1, \var) = \vareval(\state_2, \var)$ or $\state_1 = \state_2$. The obtained equivalence classes are
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctparamvalueseq(\state) = \remelem\} = \{\state\} &\text{if \vareval(\state, \var) = \varval} \\
	\eqclassv &= \{\state \in \states \mid \gfctparamvalueseq(\state) = \notppty\} &\text{otherwise}
\end{align*}

The set of states $\states'$ of \viewparamvalueseq is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states, \, \vareval(\state, \var) = \varval\} \\
	&\;= \{\{\state\} \mid \state \in \states, \, \gfctparamvalueseq(\state) = \remelem\} = \nogroupstates \\
	\states_2 &:= \{\{\state \in \states  \mid \vareval(\state, \var) \neq \varval\}\} = \{\{\state \in \states \mid \gfctparamvalueseq(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[h]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}		
		\input{./04/images/variables/varsBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/variables/varsValEqAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp with the state set $\states = \{\varstyle{x}{y} \mid x,y \in \{0, 1, 2\}\}$ (left) and the \viewN $\viewparamvalueseq(y=1)$ on it (right)}
	\label{fig:varsValEq}  
\end{figure}

In Figure \ref{fig:varsValEq} we can observe the view of $\viewparamvalueseq(y=1)$ on \chgph, in which states with $y=1$ are not grouped, but all the remaining ones.

%Analogously a \viewN that requires inequality instead of equality is feasible.

%\begin{definition}
%	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$, $\var \in \vars$ and $\varval \in \varevalimg$. The \viewN \viewparamvaluesneq is defined by its \grpfctN \gfctparamvaluesneq where $\gfctsubparamvaluesneq : \smstates \to \imggrp$ with
%	\[
%	\gfctsubparamvaluesneq(\state) =
%	\begin{cases}
%			\remelem, &\text{if } \vareval(\state, \var) \neq \varval\\
%			\notppty, 	&\text{otherwise}
%		\end{cases}
%	\]
%	where $\imggrp := \imggrpbinview$.
%\end{definition}

If states are to be grouped with the requirement of several variables equaling or not equaling specified values this can be achieved by using \parllcompN.

To allow even more flexibility a \viewN can be used that also allows a combination of requirements on variables in a disjunctive manner. To extend this idea to its full potential we will define a \viewN that allows requirements using a disjunctive normal formal (DNF). To formalize this \viewN more efficiently we will write $\varstate[,i]$ short for $\vareval(\state, \var_i)$ where $x_i \in \vars$ and $i \in \natnums$. We define the symbol \eqorneq to be an element of the set $\{=,\neq\}$. That is to say, whenever it is used each time written it is a representative for either the symbol $=$ or $\neq$. It allows to write one symbol whenever $=$ and $\neq$ could or should be possible. Moreover for this context we consider $(\varstate[,i] = \varval)$ as a literal and $(\varstate[,i] \neq \varval)$ as its negation. We write $(\varstate[,i] \eqorneq \varval)$ for a literal that could be negated or not negated.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and 
	\begin{align*}
		c(s) = &((\varstate[,i_1] \eqorneq \varval_{i_1}) \land \dots \land (\varstate[,i_{l_1}] \eqorneq \varval_{i_{l_1}})) \; \lor \\
		&((\varstate[,i_{l_1+1}] \eqorneq \varval_{i_{l_1+1}}) \land \dots \land (\varstate[,i_{l_2}] \eqorneq \varval_{i_{l_2}})) \; \lor  \\
		&\dots \\ 
		&((\varstate[,i_{(l_{m-1})+1}] \eqorneq \varval_{i_{(l_{m-1})+1}}) \land \dots \land (\varstate[,i_{l_m}]  \eqorneq \varval_{i_{l_m}}))
	\end{align*}
	
	proposition logical formula in disjunctive normal form where
	\begin{itemize}
		\item $\varstate[,i_k], a_{i_k} \in \varevalimg$ with $i_k\in \natnums$ and $k \in \{1, \dots, l_m\}$
		\item $l_1 < l_2 < \dots < l_m$ are natural numbers and $m$ is the number of clauses in $c(s)$
	\end{itemize}		
	The \viewN \viewparamdnf is defined by its \grpfctN \gfctparamdnf where $\gfctsubparamdnf : \smstates \to \imggrp$ with
	\[
	\gfctsubparamdnf(\state) =
	\begin{cases}
			\remelem, &\text{if } d(s) \text{ is true}\\
			\notppty, 	&\text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \{\group, \remelem\}$.
\end{definition}


The DNF allows us to specify a requirement in disjunctive normal form about variables. States are mapped to the same value depending on whether or not they meet this requirement.

The \viewN \viewparamdnf groups states that share the same value for a given variable. For $\state_1, \state_2$ it is $\gfctparamdnf(\state_1) = \gfctparamdnf(\state_2)$ \iffN $\vareval(\state_1, \var) = \vareval(\state_2, \var)$ or $\state_1 = \state_2$. The obtained equivalence classes are
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctparamdnf(\state) = \remelem\} = \{\state\} &\text{if } d(s) \text{ true} \\
	\eqclassv &= \{\state \in \states \mid \gfctparamdnf(\state) = \notppty\} &\text{otherwise}
\end{align*}

The set of states $\states'$ of \viewparamdnf is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states, \, d(s) \text{ true}\} = \{\{\state\} \mid \state \in \states, \, \gfctparamdnf(\state) = \remelem\} = \nogroupstates \\
	\states_2 &:= \{\{\state \in \states  \mid d(s) \text{ false}\}\} = \{\{\state \in \states \mid \gfctparamdnf(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[h]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}		
		\input{./04/images/variables/varsBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/variables/varsDnfAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp $\states = \{\varstyle{x}{y} \mid x,y \in \{0, 1, 2\}\}$ (left) and the \viewN \viewparamdnf with $d(s) = ((x=0) \land (y=0)) \lor ((x=1) \land (y=1)) \lor ((x=2) \land (y=2))$  on it (right)}
	\label{fig:varsDnf}  
\end{figure}

Analogously a \viewN based on a conjunctive normal formal can be defined that may be more convenient, depending on the query.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and 
	\begin{align*}
		c(s) = &((\varstate[,i_1] \eqorneq \varval_{i_1}) \lor \dots \lor (\varstate[,i_{l_1}] \eqorneq \varval_{i_{l_1}})) \; \land \\
		&((\varstate[,i_{l_1+1}] \eqorneq \varval_{i_{l_1+1}}) \lor \dots \lor (\varstate[,i_{l_2}] \eqorneq \varval_{i_{l_2}})) \; \land  \\
		&\dots \\ 
		&((\varstate[,i_{(l_{m-1})+1}] \eqorneq \varval_{i_{(l_{m-1})+1}}) \lor \dots \lor (\varstate[,i_{l_m}]  \eqorneq \varval_{i_{l_m}}))
	\end{align*}
	
	proposition logical formula in disjunctive normal form where
	\begin{itemize}
			\item $\varstate[,i_k], a_{i_k} \in \varevalimg$ with $i_k\in \natnums$ and $k \in \{1, \dots, l_m\}$
			\item $l_1 < l_2 < \dots < l_m$ are natural numbers and $m$ is the number of clauses in $c(s)$
	\end{itemize}
	The \viewN \viewparamcnf is defined by its \grpfctN \gfctparamcnf where $\gfctsubparamcnf : \smstates \to \imggrp$ with
	\[
	\gfctsubparamcnf(\state) =
	\begin{cases}
			\remelem, &\text{if } c(\state) \text{ is true}\\
			\notppty, 	&\text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$.
\end{definition}

The only difference from the \viewN \viewparamcnf to the \viewN \viewparamdnf is whether the respective formulae is in conjunctive or disjunctive normal form. Since each formulae in conjunctive normal form can be transformed to a formulae in disjunctive normal form and vice versa \redcomment{CITATION??} neither on of the \viewsN can perform an action the other can not. Hence there is no difference in expressivity, but there may be one in size. Therefore both views have been implemented and formalized. For finite \chgphsN they present an interface to performing arbitrary groupings on the state set utilizing parameter values. Equality, equivalence classes and the new state set behave and are constructed analogously to the \viewN \viewparamdnf.

The views discussed before reduce the \chgphN in a very precise but also manual manner, because it not only dictates the variable but also its value. A more general approach is to stipulate only the variable but not its value. This way states will be grouped that have the same value for that variable with no regard to the actual value of that variable. 
%This idea could be achieved with a \viewN based on the \grpfctN $\grpfct[\varval_1 ]$%\pll \dots \pll \gfctparamvalueseqopt[\varval_n]]$ with $\redcomment{\vareval(\states, \var)} = \{\varval_1, \dots, \varval_n\}$ and $|\vareval(\states,\var)| = n$. This grouping function just groups on every possible value for the variable \var. Since this is \redcomment{not very practical} we define a \viewN that achieves this result in a more direct and more efficient way.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. The \viewN \viewparamvalident is defined by its \grpfctN \gfctparamvalident where $\gfctsubparamvalident : \smstates \to \imggrp$ with
	\[
	\state \mapsto \vareval(\state,\var)
	\]
	and $\imggrp := \varevalimg \cup \{\remelem\}$.
\end{definition}

With this grouping function we directly map to the value of the variable. Hence for $\state_1, \state_2 \in \states$ it is $\gfctparamvalident(\state_1) = \gfctparamvalident(\state_2)$ \iffN they are mapped to the same value $\varval \in \imggrp$. Hence the equivalence classes of \eqrelview are
\[
\eqclassv[\smstate] = \{ \state \in \states \mid \vareval(\state) = \vareval(\smstate)\}.
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewparamvalident.

\begin{figure}[h]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}		
		\input{./04/images/variables/varsBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/variables/varValIdentAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp $\states = \{\varstyle{x}{y} \mid x,y \in \{0, 1, 2\}\}$ (left) and the \viewN $\viewparamvalident(x)$ on it (right).}
	\label{fig:varValIdent}  
\end{figure}

In Figure \ref{fig:varValIdent} we can observe the view of $\viewparamvalident$ on \chgph. States are grouped in which $x$ has the same value. It is $x \in \{0, 1, 2\}$. Hence, the states $\varstyle{0}{0}, \varstyle{0}{1},\varstyle{0}{2}$ are grouped because in all of them it is $x=0$. For the same reason $\varstyle{1}{0}, \varstyle{1}{1},\varstyle{1}{2}$ grouped with $x=1$ and $\varstyle{2}{0}, \varstyle{2}{1},\varstyle{2}{2}$ with $x=2$.
\subsubsection{Property Values and Model Checking Results}
Apart from direct and indirect components of an \mdpN there are other values linked to states. These can be given by a reward structure or results from model checking. A reward structure simply assigns values to each state. Results from model checking are also available statewisely. 
%Although we do not want to go into detail with model checking in this thesis values determined by it are minimal and maximal probabilities or expected values (e.g. of rewards). 
We abstract from the exact type of value or its origin and formalize this notion with an arbitrary function that assigns a value to each state and utilize it to define a \viewN. Note that there might be several such functions (e.g.reward structure and several model checking results) for an \chgphN.

\begin{definition}
	The function $\propfct : \states \to \realnums$ is called \emph{property function} (generated by a model checker). It maps each state to a property value.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$, $r \in \realnums$ a granularity, $\propfct : \states \to \realnums$ a property function given and the by $r$ induced partition $Z =\bigcup_{i \in \integers}Z_i$ on \realnums where
	\[
		Z_i = 
		\begin{cases}
			[i \cdot r -  \frac{r}{2}, i \cdot r +  \frac{r}{2}), &\text{if } i > 0 \\
			(i \cdot r -  \frac{r}{2}, i \cdot r +  \frac{r}{2}), &\text{if } i = 0 \\
			(i \cdot r -  \frac{r}{2}, i \cdot r +  \frac{r}{2}]&\text{if } i < 0
		\end{cases}
%		\begin{cases}
%			[z_{min}, z_{min} + \frac{r}{2}), &\text{if } i=1 \\
%			[i \cdot r -  \frac{r}{2}, i \cdot r +  \frac{r}{2}), &\text{if } i\in\{2,\dots, n-1\} \\
%			(z_{max}-\frac{r}{2}, z_{max}, &\text{if } i = n
%		\end{cases}
	\]
%	where 
%\begin{align*}
%	z_{min} &= \min\propfct[\states] - (\min\propfct[\states] \text{ mod } r) \\
%	z_{max} &= \max\propfct[\states] - (\max\propfct[\states] \text{ mod } r) + \frac{r}{2}
%\end{align*}	
	The \viewN \viewprop is defined by its \grpfctN \gfctprop where $\gfctsubprop : \smstates \to \imggrp$ with
	\[
	\state \mapsto r \cdot i \quad\quad\quad \text{where } \propfct(\state) \in Z_i \in Z
	\]
	and $\imggrp = \realnums \cup \remset$.
\end{definition}

With this \viewN a partition on the image of \propfct is built, based on the granularity $r$. 
%The partition $Z$ is finite since the image of \propfct is finite because \mdpsN in this thesis are assumed finite as \redcomment{in practice model checking for infinite \mdpsN is not possible}. 
The smaller the granularity $r$ the more elements the partition has, and vice versa. In the implementation for each state \state the value $r \cdot i$ of $\propfct(\state)$ is directly determined using rounding. The formalization as in the definition above was chosen, because it clearly formalizes the rounding behavior.

Two states $\state_1, \state_2$ are grouped if $\gfctprop(\state_1) = \gfctprop(\state_2) \neq \remelem$. Hence, the obtained equivalence classes are
\begin{align*}
	\eqclassv &= \{\state' \in \states \mid \gfctprop(\state') = \gfctprop(\state) =: r \cdot i\} \\
	&= \{\state' \in \states \mid \propfct(\state), \propfct(\state') \in Z_i\}
\end{align*}

According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewprop.

\begin{figure}[h]
	\begin{minipage}{.6\textwidth}
		%		\hspace{5mm}
		\input{./04/images/property/propBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/property/propAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN $\viewprop(0.4)$ on it (right)}
	\label{fig:PropBeforeAfter}  
\end{figure}
In Figure \ref{fig:PropBeforeAfter} we observe the \viewN $\viewprop(0.4)$ on \chgph. The by $r=0.4$ partition is $Z = \bigcup_{i \in \integers} Z_i$ where
\[
Z_i = 
\begin{cases}
	[i \cdot 0.4 -  0.2, i \cdot 0.4 +  0.2) \:\!= [0.4i - 0.2, 0.4i + 0.2) , &\text{if } i > 0 \\
	(i \cdot 0.4 -  0.2, i \cdot 0.4 +  0.2) = (-0.2, 0.2), &\text{if } i = 0 \\
	(i \cdot 0.4 -  0.2, i \cdot 0.4 +  0.2] \:\!= (0.4i - 0.2, 0.4i + 0.2], &\text{if } i < 0 \\
\end{cases}
\]
It is 
\begin{alignat*}{3}
	\propfct(\state_4)=-0.6, \propfct(\state_8)=-0.95, \propfct(\state_9) = -0.99 &\in Z_{-2} &&= [-1.8, -2.2) \\
%	[0.4 \cdot (-2) - 0.2, 0.4 \cdot (-2) + 0.2) =  \\
	\propfct(\state_1)=0.1, \propfct(\state_{10})=0.15 &\in Z_0 &&= (-0.2, 0.2)\\
	\propfct(\state_2)=0.2, \propfct(\state_3)=0.41, \propfct(\state_6) = 0.59 &\in Z_1 &&= [0.2, 0.6) \\
%	= [0.4 \cdot 1 - 0.2, 0.4 \cdot 1 + 0.2) \\
	\propfct(\state_5)=0.93, \propfct(\state_{7})=2.06 &\in Z_5 &&= [1.8, 2.2) \\
%	= [0.4 \cdot 5 - 0.2, 0.4 \cdot 5 + 0.2) = [1.8, 2.2)\\	
\end{alignat*}
Hence it is
\begin{alignat*}{3}
 	\gfctprop(\state_4) = \gfctprop(\state_{8}) = \gfctprop(\state_{9}) &= 0.4\cdot(-2) &&= -0.8 \\
 	\gfctprop(\state_1) = \gfctprop(\state_{10}) &= 0.4\cdot0 &&= 0 \\
 	\gfctprop(\state_2) = \gfctprop(\state_{3}) = \gfctprop(\state_{6}) &= 0.4\cdot1 &&= 0.4 \\
 	\gfctprop(\state_5) = \gfctprop(\state_{7}) &= 0.4\cdot5 &&= 2 \\
\end{alignat*}
and states are grouped as displayed in the simplified representation of \viewprop.

\subsection{Utilizing the MDP Graphstructure}
\subsubsection{Distance}
Considering distances in a graph can be very helpful to get an overview of a graph. Likewise it helps a lot with understanding the structure of \achgphN. In order to consider the distance between nodes we will need to formalize it.

\redcomment{definition is very similar to execution fragments! Citation?}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A (simple and finite) \emph{path} \path is a sequence \pathsecfull alternating between states and actions where $n \in \natnums, \{\state_1, \dots, \state_{n}\} \subseteq \states$ is a set of distinct states,  $\{\action_1, \dots, \action_{n}\} \subseteq \actions$ and for all $i \in \{1, \dots, n\}$ it is $(\state_i,\action_i, \state_{i+1}) \in \trans$. 
	
	\noindent
	It is $\pfirst(\path) := \state_1$ and $\plast(\path) := \state_n$ and \pathset the set of all paths in \chgph.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A (simple and finite) \emph{undirected path} \pathbi is a sequence \pathsecfull alternating between states and actions where $n \in \natnums, \{\state_1, \dots, \state_{n}\} \subseteq \states$ is a set of distinct states,  $\{\action_1, \dots, \action_{n}\} \subseteq \actions$ and for all $i \in \{1, \dots, n\}$ it is $(\state_i,\action_i, \state_{i+1}) \in \trans$ or $(\state_{i+1},\action_i, \state_{i}) \in \trans$. 
	
	\noindent
	It is $\pfirst(\pathbi) := \state_1$ and $\plast(\pathbi) := \state_n$ and \pathbiset the set of all undirected paths in \chgph.
\end{definition}

\begin{definition}
	\sloppy
	Let $\chgph = \chgphtuple$ be \achgphN and \path = \pathsecfull be a path in \chgph. The number $n =: \lenpath(\path)$ is called \emph{length} of the path \path.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The \emph{distance} between disjoint $\states_1, \states_2 \subseteq \states$ is the length of the shortest path from a state $\state_1 \in \states_1$ to a $\state_2 \in \states_2$ or infinity if no such path exists. That is, if $\states_1 \cap \states_2 = \emptyset$ it is		
	\[
		\distpath(\chgph, \states_1, \states_2) := 
		\begin{cases}
			\min\{\lenpath(\path) \mid \path \in P_{\states_1 \to \states_2}\}, &\text{if } P_{\states_1 \to \states_2} \neq \emptyset \\
			\infty, &\text{otherwise}
		\end{cases}
	\]
	where $P_{\states_1 \to \states_2} := \{\path \in \pathset \mid \pfirst(\path) \in \states_1, \; \plast(\path) \in \states_2\}$. \\
	\noindent
	If $\states_1 \cap \states_2 \neq \emptyset$, it is $\distpath(\chgph, \states_1, \states_2) := 0$.
	\label{def:distance}
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The \emph{reverse distance} between disjoint $\states_1, \states_2 \subseteq \states$ is the length of the shortest path from a state $\state_2 \in \states_2$ to a $\state_1 \in \states_1$ or infinity if no such path exists. That is, if $\states_1 \cap \states_2 = \emptyset$ it is		
	\[
	\distpathrev(\chgph, \states_1, \states_2) := 
	\begin{cases}
		\min\{\lenpath(\path) \mid \path \in P_{\states_1 \leftarrow \states_2}\}, &\text{if } P_{\states_1 \leftarrow \states_2} \neq \emptyset \\
		\infty, &\text{otherwise}
	\end{cases}
	\]
	where $P_{\states_1 \leftarrow \states_2} := \{\path \in \pathset \mid \plast(\path) \in \states_1, \; \pfirst(\path) \in \states_2\}$. \\
	\noindent
	If $\states_1 \cap \states_2 \neq \emptyset$, it is $\distpathrev(\chgph, \states_1, \states_2) := 0$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The \emph{undirected distance} between disjoint $\states_1, \states_2 \subseteq \states$ is the length of the shortest undirected path from a state $\state_1 \in \states_1$ to a state $\state_2 \in \states_2$  or infinity if no such path exists. That is, if $\states_1 \cap \states_2 = \emptyset$ it is		
	\[
	\distpathbi(\chgph, \states_1, \states_2) := 
	\begin{cases}
		\min\{\lenpath(\pathbi) \mid \pathbi \in P_{\states_1 - \states_2}\}, &\text{if } P_{\states_1 - \states_2} \neq \emptyset \\
		\infty, &\text{otherwise}
	\end{cases}
	\]
	where $P_{\states_1 - \states_2} := \{\pathbi \in \pathbiset \mid \pfirst(\pathbi) \in \states_1, \; \plast(\pathbi) \in \states_2\}$. \\
	\noindent
	If $\states_1 \cap \states_2 \neq \emptyset$, it is $\distpathbi(\chgph, \states_1, \states_2) := 0$.
\end{definition}

For a given \chgphN \chgph with state set \states and $\state \in \states, \smstates \subseteq \states$ we write $\distpath(\mdp, \smstates, \state)$ short for $\distpath(\mdp, \smstates, \{\state\})$ and $\distpath(\mdp, \state, \smstates)$ short for $\distpath(\mdp, \{\state\}, \smstates)$. We do so in the same way for \distpathbi and \distpathrev.
For a \viewN that applies to the whole and utilizes distance it only makes sense to consider a given set of states from which one the distance is measured. An intuitive choice for such set is the set of initial states. To determine the distance a simple breadth first search is used. There is no algorithm such as Dijkstra need, since there are no edge weights apart from the probabilities. 
%The following algorithm calculates the distance of each node from a given set $\smstates \subseteq \states$ considering granularity \grandist:
%\redcomment{Implementation Algorithm}
%The set \fctdistdefault declares the returned set of \redcomment{ALGORITHM}. 
The implementation ensures that for every state $\state$ there exists a pair $(\state, \distval)$ in \fctdistdefault. The following \viewN groups states that have the same distance to the set measured with the amounts of transitions necessary to reach the the closest \smstates considering the granularity \grandist.

\begin{definition}
		Let $\chgph = \chgphtuple$ be \achgphN, $\bar{\states} \subseteq \smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewdistance is defined by its \grpfctN \gfctdistance where $\gfctsubdistance : \smstates \to \imggrp$ with 
		\[
		\gfctdistance(\state) =
		\begin{cases}
			 \distval - (\distval \text{ mod } n), &\text{if } d \neq \infty \\
			 \infty, &\text{otherwise}
		\end{cases}		
		\]
		where $\distval = \distpath(\chgph,\bar{\states}, \state)$ and $\imggrp = \natnums \cup \{\infty\} \cup \remset$.
\end{definition}

The number $n$ from the definition is the granularity of the distance cluster. For $n = 2$ we have for $d = 0 : 0 - 0 = 0$, for $d = 1 : 1 - 1 = 0$, for $d = 2 : 2 - 0 = 2$ and for $d = 3 : 3 - 1 = 2$ where each time the subtrahend is $d \text{ mod } 2$. We see that, \gfctdistance maps $\distpath(\chgph,\smstates, \state)$ to next smaller natural number that is dividable by $n$, which means the granularity causes that $\gfctdistance(\state)$ is a multiple of $n$.

In \viewdistance two states $\state_1, \state_2 \in \states$ are grouped \iffN $\gfctdistance(\state_1) = \gfctdistance(\state_2)$. Hence the equivalence classes in \eqrelview are 
\begin{align*}
	\eqclassv &= \{\state' \in \states \mid \gfctdistance(\state') = \gfctdistance(\state) = \tilde{d} \in \natnums\}  &\text{if } \distpath(\chgph, \bar{\states}, \state) \neq \infty \\
	\eqclassv &= \{\state \in \states \mid \gfctdistance(\state) = \infty\} &\text{otherwise } 
\end{align*}

Thereby the obtained set of states $\states'$ of \viewparamvalueseq is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\{\state \in \states \mid \distpath(\chgph, \bar{\states}, \state) = \distval - (\distval \text{ mod } n) =: \tilde{d} \neq \infty\} \mid \tilde{d} \in \gfctdistance[\states]\} \\
	&\;= \{\{\state \in \states \mid \gfctdistance(\chgph, \bar{\states}, \state) = \distval - (\distval \text{ mod } n) =: \tilde{d} \neq \infty\} \mid \tilde{d} \in \gfctdistance[\states]\} \text{ and}\\
	\states_2 &:= \{\{\state \in \states  \mid \distpath(\chgph, \bar{\states}, \state) = \infty\}\} = \{\{\state \in \states \mid \gfctdistance(\state) = \infty\}\}.
\end{align*}

\begin{figure}[h]
	\begin{minipage}{.45\textwidth}
		%		\hspace{5mm}		
		\input{./04/images/distance/distBefore}
	\end{minipage}%
	\begin{minipage}{.20\textwidth}
		\input{./04/images/distance/distForwAfter}
	\end{minipage}
	\hspace{-6pt}
	\begin{minipage}{.35\textwidth}
%		\hspace{30mm}
%		\vspace{1.5mm}
		\input{./04/images/distance/distForwGran2After}
	\end{minipage}	
	\caption{Simplified representations of \mdp (left), the \viewsN $\viewdistance(\{\state_1, \state_6\}, 1)$ (middle) and $\viewdistance(\{\state_1, \state_6\}, 2)$ on it (right). \redcomment{CANNOT SHIFT RIGHT DIAGRAM FURTHER TO THE RIGHT}}
	\label{fig:Distance}  
\end{figure}

In Figure \ref{fig:varValIdent} we can observe the \viewsN $\viewdistance(\{\state_1, \state_6\}, 1)$ (middle) and $\viewdistance(\{\state_1, \state_6\}, 2)$ (right) on \chgph. It is

\redcomment{Can not get rid of left indent below in left minipage}

\begin{minipage}{.4\textwidth}
	\begin{align*}
		\hspace{-10mm}
		\distpath(\chgph, \{\state_1, \state_6\}, \state_i) &= 0 \text{ for } i \in \{1,6\},\\
		\distpath(\chgph, \{\state_1, \state_6\}, \state_i) &= 2 \text{ for } i = 4,
	\end{align*}	
\end{minipage}
\begin{minipage}{.5\textwidth}
	\begin{align*}
		\hspace{10mm}
	 	\distpath(\chgph, \{\state_1, \state_6\}, \state_i) &= 1 \text{ for } i \in \{2,3,7,8\},\\
		\distpath(\chgph, \{\state_1, \state_6\}, \state_i) &= \infty \text{ for } i \in \{5,9,10\}
	\end{align*}
\end{minipage}


This how we obtain, the set of states of $\viewdistance(\{\state_1, \state_6\}, 1)$ as displayed in the figure. For $\viewdistance(\{\state_1, \state_6\}, 2)$ (right) the states $\{\state_1, \state_6\}$ and $\{\state_2, \state_3, \state_7, \state_8\}$ of $\viewdistance(\{\state_1, \state_6\}, 1)$ merge into one, as $\gfctdistance(\state_i) = 0 - (0 \text{ mod } 2) = 0 - 0 = 0 = 1 - 1 =1 - (1 \text{ mod } 2) = \gfctdistance(\state_j)$ for $j \in \{1,6\}$ and $i \in \{2,3,7,8\}$.

A probable usecase of a view is to find out how a certain state is or was reached. For this we define a \viewN that group states that have the same distance from a given state, when only traversing transitions backwards.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\bar{\states} \subseteq \smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewdistancerev is defined by its \grpfctN \gfctdistancerev where $\gfctsubdistancerev : \smstates \to \imggrp$ with 
	\[
	\gfctdistancerev(\state) =
	\begin{cases}
		\distval - (\distval \text{ mod } n), &\text{if } d \neq \infty \\
		\infty, &\text{otherwise}
	\end{cases}		
	\]
	where $\distval = \distpathrev(\chgph,\bar{\states}, \state)$ and $\imggrp = \natnums \cup \{\infty\} \cup \remset$.
\end{definition}

Note that the only difference of \viewdistancerev to \viewdistance is that \distpathrev is used instead of \distpath, with the only difference of \distpath and \distpathrev being that $\pfirst(\path)$ and $\plast(\path)$ are swapped. Hence, equality, equivalence classes and the new state set behave and are constructed analogously to the \viewN \viewdistance.

For cases where the direction of transitions is of no further importance we define a \viewN \viewdistancebi utilizing \distpathbi.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\bar{\states} \subseteq \smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewdistancebi is defined by its \grpfctN \gfctdistancebi where $\gfctsubdistancebi : \smstates \to \imggrp$ with 
	\[
	\gfctdistancebi(\state) =
	\begin{cases}
		\distval - (\distval \text{ mod } n), &\text{if } d \neq \infty \\
		\infty, &\text{otherwise}
	\end{cases}		
	\]
	where $\distval = \distpathbi(\chgph,\bar{\states}, \state)$ and $\imggrp = \natnums \cup \{\infty\} \cup \remset$.
\end{definition}

Again, because the only difference of \viewdistancebi to \viewdistance is that \distpathbi is used instead of \distpath, we omit explaining behavior and construction of equality, equivalence classes and the new state set.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{15mm}		
		\centering \input{./04/images/distance/distRevAfter}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\hspace{10mm}		
		\centering \input{./04/images/distance/distBiAfter}
	\end{minipage}	
	\caption{Simplified representations of the \viewsN $\viewdistancerev(\{\state_1, \state_6\}, 1)$ (middle) and $\viewdistancebi(\{\state_1, \state_9\}, 1)$ (right) on the \chgph from Figure \ref{fig:Distance}.} 
	\label{fig:DistanceRevBi}  
\end{figure}

\redcomment{Explanation could be added}



%\subsubsection{Double Directed Edges with same Action}
%\redcomment{NOT SURE IF SHOULD BE INCLUDED}
%\begin{definition}
%	Let $\chgph = \chgphtuple$ be \achgphN.
%\end{definition}

\subsubsection{Cycles}
A cycle is a structure that can exist in every graph. The concept of cycles is not specific to \chgphsN or any of its more specialized variants. The purpose of this thesis is to discuss views that utilize domain specific knowledge or if a general concept is of special relevance when exploring \achgphN. The former and the latter apply on cycles.

Formalizing \viewsN based on cycles requires some formalization of the concept cycle. We will use a domain specific definition that will serve us the most.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A (simple) \emph{cycle} \cycle in \chgph is a sequence \cyclesecfull alternating between states and actions where $n \in \natnums, \{\state_0, \dots, \state_{n-1}\} \subseteq \states$ is a set of distinct states,  $\{\action_0, \dots, \action_{n-1}\} \subseteq \actions$ and for all $i \in \{0, \dots, n-1\}$ it is $(\state_i,\action_i, \state_{i+1 \text{ mod }n}) \in \trans$.
\end{definition}

When the actions in the cycle are of no further importance, we will omit them only writing a sequence of states. In the following let $\cycle = \cyclesecfull$ be a cycle. For conveniences we will write $\state \in \cycle$ if the state is contained in the cycle \cycle and $\action \in \cycle$ if the action is contained in in the cycle \cycle. \redcomment{only if??} In words we will both write a state or action is \emph{on} or \emph{in} the cycle. Let $\cycle_1$ and $\cycle_2$ be cycles. $\cycle_1 \cup \cycle_2 := \{\state \in \states \mid \state \in \cycle_1 \text{ or } \state \in \cycle_2\}$.

\begin{definition}
	Let \cycle be an cycle in \chgph and \states be the states set of \chgph. The number $|\{\state \in \states \mid \state \in \cycle\}| =: \lencycle(\cycle)$ is called the \emph{length} of a cycle. 
\end{definition}

\begin{definition}
	Let $\chgph$ be an \chgphN. The set $\cycleset := \{ \cycle \mid \lencycle(\cycle) \geq n\}$ declares the set of all cycles in \chgph with a length of at least $n$.
\end{definition}

In practice there exist several cycle finding algorithms. The function $\fctfindcycles(\chgph, n)$ is an abstraction for one of these algorithms being used. The actual implementation relys on algorithms of the Java library \jgrapht \cite{Michail2020} namely the \redcomment{Algorithm Szwarcfiter and Lauer - $O(V+EC)$ and Tiernan - $O(V.constV)$ CITATION!!}

With the formalization done we will introduce some views utilizing the concept cycles. For one we will combine the notion cycle with domain specific knowledge for the other we will consider how and why cycles in MDPs are in general of relevance. We will begin with the latter. Cycles in general are of interest because in many cases they are unwanted as they lead to lead to infinite values for model checking results. While it depends on the actual model in many cases infinite values in model checking often are unwanted and due to faulty construction of the model. Finding cycles hence may help in debug \achgphN. Therefore a \viewN that simply finds existing cycles is feasible.


\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewhascycle is defined by its \grpfctN \gfcthascycle where $\gfctsubhascycle : \smstates \to \imggrp$ with
	\[
	\gfctsubhascycle(\state) =
	\begin{cases}
			\remelem, &\text{if } \exists \cycle \in \cycleset : \state \in \cycle \\
			\notppty, &\text{otherwise}
		\end{cases}
	\]
	
	and $\imggrp = \{\group, \remelem\}$.
\end{definition}

This \viewN groups all states that are contained in cycle with a length of at least $n$. It is to note that the affinity of a state to one or several respective cycles is lost. For $\state_1, \state_2$ they are grouped $\gfcthascycle(\state_1) = \gfcthascycle(\state_2) \neq \remelem$. Hence, the obtained equivalence classes are
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfcthascycle(\state) = \remelem\} = \{\state\} &\text{if } \exists \cycle \in \cycleset : \state \in \cycle \\
	\eqclassv &= \{\state \in \states \mid \gfcthascycle(\state) = \notppty\} &\text{otherwise}
\end{align*}

The set of states $\states'$ of \viewhascycle is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\{\state\} \mid \state \in \states, \,\text{if } \exists \cycle \in \cycleset : \state \in \cycle\} \\
	&\;= \{\{\state\} \mid \state \in \states, \, \gfcthascycle(\state) = \remelem\} = \nogroupstates \\
	\states_2 &:= \{\{\state \in \states  \mid \text{if } \exists \cycle \in \cycleset : \state \in \cycle \}\} = \{\{\state \in \states \mid \gfcthascycle(\state) = \notppty\}\}.
\end{align*}

\begin{figure}[h]
	\centering
	\input{./04/images/cycles/cyclesBefore}			
	\caption{Simplified representation of \mdp}
	\label{fig:cyclesBefore}  
\end{figure}

\begin{figure}[h]
	\centering
	\input{./04/images/cycles/cyclesAfterHas}
	\caption{Simplified representations of the \viewN \viewhascycle on \chgph from Figure \ref{fig:cyclesBefore}. The states $\state_{12}$ and $\state_{13}$ are grouped since they are the only states not on a cycle.}
	\label{fig:cycleAfterHas}  
\end{figure}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewexactcycle is defined by its \grpfctN \gfctexactcycle where $\gfctsubexactcycle : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\cycle \in \cycleset \mid \state \in \cycle\}
	\]
	
	and $\imggrp = \powerset{\cycleset}\cup \remset.$
	\label{def:exactcycleview}
\end{definition}

This \viewN groups states that have the same set of cycles they are contained in. Thus if $\cycle_1$ and $\cycle_2$ are distinct cycles and $\state_1, \state_2 \in \cycle_1$ and $\state_1 \in \cycle_2$ but $\state_2 \notin \cycle_2$ they are not grouped. It suffices that a state is on one cycle that the other one is not on, in order for the states not being grouped. In graphs with many cycles this can lead to little grouping.

Two states $\state_1, \state_2$ are grouped if $\gfctexactcycle(\state_1) = \gfctexactcycle(\state_2) \neq \remelem$. Hence, the obtained equivalence classes are
\begin{align*}
	\eqclassv &= \{\state' \in \states \mid \gfctexactcycle(\state') = \gfctexactcycle(\state) = \{\cycle_1, \dots, \cycle_n\} \subseteq \cycleset\}
\end{align*}

According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewexactcycle.

\redcomment{GREEDY APPROACHES (STATE ON SINGLE CYCLE), AND SET APPROACH s $\to$ $C_1 \cup C_2$ omitted because not sure if needed}

The \viewN above might be useful when having found cycles to see what cycles specifically exist. It might be interesting to find cycles that consist only of transitions of the same action. The following \viewN accomplishes that.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
%		\hspace{5mm}
		\input{./04/images/cycles/cyclesAfterExact0}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/cycles/cyclesAfterExact5}
	\end{minipage}
	\caption{\viewNC $\viewexactcycle(2)$ (left) and \viewN $\viewexactcycle(5)$ (right) on \chgph from Figure \ref{fig:cyclesBefore}}
	\label{fig:cycleAfterExtact}  
\end{figure}

In Figure \ref{fig:cycleAfterExtact} we can observe the \viewsN of $\viewexactcycle(2)$ and $\viewexactcycle(5)$ on \chgph from Figure \ref{fig:cyclesBefore}. In the simplified representation of \achgphN, we find six cycles of size at least two:

\begin{align*}
	\cycle_1 &= (\state_1, \action, \state_2, \action, \state_3, \actionb, \state_4, \actionb, \state_5, \actionb, \state_6, \actionb, \state_7, \action, \state_8, \actionb, \state_1) \\
	\cycle_2 &= (\state_1, \action, \state_2, \action, \state_3, \action, \state_7, \action, \state_8, \actionb, \state_1) \\
	\cycle_3 &= (\state_3, \actionb, \state_4, \actionb, \state_5, \actionb, \state_6, \actionb, \state_7, \actionb, \state_3) \\
	\cycle_4 &= (\state_7, \actionc, \state_9, \actionc, \state_{10}, \actionc, \state_{11}, \actionc, \state_7) \\
	\cycle_5 &= (\state_1, \action, \state_2, \actionc, \state_7, \action, \state_8, \actionb, \state_1) \\
	\cycle_6 &= (\state_3, \action, \state_7, \actionb, \state_3)
\end{align*}

\viewNC $\viewexactcycle(3)$ results as displayed as in the simplified representation on the left because because the following states are contained in exactly these cycles

\begin{align*}
	\state_1, \state_2, \state_8 &\text{ in } \cycle_1, \cycle_2, \cycle_5 \\
	\state_3 &\text{ in } \cycle_1, \cycle_2, \cycle_3, \cycle_5, \cycle_6 \\
	\state_7 &\text{ in } \cycle_1, \cycle_2, \cycle_3, \cycle_4, \cycle_5, \cycle_6 \\
	\state_4, \state_5, \state_6 &\text{ in } \cycle_1, \cycle_3 \\
	\state_9, \state_{10}, \state_{11} &\text{ in } \cycle_4
\end{align*}
and $\state_{12}$ and $\state_{13}$ are contained in no cycle of size at least two, i.e. $\gfctexactcycle(\state_{12}) = \gfctexactcycle(\state_{13}) = \emptyset$. For the $\viewexactcycle(5)$ it is $\cycle_{\chgph, 5} = \{\cycle_1, \cycle_2, \cycle_3\}$. Thereby we have the following states being exactly contained in these cycles:

\begin{align*}
	\state_1, \state_2, \state_8 &\text{ in } \cycle_1, \cycle_2 \\
	\state_3 &\text{ in } \cycle_1, \cycle_2, \cycle_3 \\
	\state_7 &\text{ in } \cycle_1, \cycle_2, \cycle_3 \\
	\state_4, \state_5, \state_6 &\text{ in } \cycle_1, \cycle_3 \\
\end{align*}
and $\gfctexactcycle(\state) = \emptyset$ for all remaining states \state.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewexactactcycle is defined by its \grpfctN \gfctexactactcycle where $\gfctsubexactactcycle : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\cycle \in \cycleset \mid \state \in \cycle, \tilde{\action} \in \cycle, \forall \action \in \cycle : \action = \tilde{\action} \}
	\]
	
	and $\imggrp = \powerset{\cycleset} \cup \remset.$
\end{definition}

The \viewN specializes the \viewN from Definition \ref{def:exactcycleview} in the sense that it additionally requires for all $\cycle \in \gfctexactcycle$ that all actions occurring in the cycle are the same.The reasoning about the equality of the \grpfctN values, the obtained equivalence classes and the resulting set of states $\states'$ of the \viewN is analogous to \viewexactcycle and thus omitted.

\begin{figure}[h]
	\centering	
	\input{./04/images/cycles/cyclesAfterExactAct0}	
	\caption{Simplified representation of the \viewN \viewcycleset on \mdp from Figure \ref{fig:cyclesBefore}}
	\label{fig:cycleAfterExactAct2}
\end{figure}

In Figure \ref{fig:cycleAfterExactAct2} the simplified representation of $\viewexactactcycle(2)$ on \chgph from Figure \ref{fig:cyclesBefore} can be observed. From cycles listed in the discussion of Figure \ref{fig:cycleAfterExtact} only $\cycle_3$ and $\cycle_4$ consist of transitions with the same actions, i.e. only $\cycle_3, \cycle_4 \in \gfctexactactcycle[\states]$ for $n = 2$. The \viewN \viewexactactcycle in Figure \ref{fig:cycleAfterExactAct2} results because the following states are contained in exactly these cycles

\begin{align*}
	\state_3, \state_4, \state_5, \state_6 &\text{ in } \cycle_3 \\
	\state_7 &\text{ in } \cycle_3, \cycle_4 \\
	\state_9, \state_{10}, \state_{11} &\text{ in } \cycle_4
\end{align*}
and for all remaining states \states it is $\gfctexactactcycle(\state) = \emptyset$.

When discussing definition \ref{def:exactcycleview} we stated that little grouping can occur when mapping on the set of cycles in all of which the state is contained. Hence we provide the definition and implementation of a \viewN that groups states even though their set of cycles is not equal, but there is sufficient similarity in the cycles they are on. This might be useful to find clusters of cycles.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewcycleset is defined by its \grpfctN \gfctcycleset where $\gfctsubcycleset : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\smstate \in \states \mid \state, \smstate \in \cycle \in \cycleset\}
	\]
	and $\imggrp = \states \cup \remset.$
\end{definition}

\begin{figure}[h]
	\centering
	\input{./04/images/cycles/cyclesAfterSet0}
	\caption{Simplified representation of the \viewN $\viewcycleset(2)$ on \mdp from Figure \ref{fig:cyclesBefore}} 
	\label{fig:cycleAfterSet0}  
\end{figure}

In Figure \ref{fig:cycleAfterSet0} the simplified representation of $\viewexactactcycle(2)$ on \chgph from Figure \ref{fig:cyclesBefore} can be observed. Since it is $n=2$ we consider the same cycles as in the discussion of Figure \ref{fig:cycleAfterExtact}. It is $\state_1, \dots, \state_8 \in \cycle_1$. Hence, for $i \in \{1, \dots, 8\}$ it is $\gfctcycleset(\state_i) \subseteq \{\state_1, \dots, \state_8\}$. For $\state \in \{\state_1, \dots, \state_8\} \setminus \{\state_7\}$ there is no cycle containing any other state than $\{\state_1, \dots, \state_8\}$. Thus, for $i \in \{1, \dots, 8\}$ it is $\gfctcycleset(\state_i) = \{\state_1, \dots, \state_8\}$.For the state $\state_7$ it is $\gfctcycleset(\state_7) = \{\state_1, \dots, \state_{11}\}$ because of $\state_7 \in \cycle_4$ and $\state_{12}, \state_{13}$ are contained in no cycle of length at least two. Also because $\state_{12}, \state_{13}$ are contained in no cycle of length at least two it is $\gfctcycleset(\state_{12}) = \gfctcycleset(\state_{13}) = \emptyset$. Obviously for $\state_9, \state_{10}, \state_{11}$ it is $\gfctcycleset(\state_i) = \{\state_7, \state_9, \state_{10}, \state_{11}\}$ because it is only $\state_9, \state_{10}, \state_{11} \in \cycle_4$ as $\state_7$ denies them being on any other (\emph{simple}) cycle. Thereby the grouping results in a view as depicted as simplified representation in Figure \ref{fig:cycleAfterSet0}.


Each state is mapped to the set of states resulting from joining the state sets of all the cycles the state is on. 

\subsubsection{Strongly Connected Components}
Strongly connect components (\sccN) are are interesting when exploring \achgphN because they group states where may happen some complex operation. Morover finding strongly connected components is way more efficient than finding cycles. Since every cycle also is a strongly connected component finding strongly connected components can be seen as finding a set that contains cycles. Therefore it is feasible to consider a \viewN utilizing strongly connected components. Deviating from most definitions we will define \sccN not as a subgraph but only as the set of its nodes. Moreover the definition is written in the terms of \achgphN.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. A set $\scc \subseteq \states$ is called \emph{strongly connected component} if for all $\state, \state' \in \scc$ either it holds
	\[
		\exists \path \in \pathset : \pfirst(\path) = \state \land \; \plast(\path) = \state'
	\]
	{\centering{or}}
	\[
	 \state = \state'\text{.}
	\]
	
%	\begin{align*}
%			\scc = \{\state_1 \in \states \mid & \; \forall \state' \in \scc : \exists n \in \natnums, \exists \; \! (\state_1, \action_1, \state_2, \action_2 \dots, \state_n, \action_n, \state') \\
%			&\text{ where } (\state_n, \action_n, \state') \in \trans \land \forall i \in \{1, \dots, n-1\} : (\state_i, \action_i, \state_{i+1}) \in \trans \}
%	\end{align*}
%	That is for every state in the set there has to exist a sequence of transitions to every other state of the set. The state itself is always considered a reachable by itself, i.e. there does not need to exist a self loop. In consequence, each state is contained in stronlgy connected component namely at least in the one that only contains the state. 
	\noindent
	The set of all strongly connected components of \chgph, that contain at least $n$ states, is denoted with \setscc.
\end{definition}

Since the strong connection is an equivalence relation the \sccsN are equivalence classes and hence disjoint. To find \sccsN Tarjan's and Sahir's algorithm is the classic \cite{Sharir1981}. In the implementation an improved variant from Gabow \cite{Gabow2000} is used supplied by the \jgrapht library.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewscc is defined by its \grpfctN \gfctscc where $\gfctsubscc : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\scc \in \setscc \mid \state \in \scc\}
	\]
	and $\imggrp = \setscc \cup \remset$.
\end{definition}

This \viewN groups all states together that are in the same \sccN. Note that for all states \state \gfctscc(\state) is a singleton set because \sccsN are disjoint. That is, each state is mapped to the set only containing its strongly connected component or to the empty set if its \sccN has less than $n$ elements. In the \viewN \viewscc two states $\state_1, \state_2 \in \states$ are grouped if $\gfctscc(\state_1) = \gfctscc(\state_2) \neq \remelem$. Hence the equivalence classes are:
\begin{align*}
	\eqclassv &= \{\state' \in \states \mid \gfctscc(\state') = \gfctscc(\state) =: \scc \in \setscc\} \quad\quad\quad \text{for } \state \in \scc
\end{align*}
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewexactcycle.

\begin{figure}[h]
	\begin{minipage}{.55\textwidth}
		\hspace{5mm}
		\input{./04/images/sccs/sccBefore}
	\end{minipage}
	\begin{minipage}{.5\textwidth}
%		\hspace{5mm}
		\input{./04/images/sccs/sccAfter}
	\end{minipage}
		\caption{Simplified representations of \mdp (left) and the \viewN $\viewscc(2)$ on it (right)}
		\label{fig:sccMin2}  
\end{figure}

In Figure \ref{fig:sccMin2} the simplified representation of $\viewscc(2)$ (right) on \chgph (left) can be observed.. The \sccsN in \chgph are $\{\state_1\}, \{\state_2, \state_3, \state_4, \state_5\}, \{\state_6, \state_7, \state_8, \state_9\}, \{\state_{10}, \state_{11}, \state_{12}\}$ and $\{\state_{13}\}$. Because the \sccN of state $\state_{13}$ has not cardinality two but one it is mapped to the empty set and would be grouped with any other \state whoms strongly connected component has less than two elements.

A special kind of strongly connected components is the the bottom strongly connected component.

\begin{definition}
	Let \scc be a \sccN. A \emph{bottom strongly connected component} (\bsccN) is a \sccN where it holds that:
	\[
	\forall \state \in \scc : \forall (\state, \action, \state') \in \trans : \state' \in \scc
	\]
%	\[
%	\forall \state \in \scc : \bigsum{t \in \scc} \trans(\state, t) = 1
%	\]
	That is from \scc there is no state reachable outside of \scc. The set of all bottom strongly connected components of \chgph, that contain at least $n$ states, is denoted with \setbscc.
\end{definition}

\redcomment{Bottom strongly connected components are of relevance because they pose a terminal structure of an \chgph that can not be left.}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$. The \viewN \viewbscc is defined by its \grpfctN \gfctbscc where $\gfctsubbscc : \smstates \to \imggrp$ with
	\[
	\state \mapsto \{\scc \in \setbscc \mid \state \in \scc\}
	\]
	and $\imggrp = \setbscc \cup \remset$.
\end{definition}

The \viewN \viewbscc groups all states together that are in the same \bsccN. That is, it is a specialization of \viewscc, because instead of all \sccsN the set is no restricted to the ones where there is no outgoing transition to another \sccN. Hence, equality, equivalence classes and the state set behave and are constructed very similarly.

\begin{figure}[h]
	\begin{minipage}{.55\textwidth}
		\hspace{5mm}
		\input{./04/images/sccs/sccBefore}
	\end{minipage}
	\begin{minipage}{.5\textwidth}		
		\input{./04/images/sccs/bsccAfter}
	\end{minipage}
	\caption{Simplified representations of \mdp (left) and the \viewN \viewbscc(0) on it (right)}
	\label{fig:bsccAfter}  
\end{figure}

In Figure \ref{fig:bsccAfter} the simplified representation of $\viewbscc(0)$ (right) on \chgph (left) can be observed. The \sccsN in \chgph are $\{\state_1\}, \{\state_2, \state_3, \state_4, \state_5\}, \{\state_6, \state_7, \state_8, \state_9\}, \{\state_{10}, \state_{11}, \state_{12}\}$ and $\{\state_{13}\}$. The only ones where there is no state with an outgoing transition to state in another \sccN are $\{\state_6, \state_7, \state_8, \state_9\}$ and $\{\state_{13}\}$. Hence these two sets of states become a new state \viewbscc while all remaining states are mapped to $\emptyset$ and thereby grouped together.

In the implementation strongly connected components are determined using the algorithm of Gabow, afterwards filtering those \sccsN that have only transitions to states within the \sccN. When bottom strongly connected components are to be determined the found set of strongly connected components is then filtered, retaining those, that meet the requirement of being a \bsccN.
	
\end{document} 
