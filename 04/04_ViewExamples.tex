\documentclass[preview]{standalone}
\input{prelude}


\begin{document}
\section{View Examples}
In this chapter we will introduce and discuss some \viewN examples created by the author. Their purpose is to understand the idea and concept of a \viewN and get to know some views that might be useful in real world applications. \\
When considering \viewsN we only want into account those that utilize properties of MDPs or that do computations that are also feasible on normal graphs but are of explicit relevance MDPs.
\subsection{Views Utilizing MDP Components}
In this subsection we will introduce some views the are purely based on the components of an \mdpN. Their will neither be computations on the graph-structure of an MDP nor computations using the result vector.
\subsubsection{Atomic Propositions}
One of the least involved approaches to create a view is to base it on the atomic propositions that are assigned to each state by the labeling function. The notion is to group states that were assigned the same set of atomic propositions. \redcomment{Why useful?, currently no "has AP" -> maybe should be added}


\begin{definition}	
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN. The view \viewatomicprops is defined by its grouping function \gfctatomicprops \grpfctN with $\gfctatomicprops : \states \to \imggrp, {\state}\mapsto{\labelingfct(\state)}$.
\end{definition}

The grouping function is exactly the labeling function i.e. for all $\state \in \states$ it is $\gfctatomicprops(\state) := \labelingfct(\state)$. So it is $\gfctatomicprops(\state_1) = \gfctatomicprops(\state_2) \iff \labelingfct(\state_1) = \labelingfct(\state_2)$. According to Definition \ref{def:eqrelview} for $\smstate \in \states$ it is $\eqclassv[\smstate] = \{\state \in \states \mid \labelingfct(\state) = \labelingfct(\smstate)\}$.
%$\forall \state_1, \state_2 \in \states :

By this we obtain the \viewN $\viewatomicprops$ for a given \chosengraphtypeN \chgph where: $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =  \bigcup_{a \in \atomicprops} \{\{\state \in \states \mid \labelingfct(\state) = a\}\}$. All other components are constructed as in Definition \ref{def:view}.

Although this view might seem rather simple because it is only performs $\gfctatomicprops := \labelingfct$ it is the most powerful one of all the views that will be shown later on. This is because every view presented in the following is reducible to this one. That is because a \grpfctN essentially asserts an atomic proposition to every state, namely the value in respect to the considered property of a given view. The reduction can be realized by replacing the labeling function with the grouping function of the resepective view. That is $\labelingfct := \grpfct$ and $\atomicprops := \redcomment{\grpfct(\states)}$ for some \grpfctN \grpfct.

\subsubsection{Initial States}
An a little more involved idea than directly using a given function is to utilize the set of initial states. We can group states that have a probability greater zero, that they are started from. In practice this might be useful to quickly find all initial states.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\initstates := \{\state \in \states \mid \state \in \init\}$. The view \viewinitstates is defined by its grouping function \gfctinitstates \grpfctN with $\gfctinitstates : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
		\emptyset,				& \text{if } \state \in \initstates \\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	and $\imggrp := \{\emptyset\} \cup \remset$.
\end{definition}

For $\state_1,\state_2 \in \states$ it is $\gfctinitstates(\state_1) = \gfctinitstates(\state_2)$ \iffN $\state_1, \state_2 \in \initstates$ or $\state_1 = \state_2$. According to Definition \ref{def:eqrelview} it is 
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctinitstates(\state) = \emptyset\} &\text{for } \state \in \initstates \text{ and} \\
	\eqclassv &= \{\state \in \states \mid \gfctinitstates(\state) = \{\state\} \} = \{\state\} &\text{for } \state \notin \initstates.
\end{align*}


By this we obtain the \viewN $\viewinitstates$ for a given \chosengraphtypeN \chgph where: $\states' = \bigcup_{\state \in \states} \{\eqclassv\} = \{\state \in \states \mid \state \in \initstates\}\cup \bigcup_{\state \in \states \setminus \initstates}\{\{\state\}\}$.

All other components are constructed as in Definition \ref{def:view}.

\subsubsection{Outgoing Actions}
\redcomment{define outgoing transition and outgoing action}
The \emph{OutAction View} groups states that share some property regarding their actions  of the outgoing transitions. Several variants are feasible. In the following we will use the expression "outgoing action \action" equivalent with "transition with outgoing action \action".

The most obvious variant to group states is to group states that \emph{have} a given outgoing action. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The view \viewhasoutaction is defined by its \grpfctN $\gfcthasoutaction : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state' \in \states: (\state, \action, \state') \in \trans \\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	and $\imggrp := \setoutact$.	
\end{definition}


For $\state_1,\state_2 \in \states$ it is $\gfcthasoutaction(\state_1) = \gfcthasoutaction(\state_2)$ \iffN 
there exist $\state_{a},\state_{b} \in \states$ with 
$(\state_1, \action, \state_{a}), (\state_2, \action, \state_{b}) \in \trans$ (i.e. they have the same outgoing action \action) or $\state_1 = \state_2$. 
In accordance with Definition \ref{def:eqrelview} it is
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfcthasoutaction(\state) = \action\} &\exists\state' \in \states : (\state, \action, \state') \in \trans \\
	\eqclassv &= \{\state \in \states \mid \gfcthasoutaction(\state) = \state\} = \{s\} &\text{ otherwise}
\end{align*}
 %if for all $\state' \in \states : (\state,\action,\state') \notin \trans$.

Thereby we obtain the \viewN \viewhasoutaction for a given \chosengraphtypeN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where
\begin{align*}
	 \states_1 &:= \{\state \in \states \mid \exists \state' \in \states: (\state, \action, \state') \in \trans\} = \{\state \in \states \mid \state \text{ has outgoing action \action }\} \\
	\states_2 &:= \remstates.
\end{align*}


Since actions are a very important part of \chosengraphtypesN as well as of its more powerful siblings MDPs and MCs it seems useful to further enhance this view and look at variants of it. Instead of only grouping states that only \emph{have} outgoing actions we could also quantify the amount of times that action should be outgoing.

For example we could require that a given action has to be outgoing a minimum amount of times. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The view \viewminoutaction is defined by its \grpfctN $\gfctminoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state_1, \dots, \state_\numoutact \in \states:  \predminoutact\\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \setoutact$, $\numoutact \in \natnums$ is the minimum amount of times a transition with action \action has to be outgoing in order to be grouped with the other states and
	\[
	\predminoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_\numoutact) \in \trans) \land |\{\state_1, \dots, \state_\numoutact\}| = \numoutact
	\]
	
	is a first order logic predicate.
	\label{def:minoutaction}
\end{definition}

The number  and  
The predicate \predminoutact requires that there are transitions with action \action to \numoutact distinct states.

For $\state_1,\state_2 \in \states$ it is $\gfctminoutaction(\state_1) = \gfctminoutaction(\state_2)$ \iffN there exist distinct $\state_{a_1}, \dots, \state_{a_\numoutact} \in \states$ and distinct $\state_{b_1}, \dots, \state_{b_\numoutact} \in \states$ so that $(\state_1, \action, \state_{a_1}), \dots, (\state_1, \action, \state_{a_\numoutact}) \in \trans$ and $(\state_2, \action, \state_{b_1}), \dots, (\state_2, \action, \state_{b_\numoutact}) \in \trans$ or $\state_1 = \state_2$. According to Definition \ref{def:eqrelview} it is 
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctminoutaction(\state) = \action\} &\text{if } \predminoutact \\ 
	\eqclassv &= \{\state \in \states \mid \gfctminoutaction(\state) = \state\} = \{\state\} &\text{ otherwise}
\end{align*}

By this we obtain the \viewN $\viewminoutaction$ for a given \chosengraphtypeN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where 

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact\} \\ %(\state, \action, \state_1), \dots, (\state, \action, \state_\numoutact) \in \trans, |\{\state_1, \dots, \state_\numoutact\}| = \numoutact\} \\ 
	&\hspace{1.15mm}= \{\state \in \states \mid \text{the action } \action \text{ is outgoing at least } \numoutact \text{ times} \} \text{ and} \\
	\states_2 &:= \remstates.	
\end{align*}

In a similar fashion we define view that groups states where at most a certain number of times a given action is outgoing. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The view \viewmaxoutaction is defined by its \grpfctN $\gfctmaxoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \remset$, $\numoutact \in \natnums$ is the maximal number of times a transition with action \action may be outgoing and 
	\[
	\predmaxoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_{\numoutact+1}) \in \trans) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numoutact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
	\label{def:viewmaxoutaction}
\end{definition}

 It ensures that if there are one more than \numoutact outgoing transitions with an action \action at least two of the states where the transitions \redcomment{end} are in fact the same. Since this is required for all possible combinations of $\numoutact + 1$ states by the grouping function, only states that have at most \numoutact outgoing actions will be assigned with \action by the grouping function. The reasoning about the equality of the \grpfctN values, the obtained equivalence classes and the resulting set of states $\states'$ of the view is analogous to \viewminoutaction.

Since we already defined \grpfctsN and hence views for a required minimal and maximal amount of times an action has to be outgoing it is now easily possible to define a view that groups states where the amount of outgoing actions is at least \numoutact and at most \numoutactb. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The view 
	\viewspanoutaction is defined by its \grpfctN $\gfctspanoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \remset$ and $\numoutactb, \numoutact \in \natnums$ are the minimal and maximal number of transitions with action \action in order for state to be grouped. The predicates \predminoutact and \predmaxoutact are the predicates from Definition \ref{def:minoutaction} and Definition \ref{def:viewmaxoutaction} respectively.
\end{definition}

We already know that for a given $\state \in \states$ the expressions $\exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact$ and $\forall \state_1, \dots, \state_{\numoutactb+1} \in \states: \predmaxoutact[\numoutactb]$ from Definition \ref{def:minoutaction} and Definition \ref{def:viewmaxoutaction} require that \state has minimal and maximal amount of outgoing transitions with an action \action respectively. Hence the conjunction will be true for states where the amount of outgoing transitions with action \action is element of the set $\{\numoutactb, \numoutact+1, \dots, \numoutact-1, \numoutact\}$. We will write for this that the number of outgoing actions is \emph{in the span}.

For a given state \state and action \action we set
\[
\formoutact:= \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb]\land \\
\forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact
\]

for convenience. \formoutact is true  \iffN the number of outgoing actions is in the span. For $\state_1, \state_2 \in \states$ it is $\gfctspanoutaction(\state_1) = \gfctspanoutaction(\state_2)$ \iffN $\formoutact[\state_1] \land \formoutact[\state_2]$ or $\state_1 = \state_2$. Then its equivalence classes are

\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \action\} &\formoutact \text{ true} \\
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \state\} = \{\state\} &\text{ otherwise}	
\end{align*}

The new set of states $\states'$ of the view \viewspanoutaction is the union of the equivalence classes of equivalence relation \eqrelview on the set of states \states of the original \chosengraphtypeN. Hence it is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \gfctspanoutaction(\state) = \action\} \\
	&\hspace{1.15mm}= \{\state \in \states  \mid \formoutact \text{ true}\} \\
	&\hspace{1.15mm}= \{\state \in \states \mid \text{the action } \action \text{ is outgoing } \numoutactb \text{ to } \numoutact \text{ times}\} \text{ and} \\
	\states_2 &:= \remstates.
\end{align*}

The \viewsN above can be combined with \parllcompN. The thereby obtained \viewN requires that the respective conditions of all the combined \viewsN are met. In this sense it is a conjunctive combination.

Instead of making requirements about states and group them based on whether they meet these requirements it also possible to group states that are very similar or even identical in regard to their outaction. We consider this idea with the \emph{\outactident \viewNC} in two variants: \outactidentstrong and \outactidentweak (idententiy). Firstly we will consider the variant of strong identity.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The \viewN \viewstrongoutactident is defined by its \grpfctN $\gfctstrongoutactident : \states \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numoutact) \mid \action \in \actions, \numoutact \text{ is the number of times that \action is outgoing from } \state\}
	\]
	and $\imggrp := \actions \times \natnums_0$.
\end{definition}

The \grpfctN asserts to each state a set of pairs. Note that a pair is contained int the set for each action $\action \in \actions$. In case there is no outgoing transition from state \state with an action \action it is $(\action, 0) \in \gfctstrongoutactident$. For $\state_1, \state_2 \in \states$ it is $\gfctstrongoutactident(\state_1) = \gfctstrongoutactident(\state_2)$ \iffN $\state_1$ and $\state_2$ are mapped to the same set of pairs. By Definition \ref{def:eqrelview} the obtained equivalence classes of \eqrelview are
\[
	\eqclassv := \{\state \in \states \mid \gfctstrongoutactident(\state) = \{(\action_1, \numoutact_1), \dots, (\action_l, \numoutact_l)\}, l = |\actions|\}
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewstrongoutactident. All other components of \viewstrongoutactident are as usual structured in accordance with the Definition \ref{def:view}.
As mentioned earlier a \outactidentweak variant of the \outactident \viewN is also conceivable.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The \viewN \viewweakoutactident is defined by its \grpfctN $\gfctweakoutactident : \states \to \imggrp$ with
	\[
	\state \mapsto \{\action \in \actions \mid \exists \state' \in \states : (\state, \action, \state') \in \trans\} 	
	\]
	and $\imggrp := \actions$.
\end{definition}
\redcomment{condition of image-set written in inconsistent style to strong identity. Swap strong and weak (order)?}

\redcomment{The grouping function maps to the set of outgoing actions of a state and thereby discards information about the number of times an actions is outgoing. If an action is not outgoing from a state it is not contained in the set.}

For $\state_1, \state_2 \in \states$ it is $\gfctweakoutactident(\state_1) = \gfctweakoutactident(\state_2)$ \iffN they are mapped to the same set of actions. Hence the equivalence classes of \eqrelview are
\[
	\eqclassv{\smstate} = \{ \state \in \states \mid \gfctweakoutactident(\state) = \gfctweakoutactident(\smstate) =: \{\action_1, \dots, \action_l\}, l \in \natnums\}.
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewweakoutactident.

\subsubsection{Ingoing Actions}
Analogously to Outgoing Actions views of utilizing ingoing actions are feasable. Since there is no difference apart from the definitions itself, we only provide the definitions.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The view \viewhasinaction is defined by its \grpfctN $\gfcthasinaction : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state' \in \states: (\state', \action, \state) \in \trans \\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	and $\imggrp := \actions \cup \remset$.	
	\label{def:mininaction}
\end{definition}	


\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The view \viewmininaction is defined by its \grpfctN $\gfctmininaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state_1, \dots, \state_\numinact \in \states:  \predmininact\\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \remset$, $\numinact \in \natnums$ is the minimum amount of times a transition with action \action has to be ingoing in order to be grouped with the other states and
	\[
	\predmininact := ((\state_1, \action, \state), \dots, (\state_\numinact, \action, \state) \in \trans) \land |\{\state_1, \dots, \state_\numinact\}| = \numinact
	\]
	is a first order logic predicate.
	\label{def:viewmaxinaction}
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The view \viewmaxinaction is defined by its \grpfctN $\gfctmaxinaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \remset$, $\numinact \in \natnums$ is the maximal number of times a transition with action \action may be ingoing and 
	\[
	\predmaxinact := ((\state_1, \action, \state), \dots, (\state_{\numinact+1}, \action, \state) \in \trans) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numinact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The view 
	\viewspaninaction is defined by its \grpfctN $\gfctspaninaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
		\action,				& \text{if } \exists \state_1, \dots, \state_\numinactb \in \states: \predmininact[\numinactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
		\remelem,          	& \text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \actions \cup \remset$ and $\numinactb, \numinact \in \natnums$ are the minimal and maximal number of transitions with action \action in order for state to be grouped. The predicates \predmininact and \predmaxinact are the predicates from Definition \ref{def:mininaction} and Definition \ref{def:viewmaxinaction} respectively.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The \viewN \viewstronginactident is defined by its \grpfctN $\gfctstronginactident : \states \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numinact) \mid \action \in \actions, \numinact \text{ is the number of times that \action is ingoing from } \state\}
	\]
	and $\imggrp := \actions \times \natnums_0$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\action \in \actions$. The \viewN \viewweakinactident is defined by its \grpfctN $\gfctweakinactident : \states \to \imggrp$ with
	\[
	\state \mapsto \{\action \in \actions \mid \exists \state' \in \states : (\state', \action, \state) \in \trans\} 	
	\]
	and $\imggrp := \actions$.
\end{definition}

\subsubsection{Variables}
The concept of variables is not part of the definitions of neither \chosengraphtypesN, MCs or MDPs. Even though, it is of great importance in practical applications. Variables are used to represent states (in more detail). 

For example an \mdpN could be used to model a computer program with human interaction. Every state of the MDP refers an overall state of the program during execution time. In this state of the program, its variables will have specific values. We may want to retain the information about the variable's values of the program instead of only assigning a state $\state \in \states$ that refers to the state of the program. Variables and its current values are not only relevant to computer programs but also other systems. Many of those other systems rely on some kind of global state during execution, which can be expressed with variables and values assigned to them. Since there exists no explicit component to retain this information the notion of variables is used to store it.

\redcomment{OLD: Since transitions systems MCs and MDPs in practice are used to model, analyze and check real world systems it is very practical to not only name states but also describe the properties of the state in more detail. For a basic notion variables are to be imagined as a set of variables that may have different values in different states thereby describing the characteristics of the state more thoroughly. \purpcomment{ADDED TO OLD: In practice most often they arise naturally for example as variables of a computer program that is to be modeled with an \mdpN.}} 

Because of the vast importance in practical applications we will consider some \viewsN that utilize them. To do so and being able to describe them formally we define and formalize the notion of variables by considering them as a subset of the atomic propositions \atomicprops that is assigned a value by a function.

\begin{definition}
	The set $\vars$ is called \emph{variables}.
\end{definition}

\begin{definition}
	Let \varevalimg be an arbitrary set. The function $\vareval : \states \times \vars \to \varevalimg$ is called variable evaluation function.
\end{definition} 

Most of the time we will use \vareval to refer to the variable evaluation function. When we speak about the value of a variable in a state we refer to the image of $\vareval$ for that state and variable. The set \varevalimg is arbitrary so that arbitrary values can be assigned to a variable. Speaking in terms of computer science and programming this loosens as an example the restriction of only being able to assign numbers and no booleans.

The most apparent idea for a \viewN utilizing variables is to group states that meet some requirement regarding the values of the variables.


\redcomment{state has variable not here uptil now because probably not used}

\begin{definition}
	Let
	\begin{itemize}
		\item $\chgph = \chgphtuple$ be \chosengraphtypeN,
		\item $\var \in \vars \subseteq \atomicprops$ and 
		\item $\vareval(\state, \var) = \varval$ where $\state \in \states$.		
	\end{itemize} 
	The view \viewparamvalueseq is defined by its \grpfctN $\gfctparamvalueseq : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
		\varval, &\text{if } \vareval(\state, \var) = \varval\\
		\remelem, &\text{otherwise}
	\end{cases}
	\]
	where $\imggrp := \remset \cup \{a\}$.
\end{definition}

The view \viewparamvalueseq groups states that share the same value for a given variable. For $\state_1, \state_2$ it is $\gfctparamvalueseq(\state_1) = \gfctparamvalueseq(\state_2)$ \iffN $\vareval(\state_1, \var) = \vareval(\state_2, \var)$ or $\state_1 = \state_2$. The obtained equivalence classes are
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \vareval(\state, \var) = \varval\} \\
	\eqclassv &= \{\state \in \states \mid \gfctparamvalueseq(\state) = \state\} = \{\state\}
\end{align*}

The set of states $\states'$ of \viewparamvalueseq is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \gfctparamvalueseq(\state) = \varval\} \\
	&\hspace{1.15mm}= \{\state \in \states  \mid \vareval(\state, \var) = \varval\} \text{ and} \\
	\states_2 &:= \remstates.
\end{align*}

Analogously a view that requires inequality instead of equality is feasible.

\begin{definition}
	Let
	\begin{itemize}
		\item $\chgph = \chgphtuple$ be \chosengraphtypeN,
		\item $\var \in \vars \subseteq \atomicprops$ and 
		\item $\vareval(\state, \var) \neq \varval$ where $\state \in \states$.		
	\end{itemize} 
	The view \viewparamvaluesneq is defined by its \grpfctN $\gfctparamvaluesneq : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
		\varval, &\text{if } \vareval(\state, \var) \neq \varval\\
		\remelem, 	&\text{otherwise}
	\end{cases}
	\]
	where $\imggrp := \remset \cup \{a\}$.
\end{definition}

If states are to be grouped with the requirement of several variables equaling or not equaling specified values this can be achieved by using \parllcompN. 

To allow even more flexibility a view can be used that also allows a combination of requirements on variables in a disjunctive manner. To extend this idea to its full potential we will define a \viewN that allows requirements using a disjunctive normal formal (DNF). To formalize this view more efficiently we will write $\varstate[,kl] = \varval$ short for $\vareval(\state, \var_{kl}) = \varval$ where $k,l \in \natnums$ and $x_{kl} \in \vars$. In the same sense we write $\varstate[,kl] \neq \varval$. \redcomment{It may be that $x_{ab} = x_{mn}$ for $a,b,m,n \in \natnums$ NOT HAPPY WITH THIS}. We define the symbol \eqorneq to be an element of the set $\{=,\neq\}$. That is to say, whenever it is used each time written it is a representative for either the symbol $=$ or $\neq$. It allows to write one symbol whenever $=$ and $\neq$ could or should be possible. Moreover for this context we consider $(\varstate[,kl] = \varval)$ as a literal and $(\varstate[,kl] \neq \varval)$ as its negation. We write $(\varstate[,kl] \eqorneq \varval)$ for a literal that could be negated or not negated.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and 
	\[
	d(s) = ((\varstate[,11] \eqorneq \varval_{11}) \land \dots \land (\varstate[,1l_1] \eqorneq \varval_{1l_1})) \lor \dots \lor ((\varstate[,k1] \eqorneq \varval_{k1}) \land \dots \land (\varstate[,kl_k]  \eqorneq \varval_{kl_k}))
	\]
	proposition logical formulae in disjunctive normal form where
	\begin{itemize}
		\item $\{\var_{kl_i} \mid k \in \natnums, l_i \in \{l_1, \dots l_k\} \subseteq \natnums\} \subseteq \vars$ and $\varstate[,kl_i] = \vareval(\state, \var_{kl_i})$
		\item $\{\varval_{kl_i} \mid k \in \natnums, l_i \in \{l_1, \dots l_k\} \subseteq \natnums\} \subseteq \redcomment{\vareval(\states,\vars)}$
	\end{itemize}
	The \viewN \viewparamdnf is defined by its \grpfctN $\gfctparamdnf : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
		true, &\text{if } d(s) \text{ is true}\\
		\remelem, 	&\text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \{true, false\}$.
\end{definition}


The DNF allows us to specify a requirement in disjunctive normal form about variables. States are mapped to the same value depending on whether or not they meet this requirement.

\redcomment{DISCUSSION OF EQUALITY, EQ CLASSES AND RESULTING STATES MISSING}

Analogously a view based on a conjunctive normal formal can be defined that may be more convenient, depending on the query.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and 
	\[
	c(s) = ((\varstate[,11] \eqorneq \varval_{11}) \lor \dots \lor (\varstate[,1l_1] \eqorneq \varval_{1l_1})) \land \dots \land ((\varstate[,k1] \eqorneq \varval_{k1}) \lor \dots \lor (\varstate[,kl_k]  \eqorneq \varval_{kl_k}))
	\]
	proposition logical formulae in disjunctive normal form where
	\begin{itemize}
		\item $\{\var_{kl_i} \mid k \in \natnums, l_i \in \{l_1, \dots l_k\} \subseteq \natnums\} \subseteq \vars$ and $\varstate[,kl_i] = \vareval(\state, \var_{kl_i})$
		\item $\{\varval_{kl_i} \mid k \in \natnums, l_i \in \{l_1, \dots l_k\} \subseteq \natnums\} \subseteq \redcomment{\vareval(\states,\vars)}$
	\end{itemize}
	The \viewN \viewparamcnf is defined by its \grpfctN $\gfctparamcnf : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
		true, &\text{if } c(s) \text{ is true}\\
		\remelem, 	&\text{otherwise}
	\end{cases}
	\]
	
	where $\imggrp := \{true, false\}$.
\end{definition}

The only difference from the \viewN \viewparamcnf to the \viewN \viewparamdnf is whether the respective formulae is in conjunctive or disjunctive normal form.\redcomment{CITATION} Since each formulae in conjunctive normal form can tan be transformed to a formulae in disjunctive normal form and vice verse neither on of the \viewsN can perform an action the other can not. Hence there is no difference in expressivity, but there may be one in size. Therefore both views have been implemented and formalized. 

The views discussed before reduce the \chosengraphtypeN in a very precise but also manual manner, because it not only dictates the variable but also its value. A more general approach is to stipulate only the variable but not its value. This way states will be grouped that have the same value for that variable with no regard to the actual value of that variable. This idea could be achieved with a view based on the \grpfctN $\grpfct[\varval_1 ]$%\pll \dots \pll \gfctparamvalueseqopt[\varval_n]]$ with $\redcomment{\vareval(\states, \var)} = \{\varval_1, \dots, \varval_n\}$ and $|\vareval(\states,\var)| = n$. This grouping function just groups on every possible value for the variable \var. Since this is \redcomment{not very practical} we define a view that achieves this result in a more direct and more efficient way.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN. The view \viewparamvalident is defined by its \grpfctN $\gfctparamvalident : \states \to \imggrp$ with
	\[
	\state \mapsto \vareval(\state,\var)
	\]
	and $\imggrp := \vareval(\states, \var)$.
\end{definition}

With this grouping function we directly map to the value of the variable. Hence for $\state_1, \state_2 \in \states$ it is $\gfctparamvalident(\state_1) = \gfctparamvalident(\state_2)$ \iffN they are mapped to the value $\varval \in \imggrp$. Hence the equivalence classes of \eqrelview are
\[
\eqclassv{\smstate} = \{ \state \in \states \mid \vareval(\state) = \vareval(\smstate)\}.
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewparamvalident.


\subsection{Utilizing the MDP Graphstructure}
\subsubsection{Distance}
\redcomment{Implementation Algorithm	}
\begin{definition}
		Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $\smstates \subseteq \states$ arbitrary. \redcomment{$\fctdistdefault$ IMPLEMENTATION IN PSEUDOCODE? DEFINITION BEFORE?} The \viewN \viewdistance is defined by its \grpfctN $\gfctdistance : \states \to \imggrp$ with 
		\[
		\state \mapsto \distval \quad \quad \text{where } (\state, \distval) \in \fctdistdefault
		\]
		and $M = \states \times (\natnums \cup \{\inf\})$.
\end{definition}

Due to the implementation of \fctdistdefault for every state $\state \in \states$ exists a pair $(\state, \distval)$ in the returned set of \fctdistdefault. That is it is there for every state $\state \in \states$ there exists  $(\state, \distval)$ with $ (\state, \distval)\in \fctdistdefault$. The view groups states that have the same distance to the set measured with the amounts of transitions necessary reach the the closest \smstates considering the granularity \granularity.

\subsubsection{Double Directed Edges with same Action}
\redcomment{NOT SURE IF SHOULD BE INCLUDED}
\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN.
\end{definition}

\subsubsection{Cycles}
A cycle is a structure that can exist in every graph. The concept of cycles is not specific to \chosengraphtypesN or any of its more specialized variants. The purpose of this thesis is to discuss views that utilize domain specific knowledge or if a general concept is of special relevance when exploring \chosengraphtypeN. The former and the latter apply on cycles.

Formalizing \viewsN based on cycles requires some formalization of the concept cycle. We will use a domain specific definition that will serve us the most.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN. A (simple) \emph{cycle} in \chgph is any sequence \cyclesecfull alternating between states and actions where $n \in \natnums, \{\state_0, \dots, \state_{n-1}\} \subseteq \states$ is a set of distinct states,  $\{\action_0, \dots, \action_{n-1}\} \subseteq \actions$ and for all $i \in \{0, \dots, n-1\}$ it is $(\state_i,\action_i, \state_{i+1 \text{ mod }n}) \in \trans$.
\end{definition}

When the actions in the cycle are of no further importance, we will omit them only writing a sequence of states. In the following let $\cycle = \cyclesecfull$ be a cycle. For conveniences we will write $\state \in \cycle$ if the state is contained in the cycle \cycle and $\action \in \cycle$ if the action is contained in in the cycle \cycle. \redcomment{only if??} In words we will write a state or action is \emph{on} or \emph{in} the cycle. Let $\cycle_1$ and $\cycle_2$ be cycles. $\cycle_1 \cup \cycle_2 := \{\state \in \states \mid \state \in \cycle_1 \text{ or } \state \in \cycle_2\}$.

\begin{definition}
	Let \cycle be an cycle in \chgph and \states be the states set of \chgph. The number $n = |\{\state \in \states \mid \state \in \cycle\}|$ is called the \emph{length} of a cycle. 
\end{definition}

Apart from the formalization of the term cycle and the length of a cycle we will also have to formalize a way to find cycles.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $n \in \natnums$. The function  $\fctfindcycles(\chgph, n)$ is called \emph{cycle finder function} (CFF). It returns a set $\cycleset$ of all cycles in \chgph where for all $\cycle \in \cycleset$ it is $|\{\state \in \states \mid \state \in \cycle\}| \geq n$. That is there are at least $n$ states contained in each cycle. 
\end{definition}

In a programming like manner we will write $\fctfindcycles(\chgph,n)$ and thereby referring to its returned set. This will be clear from the context.

In practice there exist several cycle finding algorithms. The function $\fctfindcycles(\chgph, n)$ is an abstraction for one of these algorithms being used. The actual implementation relys on algorithms of the jave library \jgrapht namely the \redcomment{Algorithm Szwarcfiter and Lauer - $O(V+EC)$ and Tiernan - $O(V.constV)$ CITATION!!}

With the formalization done we will introduce some views utilizing the concept cycles. For one we will combine the notion cycle with domain specific knowledge for the other we will consider how and why cycles in MDPs are in general of relevance. We will begin with the latter.  Cycles in general are of interest because they pose the risk of getting stuck in endless loops, when performing actions on the \mdpN. \redcomment{Model checking is one of the most relevant actions on \chosengraphtypesN that are vulnerable to loops. They are performed commonly on them.} Therefore a \viewN that simply finds existing cycles is feasible.


\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $n \in \natnums$. The \viewN \viewhascycle is defined by its \grpfctN $\gfcthascycle : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
		inCycle, &\text{if } \fctfindcycles(\chgph, n) \neq \emptyset \\
		\remelem, &\text{otherwise}
	\end{cases}
	\]
	
	and $\imggrp = \remset \cup \{inCycle\}.$
\end{definition}

This \viewN groups all states that are contained in cycle with a length of at least $n$. It is to note that the affinity of a state to one or several respective cycles is lost.

\redcomment{DISCUSSION OF EQUALITY, EQ CLASSES AND RESULTING STATES MISSING}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $n \in \natnums$. The \viewN \viewexactcycle is defined by its \grpfctN $\gfctexactcycle : \states \to \imggrp$ with
	\[
	\state \mapsto \{\cycle \in \fctfindcycles(\chgph, n) \mid \state \in \cycle\}
	\]
	
	and $\imggrp = \powerset{\fctfindcycles(\chgph, n)}$
	\label{def:exactcycleview}
\end{definition}

This \viewN groups states that have the same set of cycles they are contained in. Thus if $C_1$ and $C_2$ are distinct cycles and $\state_1, \state_2 \in \cycle_1$ and $\state_1 \in \cycle_2$ but $\state_2 \notin \cycle_2$ they are not grouped. It suffices that a state is on one cycle that the other one is not, in order for the states not being grouped. In graphs with many cycles this can lead to little grouping.

\redcomment{DISCUSSION OF EQUALITY, EQ CLASSES AND RESULTING STATES MISSING}

\redcomment{GREEDY APPROACHES (STATE ON SINGLE CYCLE), AND SET APPROACH s -> $C_1 \cup C_2$ omitted because not sure if needed}

The view above might be useful when having found cycles to see what cycles specifically exist. Often it is interesting to find cycles that consist only of transitions of the same action. The following view accomplishes that.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN and $n \in \natnums$. The \viewN \viewexactcycle is defined by its \grpfctN $\gfctexactcycle : \states \to \imggrp$ with
	\[
	\state \mapsto \{\cycle \in \fctfindcycles(\chgph, n) \mid \state \in \cycle, \tilde{\action} \in \cycle, \forall \action \in \cycle : \action = \tilde{\action} \}
	\]
	
	and $\imggrp = \powerset{\fctfindcycles(\chgph, n)}$
\end{definition}

The view specializes the view from Definition \ref{def:exactcycleview} in the sense that it additionally requires for all $\cycle \in \gfctexactcycle$ that all actions occurring in the cycle are the same. \redcomment{doubling to above definition?}

\redcomment{NO DISCUSSION IF PREVIOUSLY}


\subsubsection{Strongly Connected Components}
Strongly connect components (\sccN) are of major importance in model checking \redcomment{I think so because I found the terms many times in the book. Remaining question: really? why?}
Therefore it is feasible to consider a view utilizing strongly connected components. Deviating from most definitions we will define \sccN not as a subgraph but only as the set of its nodes. Moreover the definition written in the terms of \chosengraphtypeN.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN. A set of the from
	\begin{align*}
		\scc = \{\state_1 \in \states \mid & \; \forall \state' \in \scc : \exists n \in \natnums, \exists \; \! (\state_1, \action_1, \state_2, \action_2 \dots, \state_n, \action_n, \state') \\
		&\text{ where } (\state_n, \action_n, \state') \in \trans \land \forall i \in \{1, \dots, n-1\} : (\state_i, \action_i, \state_{i+1}) \in \trans \}
	\end{align*}
	is called \emph{strongly connected component} of \chgph. That is for every state in the set there has to exist a sequence of transitions to every other state of the set. The set of strongly connected components of \chgph is denoted with \setscc.
\end{definition}

Since the strong connection is an equivalence relation the \sccsN are equivalence classes and hence disjoint. To find \sccsN Tarjans algorithm is the classic. In the implementation an improved variant from Gabow is used supplied by the \jgrapht library. \redcomment{CITATION}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN. The \viewN \viewscc is defined by its \grpfctN $\gfctscc : \states \to \imggrp$ with
	\[
	\state \mapsto \scc \quad \quad \text{ where } \redcomment{\state \in \scc \in \setscc}
	\]
	and $\imggrp = \setscc$.
\end{definition}

This view groups all states together that are in the same \sccN. Because \sccsN are disjoint each \state will be mapped to its one and only \sccN. This is because... \redcomment{DISCUSSION OF EQUALITY, EQ CLASSES AND RESULTING STATES MISSING}

A special kind of strongly connected components is the the bottom strongly connected component.

\begin{definition}
	Let \scc be a \sccN. A \emph{bottom strongly connected component} (\bsccN) is a \sccN where it holds that: \redcomment{concurrent versions}
	\[
	\forall \state \in \scc : \forall (\state, \action, \state') \in \trans : \state' \in \scc
	\]
	\[
	\forall \state \in \scc : \bigsum{t \in \scc} \trans(\state, t) = 1
	\]
	That is from \scc there is no state reachable outside of \scc. The set of bottom strongly connected components of \chgph is denoted with \setbscc.
\end{definition}

\redcomment{These are of special relevance because..}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \chosengraphtypeN. The \viewN \viewbscc is defined by its \grpfctN $\gfctbscc : \states \to \imggrp$ with
	\[
	\state \mapsto \scc \quad \quad \text{ where } \redcomment{\state \in \scc \in \setbscc}
	\]
	and $\imggrp = \setbscc$.
\end{definition}

In the implementation strongly connected components are determined using the algorithm of Gabow, afterwards filtering those \sccsN that have only transitions to states within the \sccN. Equality, equivalence classes and the new state set are constructed analogously to the view \viewscc.

\subsection{Utilizing the MDP Result Table}
In this section we will discuss \viewsN utilizing the result table. The actual implementation is relies on one powerful \viewN that can set to perform arbitrary actions using model checking results.

\redcomment{needhelp Understanding Cluster}





\end{document} 
