\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}


\begin{document}
\section{View Examples}
In this chapter we will introduce and discuss some \viewN examples created by the author. Their purpose is to understand the idea and concept of a \viewN and get to know some views that might be useful in real world applications. \\
When considering \viewsN we only want into account those that utilize properties of MDPs or that do computations that are also feasible on normal graphs but are of explicit relevance MDPs.
\subsection{Views Utilizing MDP Components}
In this subsection we will introduce some views the are purely based on the components of an \mdpN. Their will neither be computations on the graph-structure of an MDP nor computations using the result vector.
\subsubsection{Atomic Propositions}
One of the least involved approaches to create a view is to base it on the atomic propositions that are assigned to each state by the labeling function. The notion is to group states that were assigned the same set of atomic propositions. \redcomment{Why useful?, currently no "has AP" $\to$ maybe should be added}


\begin{definition}	
	Let $\chgph = \chgphtuple$ be \achgphN. The view \viewatomicprops is defined by its grouping function \gfctatomicprops \grpfctN with $\gfctatomicprops : \states \to \imggrp, {\state}\mapsto{\labelingfct(\state)}$.
\end{definition}

The grouping function is exactly the labeling function i.e. for all $\state \in \states$ it is $\gfctatomicprops(\state) := \labelingfct(\state)$. So it is $\gfctatomicprops(\state_1) = \gfctatomicprops(\state_2) \iff \labelingfct(\state_1) = \labelingfct(\state_2)$. According to Definition \ref{def:eqrelview} for $\smstate \in \states$ it is $\eqclassv[\smstate] = \{\state \in \states \mid \labelingfct(\state) = \labelingfct(\smstate)\}$.
%$\forall \state_1, \state_2 \in \states :

By this we obtain the \viewN $\viewatomicprops$ for a given \chgphN \chgph where: $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =  \bigcup_{a \in \atomicprops} \{\{\state \in \states \mid \labelingfct(\state) = a\}\}$. All other components are constructed as in Definition \ref{def:view}.

Although this view might seem rather simple because essentially it only performs $\gfctatomicprops := \labelingfct$ it is the most powerful one. This is because every view presented in the following is reducible to this one. That is because a \grpfctN essentially asserts an atomic proposition to every state, namely the value in respect to the considered property of a given view. The reduction can be realized by replacing the labeling function with the grouping function of the resepective view. That is $\labelingfct := \grpfct$ and $\atomicprops := \redcomment{\grpfct(\states)}$ for some \grpfctN \grpfct. While this works it alters the underlying \chgphN.

\subsubsection{Initial States}
An a little more involved idea than directly using a given function is to utilize the set of initial states. We can group states that have a probability greater zero, that they are started from. In practice this might be useful to quickly find all initial states.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\initstates := \{\state \in \states \mid \state \in \init\}$. The view \viewinitstates is defined by its \grpfctN with $\gfctinitstates : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \state \in \initstates \\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	and $\imggrp := \imggrpbinview$.
\end{definition}

For $\state_1,\state_2 \in \states$ it is $\gfctinitstates(\state_1) = \gfctinitstates(\state_2)$ \iffN $\state_1, \state_2 \in \initstates$ or $\state_1 = \state_2$. According to Definition \ref{def:eqrelview} it is 
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctinitstates(\state) = \group\} &\text{for } \state \in \initstates \text{ and} \\
	\eqclassv &= \{\state \in \states \mid \gfctinitstates(\state) = \{\state\} \} = \{\state\} &\text{for } \state \notin \initstates.
\end{align*}


By this we obtain the \viewN $\viewinitstates$ for a given \achgphN \chgph where: $\states' = \bigcup_{\state \in \states} \{\eqclassv\} = \{\state \in \states \mid \state \in \initstates\}\cup \bigcup_{\state \in \states \setminus \initstates}\{\{\state\}\}$.

All other components are constructed as in Definition \ref{def:view}.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/initStates/initStatesBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/initStates/initStatesAfter}
	\end{minipage}
	\caption{Simplified representation of \mdp (left) and the \viewN \viewinitstates on it(left)}
	\label{fig:initStatesExmp}  
\end{figure}


\subsubsection{Outgoing Actions}
Another crucial component of \achgphN is its set of actions \actions. Actions are used for interprocesscommunication und synchronization. In this subsection we will provide and dicuss some views utilizing actions on transitions that are outgonig from a state. 
%For simplicity we will write "outgoing action \action" short for "transition with outgoing action \action" analogously we will write "ingoing action \action" short for "transition with ingoing action \action". We
We will write a state \state has an outgoing action \action if there exists a state $\state'$ with $(\state, \action, \state') \in \trans$. For a state \state, ingoing action \action we say it has an ingoing action \action if there exist a state $\state'$ with $(\state', \action, \state) \in \trans$.

The most obvious variant to group states is to group states that \emph{have} a given outgoing action.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The view \viewhasoutaction is defined by its \grpfctN $\gfcthasoutaction : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \exists \state' \in \states: (\state, \action, \state') \in \trans \\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	and $\imggrp := \imggrpbinview$. %\actions \cup \remset$.	
\end{definition}


For $\state_1,\state_2 \in \states$ it is $\gfcthasoutaction(\state_1) = \gfcthasoutaction(\state_2)$ \iffN 
there exist $\state_{a},\state_{b} \in \states$ with 
$(\state_1, \action, \state_{a}), (\state_2, \action, \state_{b}) \in \trans$ (i.e. they have the same outgoing action \action) or $\state_1 = \state_2$. 
In accordance with Definition \ref{def:eqrelview} it is
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfcthasoutaction(\state) = \action\} &\exists\state' \in \states : (\state, \action, \state') \in \trans \\
	\eqclassv &= \{\state \in \states \mid \gfcthasoutaction(\state) = \state\} = \{s\} &\text{ otherwise}
\end{align*}
 %if for all $\state' \in \states : (\state,\action,\state') \notin \trans$.

Thereby we obtain the \viewN \viewhasoutaction for a given \chgphN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where
\begin{align*}
	 \states_1 &:= \{\state \in \states \mid \exists \state' \in \states: (\state, \action, \state') \in \trans\} = \{\state \in \states \mid \state \text{ has outgoing action \action }\} \\
	\states_2 &:= \remstates.
\end{align*}


Since actions are a very important part of \chgphsN as well as of its more powerful siblings MDPs and MCs it seems useful to further enhance this view and look at variants of it. Instead of only grouping states that only \emph{have} outgoing actions we could also quantify the amount of times that action should be outgoing.

For example we could require that a given action has to be outgoing a minimum amount of times. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The view \viewminoutaction is defined by its \grpfctN $\gfctminoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \exists \state_1, \dots, \state_\numoutact \in \states:  \predminoutact\\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$,
	%	\actions \cup \remset$
	 $\numoutact \in \natnums$ is the minimum amount of times a transition with action \action has to be outgoing in order to be grouped with the other states and
	\[
	\predminoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_\numoutact) \in \trans) \land |\{\state_1, \dots, \state_\numoutact\}| = \numoutact
	\]
	
	is a first order logic predicate.
	\label{def:minoutaction}
\end{definition}

The number  and  
The predicate \predminoutact requires that there are transitions with action \action to \numoutact distinct states.

For $\state_1,\state_2 \in \states$ it is $\gfctminoutaction(\state_1) = \gfctminoutaction(\state_2)$ \iffN there exist distinct $\state_{a_1}, \dots, \state_{a_\numoutact} \in \states$ and distinct $\state_{b_1}, \dots, \state_{b_\numoutact} \in \states$ so that $(\state_1, \action, \state_{a_1}), \dots, (\state_1, \action, \state_{a_\numoutact}) \in \trans$ and $(\state_2, \action, \state_{b_1}), \dots, (\state_2, \action, \state_{b_\numoutact}) \in \trans$ or $\state_1 = \state_2$. According to Definition \ref{def:eqrelview} it is 
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctminoutaction(\state) = \action\} &\text{if } \predminoutact \\ 
	\eqclassv &= \{\state \in \states \mid \gfctminoutaction(\state) = \state\} = \{\state\} &\text{ otherwise}
\end{align*}

By this we obtain the \viewN $\viewminoutaction$ for a given \chgphN \chgph where $\states' = \bigcup_{\state \in \states} \{\eqclassv\} =: \states_1 \cup \states_2$ where 

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact\} \\ %(\state, \action, \state_1), \dots, (\state, \action, \state_\numoutact) \in \trans, |\{\state_1, \dots, \state_\numoutact\}| = \numoutact\} \\ 
	&\hspace{1.15mm}= \{\state \in \states \mid \text{the action } \action \text{ is outgoing at least } \numoutact \text{ times} \} \text{ and} \\
	\states_2 &:= \remstates.	
\end{align*}

In a similar fashion we define view that groups states where at most a certain number of times a given action is outgoing. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The view \viewmaxoutaction is defined by its \grpfctN $\gfctmaxoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$,
%	$\numoutact \in \natnums$ 
	is the maximal number of times a transition with action \action may be outgoing and 
	\[
	\predmaxoutact := ((\state, \action, \state_1), \dots, (\state, \action, \state_{\numoutact+1}) \in \trans) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numoutact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
	\label{def:viewmaxoutaction}
\end{definition}

 It ensures that if there are one more than \numoutact outgoing transitions with an action \action at least two of the states where the transitions \redcomment{end} are in fact the same. Since this is required for all possible combinations of $\numoutact + 1$ states by the grouping function, only states that have at most \numoutact outgoing actions will be assigned with \action by the grouping function. The reasoning about the equality of the \grpfctN values, the obtained equivalence classes and the resulting set of states $\states'$ of the view is analogous to \viewminoutaction.

Since we already defined \grpfctsN and hence views for a required minimal and maximal amount of times an action has to be outgoing it is now easily possible to define a view that groups states where the amount of outgoing actions is at least \numoutact and at most \numoutactb. 

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The view 
	\viewspanoutaction is defined by its \grpfctN $\gfctspanoutaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact \\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$
%	\actions \cup \remset$ 
	and $\numoutactb, \numoutact \in \natnums$ are the minimal and maximal number of transitions with action \action in order for state to be grouped. The predicates \predminoutact and \predmaxoutact are the predicates from Definition \ref{def:minoutaction} and Definition \ref{def:viewmaxoutaction} respectively.
\end{definition}

We already know that for a given $\state \in \states$ the expressions $\exists \state_1, \dots, \state_\numoutact \in \states: \predminoutact$ and $\forall \state_1, \dots, \state_{\numoutactb+1} \in \states: \predmaxoutact[\numoutactb]$ from Definition \ref{def:minoutaction} and Definition \ref{def:viewmaxoutaction} require that \state has minimal and maximal amount of outgoing transitions with an action \action respectively. Hence the conjunction will be true for states where the amount of outgoing transitions with action \action is element of the set $\{\numoutactb, \numoutact+1, \dots, \numoutact-1, \numoutact\}$. We will write for this that the number of outgoing actions is \emph{in the span}.

For a given state \state and action \action we set
\[
\formoutact:= \exists \state_1, \dots, \state_\numoutactb \in \states: \predminoutact[\numoutactb]\land \\
\forall \state_1, \dots, \state_{\numoutact+1} \in \states: \predmaxoutact
\]

for convenience. \formoutact is true  \iffN the number of outgoing actions is in the span. For $\state_1, \state_2 \in \states$ it is $\gfctspanoutaction(\state_1) = \gfctspanoutaction(\state_2)$ \iffN $\formoutact[\state_1] \land \formoutact[\state_2]$ or $\state_1 = \state_2$. Then its equivalence classes are

\begin{align*}
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \action\} &\formoutact \text{ true} \\
	\eqclassv &= \{\state \in \states \mid \gfctspanoutaction(\state) = \state\} = \{\state\} &\text{ otherwise}	
\end{align*}

The new set of states $\states'$ of the view \viewspanoutaction is the union of the equivalence classes of equivalence relation \eqrelview on the set of states \states of the original \chgphN. Hence it is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \gfctspanoutaction(\state) = \action\} \\
	&\hspace{1.15mm}= \{\state \in \states  \mid \formoutact \text{ true}\} \\
	&\hspace{1.15mm}= \{\state \in \states \mid \text{the action } \action \text{ is outgoing } \numoutactb \text{ to } \numoutact \text{ times}\} \text{ and} \\
	\states_2 &:= \remstates.
\end{align*}

The \viewsN above can be combined with \parllcompN. The thereby obtained \viewN requires that the respective conditions of all the combined \viewsN are met. In this sense it is a conjunctive combination.

Instead of making requirements about states and group them based on whether they meet these requirements it also possible to group states that are very similar or even identical in regard to their outaction. We consider this idea with the \emph{\outactident \viewNC} in two variants: \outactidentstrong and \outactidentweak (idententiy). Firstly we will consider the variant of strong identity.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The \viewN \viewstrongoutactident is defined by its \grpfctN $\gfctstrongoutactident : \states \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numoutact) \mid \action \in \actions, \numoutact \text{ is the number of times that \action is outgoing from } \state\}
	\]
	and $\imggrp := \actions \times \natnums_0 \cup \remset$.
\end{definition}

The \grpfctN asserts to each state a set of pairs. Note that a pair is contained int the set for each action $\action \in \actions$. In case there is no outgoing transition from state \state with an action \action it is $(\action, 0) \in \gfctstrongoutactident$. For $\state_1, \state_2 \in \states$ it is $\gfctstrongoutactident(\state_1) = \gfctstrongoutactident(\state_2)$ \iffN $\state_1$ and $\state_2$ are mapped to the same set of pairs. By Definition \ref{def:eqrelview} the obtained equivalence classes of \eqrelview are
\[
	\eqclassv := \{\state \in \states \mid \gfctstrongoutactident(\state) = \{(\action_1, \numoutact_1), \dots, (\action_l, \numoutact_l)\}, l = |\actions|\}
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewstrongoutactident. All other components of \viewstrongoutactident are as usual structured in accordance with the Definition \ref{def:view}.
As mentioned earlier a \outactidentweak variant of the \outactident \viewN is also conceivable.

\begin{figure}[h]

	\input{./04/images/actions/outActIdentStrongBefore}

	\caption{Simplified representation of \mdp (left) and the \viewN \viewinitstates on it(left)}
	\label{fig:outActIdentStrongBefore}  
\end{figure}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The \viewN \viewweakoutactident is defined by its \grpfctN $\gfctweakoutactident : \states \to \imggrp$ with
	\[
	\state \mapsto \{\action \in \actions \mid \exists \state' \in \states : (\state, \action, \state') \in \trans\} 	
	\]
	and $\imggrp := \actions \cup \remset$.
\end{definition}
\redcomment{condition of image-set written in inconsistent style to strong identity. Swap strong and weak (order)?}

\redcomment{The grouping function maps to the set of outgoing actions of a state and thereby discards information about the number of times an actions is outgoing. If an action is not outgoing from a state it is not contained in the set.}

For $\state_1, \state_2 \in \states$ it is $\gfctweakoutactident(\state_1) = \gfctweakoutactident(\state_2)$ \iffN they are mapped to the same set of actions. Hence the equivalence classes of \eqrelview are
\[
	\eqclassv[\smstate] = \{ \state \in \states \mid \gfctweakoutactident(\state) = \gfctweakoutactident(\smstate) =: \{\action_1, \dots, \action_l\}, l \in \natnums\}.
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewweakoutactident.

Apart from the option of directly considering one or a set of outgoing actions with possible quantities it is also possible to only consider the quantity of outgoing actions without regarding the any specific action.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The \viewN \viewoutactsetsize is defined by its \grpfctN $\gfctoutactsetsize : \states \to \imggrp$ with
	\[
	\state \mapsto |\{\action \in \actions \mid \exists \state' \in \states : (\state, \action, \state') \in \trans\}|
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

The notion of the view is similar to utilize the outdegree, with the difference being here that ougoing transitions with the same action are considered as one single edge. This reflects on the options available for nondeterminism in this state.

The sepcialcase of there only being one single ougoing action is worth a distinct view, since it hides all nondeterministic choices, but nothing more.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The \viewN \viewoutactsingle is defined by its \grpfctN $\gfctoutactsingle : \states \to \imggrp$ with
	\[\state \mapsto 
	\begin{cases}
		\group, &\text{if } |\{\action \in \actions \mid \exists \state' \in \states : (\state, \action, \state') \in \trans\}| = 1 \\ 
		\remelem, &\text{otherwise}
	\end{cases}
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

\subsubsection{Ingoing Actions}
Analogously to Outgoing Actions views of utilizing ingoing actions are feasable. Since there is no difference apart from the definitions itself, we only provide the definitions.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The view \viewhasinaction is defined by its \grpfctN $\gfcthasinaction : \states \to \imggrp$ with 
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \exists \state' \in \states: (\state', \action, \state) \in \trans \\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	and $\imggrp := \imggrpbinview$.	
	\label{def:mininaction}
\end{definition}	


\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The view \viewmininaction is defined by its \grpfctN $\gfctmininaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \exists \state_1, \dots, \state_\numinact \in \states:  \predmininact\\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$,
%	 $\numinact \in \natnums$ 
	 is the minimum amount of times a transition with action \action has to be ingoing in order to be grouped with the other states and
	\[
	\predmininact := ((\state_1, \action, \state), \dots, (\state_\numinact, \action, \state) \in \trans) \land |\{\state_1, \dots, \state_\numinact\}| = \numinact
	\]
	is a first order logic predicate.
	\label{def:viewmaxinaction}
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The view \viewmaxinaction is defined by its \grpfctN $\gfctmaxinaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$
%	$\numinact \in \natnums$ 
	 is the maximal number of times a transition with action \action may be ingoing and 
	\[
	\predmaxinact := ((\state_1, \action, \state), \dots, (\state_{\numinact+1}, \action, \state) \in \trans) \implies \bigvee_{\mathclap{\substack{i,j \in \{1,\dots, \numinact+1\} \\ i < j}}} \state_i = \state_j
	\]
	is a first order logic predicate.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The view 
	\viewspaninaction is defined by its \grpfctN $\gfctspaninaction : \states \to \arbset$ with
	
	\[
	\state \mapsto
	\begin{cases}
			\group,				& \text{if } \exists \state_1, \dots, \state_\numinactb \in \states: \predmininact[\numinactb] \\ &\text{and } \forall \state_1, \dots, \state_{\numinact+1} \in \states: \predmaxinact \\
			\remelem,          	& \text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \imggrpbinview$
%	\actions \cup \remset$ 
	and $\numinactb, \numinact \in \natnums$ are the minimal and maximal number of transitions with action \action in order for state to be grouped. The predicates \predmininact and \predmaxinact are the predicates from Definition \ref{def:mininaction} and Definition \ref{def:viewmaxinaction} respectively.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The \viewN \viewstronginactident is defined by its \grpfctN $\gfctstronginactident : \states \to \imggrp$ with
	\[
	\state \mapsto	
	\{(\action, \numinact) \mid \action \in \actions, \numinact \text{ is the number of times that \action is ingoing from } \state\}
	\]
	and $\imggrp := (\actions \times \natnums_0) \cup \remset$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The \viewN \viewweakinactident is defined by its \grpfctN $\gfctweakinactident : \states \to \imggrp$ with
	\[
	\state \mapsto \{\action \in \actions \mid \exists \state' \in \states : (\state', \action, \state) \in \trans\} 	
	\]
	and $\imggrp := \actions\cup \remset$.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $\action \in \actions$. The \viewN \viewinactsetsize is defined by its \grpfctN $\gfctinactsetsize : \states \to \imggrp$ with
	\[
	\state \mapsto |\{\action \in \actions \mid \exists \state' \in \states : (\state', \action, \state) \in \trans\}|
	\]
	and $\imggrp := \natnums \cup \remset$.
\end{definition}

\subsubsection{Variables}
The concept of variables is not part of the definitions of neither \tsN, MCs or \mdpsN even though, it is of great importance in practice. We will introduce and discuss this concept before utilizing it for \viewsN.

Since states describe some information about a system at a certain moment of its behavior the information carried is usually not atomic but rather consists of several pieces. For instance when considering a computer program at a given moment during execution all its currently available variables will have some value, the stack will have a certain structure and the program counter points to a specific instruction. Systems in general at a certain moment of their behavior have several properties that in total pose the current state of the system. That is in practice each state is actually derived from a possible variable assertion. Choosing the respective variable assertion as state representation would result in rather complex state objects. Therefore the values of the variables are usually stored in a separate data structure and a simple identifier like an integer represents the actual state. When formalizing this in practice used approach several options com into consideration. Available \mdpN components like atomic propositions or the set of states could be used to contain this information. There could be a subset of atomic propositions that declares that a certain variable has a certain value. There had to be taken care that for each variable in each state there is only one atomic proposition declaring its value. The set of states could be used in the sense that the states itself are complex objects containing the information. Both of these options are rather tedious but possible. A third option is to define a set of variables and an evaluation function that are induced by the \mdpN.
%Firstly there is the option of declaring the states as complex objects that contain this information. This would be possible because the set of states is not further specified. Accessing this information stored within a state would be rather tedious because there is no already existing entity to properly accomplishing the access. Hence this option was not further explored. The second option is to require that all possible assertions of all variables are included in the atomic propositions. The labeling function would then assert exactly one atomic proposition for each variable for each state, that specifies what the current value of that variable is. Although this would be possible, for simplicity we chose that variables and its values are provided in addition to the \mdpN. Obviously they are to be understood as derived and therefore dependent on the  system, that the \mdpN has been derived from. By no means the set of variables and its evaluation are arbitrary.


%Variables are used to represent states (in more detail). 
%
%For example an \mdpN could be used to model a computer program with human interaction. Every state of the MDP refers an overall state of the program during execution time. In this state of the program, its variables will have specific values. We may want to retain the information about the variable's values of the program instead of only assigning a state $\state \in \states$ that refers to the state of the program. Variables and its current values are not only relevant to computer programs but also other systems. Many of those other systems rely on some kind of global state during execution, which can be expressed with variables and values assigned to them. Since there exists no explicit component to retain this information the notion of variables is used to store it.
%
%\redcomment{OLD: Since transitions systems MCs and MDPs in practice are used to model, analyze and check real world systems it is very practical to not only name states but also describe the properties of the state in more detail. For a basic notion variables are to be imagined as a set of variables that may have different values in different states thereby describing the characteristics of the state more thoroughly. \purpcomment{ADDED TO OLD: In practice most often they arise naturally for example as variables of a computer program that is to be modeled with an \mdpN.}} 
%
%Because of the vast importance in practical applications we will consider some \viewsN that utilize them. To do so and being able to describe them formally we define and formalize the notion of variables by considering them as a subset of the atomic propositions \atomicprops that is assigned a value by a function.

\begin{definition}
	Let $\mdp$ be an \mdpN. The set $\vars$ is called \emph{variables} (of \mdp). It contains all variables induced by \mdp.
\end{definition}

\begin{definition}
	Let $\mdp = \mdptuple$ be an \mdpN and \varevalimgset be an arbitrary set. The by im induced function $\vareval : \states \times \vars \to \varevalimgset$ is called \emph{variable evaluation function}.
\end{definition} 

Most of the time we will use \vareval to refer to the variable evaluation function. When we speak about the value of a variable in a state we refer to the image of $\vareval$ for that state and variable. The set \varevalimgset is arbitrary so that arbitrary values can be assigned to a variable. Speaking in terms of computer science and programming this loosens as an example the restriction of only being able to assign numbers and no booleans.

The most apparent idea for a \viewN utilizing variables is to group states that meet some requirement regarding the values of the variables.


\redcomment{state has variable not here uptil now because probably not used}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\var \in \vars$ and $\varval \in \varevalimg$. The view \viewparamvalueseq is defined by its \grpfctN $\gfctparamvalueseq : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
			\group, &\text{if } \vareval(\state, \var) = \varval\\
			\remelem, &\text{otherwise}
		\end{cases}
	\]
	where $\imggrp := \imggrpbinview$.
\end{definition}

The view \viewparamvalueseq groups states that share the same value for a given variable. For $\state_1, \state_2$ it is $\gfctparamvalueseq(\state_1) = \gfctparamvalueseq(\state_2)$ \iffN $\vareval(\state_1, \var) = \vareval(\state_2, \var)$ or $\state_1 = \state_2$. The obtained equivalence classes are
\begin{align*}
	\eqclassv &= \{\state \in \states \mid \vareval(\state, \var) = \varval\} \\
	\eqclassv &= \{\state \in \states \mid \gfctparamvalueseq(\state) = \state\} = \{\state\}
\end{align*}

The set of states $\states'$ of \viewparamvalueseq is the union of the equivalence classes of \eqrelview. It is $\states' = \bigcup_{\state \in \states} \eqclassv =: \states_1 \cup \states_2$ where

\begin{align*}
	\states_1 &:= \{\state \in \states \mid \gfctparamvalueseq(\state) = \varval\} \\
	&\hspace{1.15mm}= \{\state \in \states  \mid \vareval(\state, \var) = \varval\} \text{ and} \\
	\states_2 &:= \remstates.
\end{align*}

Analogously a view that requires inequality instead of equality is feasible.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\var \in \vars$ and $\varval \in \varevalimg$. The view \viewparamvaluesneq is defined by its \grpfctN $\gfctparamvaluesneq : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
			\group, &\text{if } \vareval(\state, \var) \neq \varval\\
			\remelem, 	&\text{otherwise}
		\end{cases}
	\]
	where $\imggrp := \imggrpbinview$.
\end{definition}

If states are to be grouped with the requirement of several variables equaling or not equaling specified values this can be achieved by using \parllcompN. 

To allow even more flexibility a view can be used that also allows a combination of requirements on variables in a disjunctive manner. To extend this idea to its full potential we will define a \viewN that allows requirements using a disjunctive normal formal (DNF). To formalize this view more efficiently we will write $\varstate[,i]$ short for $\vareval(\state, \var_i)$ where $x_i \in \vars$ and $i \in \natnums$. We define the symbol \eqorneq to be an element of the set $\{=,\neq\}$. That is to say, whenever it is used each time written it is a representative for either the symbol $=$ or $\neq$. It allows to write one symbol whenever $=$ and $\neq$ could or should be possible. Moreover for this context we consider $(\varstate[,i] = \varval)$ as a literal and $(\varstate[,i] \neq \varval)$ as its negation. We write $(\varstate[,i] \eqorneq \varval)$ for a literal that could be negated or not negated.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\var \in \vars$, $\varval \in \varevalimg$ and
	\[
	d(s) = ((\varstate[,11] \eqorneq \varval_{11}) \land \dots \land (\varstate[,1l_1] \eqorneq \varval_{1l_1})) \lor \dots \lor ((\varstate[,k1] \eqorneq \varval_{k1}) \land \dots \land (\varstate[,kl_k]  \eqorneq \varval_{kl_k}))
	\]
	proposition logical formulae in disjunctive normal form where $\varstate[,{ij}], a_{ij} \in \varevalimg$ 		
	The \viewN \viewparamdnf is defined by its \grpfctN $\gfctparamdnf : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
			\group, &\text{if } d(s) \text{ is true}\\
			\remelem, 	&\text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \{\group, \remelem\}$.
\end{definition}


The DNF allows us to specify a requirement in disjunctive normal form about variables. States are mapped to the same value depending on whether or not they meet this requirement.

\redcomment{DISCUSSION OF EQUALITY, EQ CLASSES AND RESULTING STATES MISSING}

Analogously a view based on a conjunctive normal formal can be defined that may be more convenient, depending on the query.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and 
	\begin{align*}
		c(s) = &((\varstate[,i_1] \eqorneq \varval_{i_1}) \lor \dots \lor (\varstate[,i_{l_1}] \eqorneq \varval_{i_{l_1}})) \; \land \\
		&((\varstate[,i_{l_1+1}] \eqorneq \varval_{i_{l_1+1}}) \lor \dots \lor (\varstate[,i_{l_2}] \eqorneq \varval_{i_{l_2}})) \; \land  \\
		&\dots \\ 
		&((\varstate[,i_{(l_{m-1})+1}] \eqorneq \varval_{i_{(l_{m-1})+1}}) \lor \dots \lor (\varstate[,i_{l_m}]  \eqorneq \varval_{i_{l_m}}))
	\end{align*}
	
	proposition logical formula in disjunctive normal form where
	\begin{itemize}
			\item $\varstate[,i_k], a_{i_k} \in \varevalimg$ with $i_k\in \natnums$ and $k \in \{1, \dots, l_m\}$
			\item $l_1 < l_2 < \dots < l_m$ and $m$ is the number of clauses in $c(s)$
		\end{itemize}
	The \viewN \viewparamcnf is defined by its \grpfctN $\gfctparamcnf : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
			\group, &\text{if } c(s) \text{ is true}\\
			\remelem, 	&\text{otherwise}
		\end{cases}
	\]
	
	where $\imggrp := \{\group, \remelem\}$.
\end{definition}

The only difference from the \viewN \viewparamcnf to the \viewN \viewparamdnf is whether the respective formulae is in conjunctive or disjunctive normal form.\redcomment{CITATION} Since each formulae in conjunctive normal form can tan be transformed to a formulae in disjunctive normal form and vice verse neither on of the \viewsN can perform an action the other can not. Hence there is no difference in expressivity, but there may be one in size. Therefore both views have been implemented and formalized. 

The views discussed before reduce the \chgphN in a very precise but also manual manner, because it not only dictates the variable but also its value. A more general approach is to stipulate only the variable but not its value. This way states will be grouped that have the same value for that variable with no regard to the actual value of that variable. This idea could be achieved with a view based on the \grpfctN $\grpfct[\varval_1 ]$%\pll \dots \pll \gfctparamvalueseqopt[\varval_n]]$ with $\redcomment{\vareval(\states, \var)} = \{\varval_1, \dots, \varval_n\}$ and $|\vareval(\states,\var)| = n$. This grouping function just groups on every possible value for the variable \var. Since this is \redcomment{not very practical} we define a view that achieves this result in a more direct and more efficient way.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The view \viewparamvalident is defined by its \grpfctN $\gfctparamvalident : \states \to \imggrp$ with
	\[
	\state \mapsto \vareval(\state,\var)
	\]
	and $\imggrp := \vareval(\states, \var)$.
\end{definition}

With this grouping function we directly map to the value of the variable. Hence for $\state_1, \state_2 \in \states$ it is $\gfctparamvalident(\state_1) = \gfctparamvalident(\state_2)$ \iffN they are mapped to the value $\varval \in \imggrp$. Hence the equivalence classes of \eqrelview are
\[
\eqclassv[\smstate] = \{ \state \in \states \mid \vareval(\state) = \vareval(\smstate)\}.
\]
According to Definition \ref{def:view} the set $\states' := \bigcup_{\state \in \states} \eqclassv$ is the set of states of \viewparamvalident.


\subsection{Utilizing the MDP Graphstructure}
\subsubsection{Distance}
Considering distances in a graph can be very helpful to get an overview of a graph. Likewise it helps a lot with understanding the structure of \achgphN. In order to consider the distance between nodes we will need to formalize it.

\redcomment{definition is very simlar to execution fragments! Citation?}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A (simple and finite) \emph{path} \path is a sequence \pathsecfull alternating between states and actions where $n \in \natnums, \{\state_1, \dots, \state_{n}\} \subseteq \states$ is a set of distinct states,  $\{\action_1, \dots, \action_{n}\} \subseteq \actions$ and for all $i \in \{1, \dots, n\}$ it is $(\state_i,\action_i, \state_{i+1}) \in \trans$. 
	
	\noindent
	It is $\pfirst(\path) := \state_0$ and $\plast(\path) := \state_n$ and \pathset the set of all paths in \chgph.
\end{definition}

\begin{definition}
	\sloppy
	Let $\chgph = \chgphtuple$ be \achgphN and \path = \pathsecfull be a path in \chgph. The number $n =: \lenpath(\path)$ is called \emph{length} of the path \path.
\end{definition}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The \emph{distance} from $\smstates \subseteq \states$ to $\state \in \states$ is the length of the shortest path from a state $\smstate \in \smstates$ to \state. That is $dist(\chgph, \smstates, \state) := \text{min}\{\lenpath(\path) \mid \path \in \pathset, \; \pfirst(\path) \in \smstates, \; \plast(\path) \in \state\}$.
\end{definition}

For a \viewN that applies to the whole and utilizes distance it only makes sense to consider a given set of states from which one the distance is measured. An intuitive choice for such set is the set of initial states. The following algorithm calculates the distance of each node from a given set $\smstates \subseteq \states$ considering granularity \grandist:

\redcomment{Implementation Algorithm}

The set \fctdistdefault declares the returned set of \redcomment{ALGORITHM}. The implementation ensures that for every state $\state$ there exists a pair $(\state, \distval)$ in \fctdistdefault. The following view groups states that have the same distance to the set measured with the amounts of transitions necessary to reach the the closest \smstates considering the granularity \grandist.

\begin{definition}
		Let $\chgph = \chgphtuple$ be \achgphN and $\smstates \subseteq \states$ arbitrary. \redcomment{$\fctdistdefault$ IMPLEMENTATION IN PSEUDOCODE? DEFINITION BEFORE?} The \viewN \viewdistance is defined by its \grpfctN $\gfctdistance : \states \to \imggrp$ with 
		\[
		\state \mapsto \distval \quad \quad \text{where } (\state, \distval) \in \fctdistdefault
		\]
		and $M = \natnums \cup \{\inf\} \cup \remset$.
\end{definition}

\redcomment{Variants of ALGORITHM which allow directinoless or only reverse traversal of the \mdpN are provided in the appendix. The respective views would utilize their returned set in the exact same way. That is, \fctdistdefault is replaced with the set of the respective algorithm and nothing else changes.}



\subsubsection{Double Directed Edges with same Action}
\redcomment{NOT SURE IF SHOULD BE INCLUDED}
\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN.
\end{definition}

\subsubsection{Cycles}
A cycle is a structure that can exist in every graph. The concept of cycles is not specific to \chgphsN or any of its more specialized variants. The purpose of this thesis is to discuss views that utilize domain specific knowledge or if a general concept is of special relevance when exploring \achgphN. The former and the latter apply on cycles.

Formalizing \viewsN based on cycles requires some formalization of the concept cycle. We will use a domain specific definition that will serve us the most.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A (simple) \emph{cycle} \cycle in \chgph is a sequence \cyclesecfull alternating between states and actions where $n \in \natnums, \{\state_0, \dots, \state_{n-1}\} \subseteq \states$ is a set of distinct states,  $\{\action_0, \dots, \action_{n-1}\} \subseteq \actions$ and for all $i \in \{0, \dots, n-1\}$ it is $(\state_i,\action_i, \state_{i+1 \text{ mod }n}) \in \trans$.
\end{definition}

When the actions in the cycle are of no further importance, we will omit them only writing a sequence of states. In the following let $\cycle = \cyclesecfull$ be a cycle. For conveniences we will write $\state \in \cycle$ if the state is contained in the cycle \cycle and $\action \in \cycle$ if the action is contained in in the cycle \cycle. \redcomment{only if??} In words we will both write a state or action is \emph{on} or \emph{in} the cycle. Let $\cycle_1$ and $\cycle_2$ be cycles. $\cycle_1 \cup \cycle_2 := \{\state \in \states \mid \state \in \cycle_1 \text{ or } \state \in \cycle_2\}$.

\begin{definition}
	Let \cycle be an cycle in \chgph and \states be the states set of \chgph. The number $|\{\state \in \states \mid \state \in \cycle\}| =: \lencycle(\cycle)$ is called the \emph{length} of a cycle. 
\end{definition}

\begin{definition}
	Let $\chgph$ be an \chgphN. The set $\cycleset := \{ \cycle \mid \lencycle(\cycle) \geq n\}$ declares the set of all cycles in \chgph with a length of at least $n$.
\end{definition}

In practice there exist several cycle finding algorithms. The function $\fctfindcycles(\chgph, n)$ is an abstraction for one of these algorithms being used. The actual implementation relys on algorithms of the jave library \jgrapht namely the \redcomment{Algorithm Szwarcfiter and Lauer - $O(V+EC)$ and Tiernan - $O(V.constV)$ CITATION!!}

With the formalization done we will introduce some views utilizing the concept cycles. For one we will combine the notion cycle with domain specific knowledge for the other we will consider how and why cycles in MDPs are in general of relevance. We will begin with the latter.  Cycles in general are of interest because they pose the risk of getting stuck in endless loops, when performing actions on the \mdpN. \redcomment{Model checking is one of the most relevant actions on \chgphsN that are vulnerable to loops. They are performed commonly on them.} Therefore a \viewN that simply finds existing cycles is feasible.


\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $n \in \natnums$. The \viewN \viewhascycle is defined by its \grpfctN $\gfcthascycle : \states \to \imggrp$ with
	\[
	\state \mapsto
	\begin{cases}
			\group, &\text{if } \cycleset \neq \emptyset \\
			\remelem, &\text{otherwise}
		\end{cases}
	\]
	
	and $\imggrp = \{\group, \remelem\}$.
\end{definition}

This \viewN groups all states that are contained in cycle with a length of at least $n$. It is to note that the affinity of a state to one or several respective cycles is lost.

\redcomment{DISCUSSION OF EQUALITY, EQ CLASSES AND RESULTING STATES MISSING}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $n \in \natnums$. The \viewN \viewexactcycle is defined by its \grpfctN $\gfctexactcycle : \states \to \imggrp$ with
	\[
	\state \mapsto \{\cycle \in \cycleset \mid \state \in \cycle\}
	\]
	
	and $\imggrp = \powerset{\cycleset}\cup \remset.$
	\label{def:exactcycleview}
\end{definition}

This \viewN groups states that have the same set of cycles they are contained in. Thus if $C_1$ and $C_2$ are distinct cycles and $\state_1, \state_2 \in \cycle_1$ and $\state_1 \in \cycle_2$ but $\state_2 \notin \cycle_2$ they are not grouped. It suffices that a state is on one cycle that the other one is not on, in order for the states not being grouped. In graphs with many cycles this can lead to little grouping.


\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/cycles/cyclesBefore}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
%		\input{./04/images/cycles/initStatesAfter}
	\end{minipage}
	\caption{Simplified representation of \mdp (left) and the \viewN \viewinitstates on it(left)}
	\label{fig:cyclesBefore}  
\end{figure}



\redcomment{DISCUSSION OF EQUALITY, EQ CLASSES AND RESULTING STATES MISSING}

\redcomment{GREEDY APPROACHES (STATE ON SINGLE CYCLE), AND SET APPROACH s $\to$ $C_1 \cup C_2$ omitted because not sure if needed}

The view above might be useful when having found cycles to see what cycles specifically exist. Often it is interesting to find cycles that consist only of transitions of the same action. The following view accomplishes that.

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\hspace{5mm}
		\input{./04/images/cycles/cyclesAfterHas}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		%		\input{./04/images/cycles/initStatesAfter}
	\end{minipage}
	\caption{Simplified representation of \mdp (left) and the \viewN \viewinitstates on it(left)}
	\label{fig:cycleAfterHas}  
\end{figure}

\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
%		\hspace{5mm}
		\input{./04/images/cycles/cyclesAfterExact0}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\input{./04/images/cycles/cyclesAfterExact5}
	\end{minipage}
	\caption{\viewNC \viewexactactcycle[0] (left) and \viewN \viewexactactcycle[5] the right}
	\label{fig:cycleAfterExtact0}  
\end{figure}



\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $n \in \natnums$. The \viewN \viewexactactcycle is defined by its \grpfctN $\gfctexactactcycle : \states \to \imggrp$ with
	\[
	\state \mapsto \{\cycle \in \cycleset \mid \state \in \cycle, \tilde{\action} \in \cycle, \forall \action \in \cycle : \action = \tilde{\action} \}
	\]
	
	and $\imggrp = \powerset{\cycleset} \cup \remset.$
\end{definition}

The view specializes the view from Definition \ref{def:exactcycleview} in the sense that it additionally requires for all $\cycle \in \gfctexactcycle$ that all actions occurring in the cycle are the same. \redcomment{doubling to above definition?}

\redcomment{NO DISCUSSION IF PREVIOUSLY}

In definition \ref{def:exactcycleview} we stated that little grouping can occur when mapping on the set of cycles in all of which the state is contained. Hence we provide the definition and implemenation of a view that groups states even though their set of cycles is not equal, but there is sufficient similarity in the cycles they are on.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN and $n \in \natnums$. The \viewN \viewcycleset is defined by its \grpfctN $\gfctcycleset : \states \to \imggrp$ with
	\[
	\state \mapsto \{\smstate \in \states \mid \state, \smstate \in \cycle \in \cycleset\}
	\]
	and $\imggrp = \states \cup \remset.$
\end{definition}

Each state is mapped to the set of states resulting from joing the state sets of all the cycles the state is on. 

\subsubsection{Strongly Connected Components}
Strongly connect components (\sccN) are of major importance in model checking \redcomment{I think so because I found the terms many times in the book. Remaining question: really? why?}
Therefore it is feasible to consider a view utilizing strongly connected components. Deviating from most definitions we will define \sccN not as a subgraph but only as the set of its nodes. Moreover the definition is written in the terms of \achgphN.

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. A set of the from
	\[
		\scc = \{\state \in \states \mid  \forall \state' \in \scc : (\exists \path \in \pathset \text{ with } \pfirst(\path) = \state, \; \plast(\path) = \state') \text{ or } \state = \state'\}
	\]
	
%	\begin{align*}
%			\scc = \{\state_1 \in \states \mid & \; \forall \state' \in \scc : \exists n \in \natnums, \exists \; \! (\state_1, \action_1, \state_2, \action_2 \dots, \state_n, \action_n, \state') \\
%			&\text{ where } (\state_n, \action_n, \state') \in \trans \land \forall i \in \{1, \dots, n-1\} : (\state_i, \action_i, \state_{i+1}) \in \trans \}
%	\end{align*}
	is called \emph{strongly connected component} of \chgph. That is for every state in the set there has to exist a sequence of transitions to every other state of the set. The state itself is always considered a reachable by itself, i.e. there does not need to exist a self loop. In consequence, each state is contained in stronlgy connected component namely at least in the one that only contains itself. The set of strongly connected components of \chgph is denoted with \setscc.
\end{definition}

Since the strong connection is an equivalence relation the \sccsN are equivalence classes and hence disjoint. To find \sccsN Tarjans algorithm is the classic. In the implementation an improved variant from Gabow is used supplied by the \jgrapht library. \redcomment{CITATION}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The \viewN \viewscc is defined by its \grpfctN $\gfctscc : \states \to \imggrp$ with
	\[
	\state \mapsto \scc \quad \quad \text{ where } \state \in \scc \in \setscc
	\]
	and $\imggrp = \setscc \cup \remset$.
\end{definition}

This view groups all states together that are in the same \sccN. Because \sccsN are disjoint each \state will be mapped to its one and only \sccN. This is because... \redcomment{DISCUSSION OF EQUALITY, EQ CLASSES AND RESULTING STATES MISSING}

A special kind of strongly connected components is the the bottom strongly connected component.

\begin{definition}
	Let \scc be a \sccN. A \emph{bottom strongly connected component} (\bsccN) is a \sccN where it holds that: \redcomment{concurrent versions}
	\[
	\forall \state \in \scc : \forall (\state, \action, \state') \in \trans : \state' \in \scc
	\]
	\[
	\forall \state \in \scc : \bigsum{t \in \scc} \trans(\state, t) = 1
	\]
	That is from \scc there is no state reachable outside of \scc. The set of bottom strongly connected components of \chgph is denoted with \setbscc.
\end{definition}

\redcomment{These are of special relevance because..}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN. The \viewN \viewbscc is defined by its \grpfctN $\gfctbscc : \states \to \imggrp$ with
	\[
	\state \mapsto \scc \quad \quad \text{ where } \state \in \scc \in \setbscc
	\]
	and $\imggrp = \setbscc \cup \remset$.
\end{definition}

In the implementation strongly connected components are determined using the algorithm of Gabow, afterwards filtering those \sccsN that have only transitions to states within the \sccN. Equality, equivalence classes and the new state set are constructed analogously to the view \viewscc.

\subsection{Utilizing the MDP Result Table}
In this section we will discuss \viewsN utilizing the result table. The actual implementation is relies on one powerful \viewN that can set to perform arbitrary actions using model checking results.

\redcomment{needhelp Understanding Cluster}

	
\end{document} 
