\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}

\begin{document}
\section{Comparison and Evaluation} \label{ch:eval}
In this chapter we want to show how \viewsN can be utilized in three different usecases. In subsection 6.4 we will consider take consider performance aspects.


\subsection{Explore Modules} \label{subsec:evalmodules}
\newcommand{\phil}[1]{\texttt{p#1}}


One Purpose of \viewsN is to simplify \mdpsN to make them better understandable. Due to the state explosion problem already rather simple systems can become very hard to oversee. As an example consider the concurrency problem Dining Philosophers, where n philosophers have to share n-1 forks and each of them needs two to eat. They are sitting on a round table with forks between them. Each of them only has access to fork to their left and right, if it is not already occupied. When representing the problem with an \mdpN the choice of which fork the philosopher tries to pick is made at random with an uniform distribution. The respective prism File is shown in \redcomment{add Screenshot appendix}.

Already for only three philosophers the \mdpN has 956 states. When looking at the graphical representation from \pmcvis Figure \ref{fig:0601Pure} it appears to be little helpful for understanding and exploring the graph due to its sheer size. Although the graph is large, this \mdpN is still rather small. With already five philosophers the MDP has about 100 000 states and with 10 philosophers the resulting MDP has more than 8 billion states. The \viewN \viewparamvalident can help to only show the behavior of some Philosophers and hiding the behavior of the remaining ones. 

\begin{figure}
	\includegraphics[width=\textwidth]{./06/images/06_01_pure_zoomhalf.png}
	\caption{Screenshot in current version of \pmcvis of approximately half the \mdpN \mdp}
	\label{fig:0601Pure}
\end{figure}

The \viewN $\viewparamvalident(\phil{1})$ groups all states that have the same value of (\phil{1}) ignoring the values of the remaining variables. That is, the values of \phil{2} and \phil{3} are hidden, which results in only showing the module of philosopher \phil{1} (Figure \ref{fig:0601var}). This may help immensely if only a specific module is of interest or the reaming modules have the same structure, as it is the case here with Dining Philosophers. After applying further views could be \viewparamvalident(\phil{1}) applied to understand or explore the module.
%For example if in Dining Philosophers we were interested in the part of the module where \phil{1} picks their first fork we could use the \viewN \viewparamdnf with c(s) = \redcomment{missing}({Figure}).

\begin{figure}
	\includegraphics[width=\textwidth]{./06/images/06_01_var.png}
	\caption{Screenshot in current version of \pmcvis of \viewN $\viewparamvalident(\phil{1})$}
	\label{fig:0601var}
\end{figure}

It is also possible to use the view \viewparamvalident to see the interleaved behavior of two or more modules. To see the interleaved behavior of \phil{1} and \phil{2}, we use parallel composition $\viewparamvalident(\phil{1}) \pll \viewparamvalident(\phil{2})$. This results in states $\state_1, \state_2$ being grouped where $(\gfctparamvalident (\state_1 \cond \phil{1}), \gfctparamvalident(\state_1 \cond \phil{2})) = (\gfctparamvalident(\state_2 \cond \phil{1}), \gfctparamvalident(\state_2 \cond \phil{2}))$. Hence only the value of \phil{3} is hidden which results exactly in the desired \redcomment{interleaved model} (Figure \ref{fig:0601var+var}).

\begin{figure}
	\includegraphics[width=\textwidth]{./06/images/06_01_var+var.png}
	\caption{Screenshot in current version of \pmcvis of \viewN $\viewparamvalident(\phil{1}) \pll \viewparamvalident(\phil{2})$}
	\label{fig:0601var+var}
\end{figure}

In general the views \viewparamdnf and \viewparamcnf are very powerful since they allow arbitrary operations on parameters.

%\begin{itemize}
%	\item USE: dinging Philosopher
%	\item consider dining Philosophers with
%	\item current graphical Representation looks as follows
%	\item only has about 1000 states in case studies prism mdp with about ... states
%	\item in general seems simple
%	\item parameters cluster: allows looking at just one module
%	\item also interleaving of arbitrary modules
%	\item
%	\item hasAction or OutAction-Ident for specific MDP-that run through configuration phases
%	
%\end{itemize}

\subsection{Find out why illegal states is reached}
\newcommand{\critstate}{\mt{\varstyle{2}{2}}}

In this section we want to show how views can be used for debugging. In this specific case we assume that we observed unwanted behavior or model checking results. We know that some states - that is some assignment of variables - are not allowed. We will check if these states are in fact not reachable.

We will consider the following small \mdpN the represents two systems that intend to send information via a unshareable medium. With a probability of $0.8$ a system can establish a connection and with probability of $0.2$ establishing a connection will fail. After an established connection access to the medium shall only be granted, if it is not occupied by the other system. If the medium is not occupied the system starts sending, otherwise it waits until the medium is free. The termination of the transmission is modeled with probabilities. There is 50 percent chance of terminating the transmission and a 50 percent chances of continuing. The number 0 represents that a system is trying to establish a connection, the number 1 represents that a system established the connection, the number 2 represents that the system is sending.

The state \critstate should not be reachable, since it represents the situation of the two systems occupying the unshareable medium at the same time. We will check if this state in fact is not reachable by using the $\view[\pptyparamcnf](c(\state))$ where $c(\state) := (x=2) \land (y=2)$ (Figure \ref{fig:0602Var}). Note that we are not using any disregarding \viewN.

\begin{figure}
	\includegraphics[width=\textwidth]{./06/images/06_02_Var.png}
	\caption{Screenshot in current version of \pmcvis of \viewN $\view[\pptyparamcnf](c(\state))$}
	\label{fig:0602Var}
\end{figure}

We observe, that this state is reachable, because it is shown and only reachable states are shown at all in \pmcvis. The questions occurs how and why. In order to obtain this information it should be investigated by which state this critical state \critstate has been reached. One way of accomplishing that is to look into the database that stores states and transitions (Figure \ref{fig:0602database})

\begin{figure}
	\includegraphics[width=\textwidth]{./06/prism/database-tpme.png}
	\caption{Transitions table form database}
	\label{fig:0602database}
\end{figure}

An even better approach is to look in the model file (Figure \ref{lst:0602prismbefore})

%\begin{figure}
%	\includegraphics[width=\textwidth]{./06/prism/prism-tpme-before.png}
%	\caption{Prism file}
%	\label{fig:0602prismbefore}
%\end{figure}

\begin{figure}
	\begin{lstlisting}[language=prism, caption={PRISM model file, where modules define the two systems mentioned in the text},label={lst:0602prismbefore}]
		mdp
		
		module M1
		x : [0..2] init 0;
		
		[] x=0 -> 0.8:(x'=0) + 0.2:(x'=1);
		[] x=1 & y!=2 -> (x'=2);
		[] x=2 -> 0.5:(x'=2) + 0.5:(x'=0);
		endmodule
		
		module M2
		y : [0..2] init 0;
		
		[] y=0 -> 0.8:(y'=0) + 0.2:(y'=1);
		[] y=1 & x!=2 -> (y'=2);
		[] y=1 -> 0.5:(y'=2) + 0.5:(y'=0);
		endmodule		
	\end{lstlisting}
\end{figure}

Persons with experience in working with prism models, might quickly spot the issue, especially because this is a rather small \mdpN. With less experienced people and especially with larger and more complicated models, finding an issue becomes much more difficult. Hence, let us see how views can help us.

Firstly we will use the view \viewdistance from that state on (Figure \ref{fig:0602Var+Dist} (left)). Because in the current version of the project expansion of grouped states to the ones they contain on a visual level, has not been implemented yet, we will use a custom \viewN that emulates this feature.

%\begin{figure}
%	\begin{minipage}{.5\textwidth}
%%	\begin{subfigure}
%	\centering \includegraphics[width=.95\linewidth]{./06/images/06_02_Var+Dist.png}
%	\label{fig:0602Var+Dist}
%%	\caption{Screenshot in current version of \pmcvis of \viewN $\view[\pptyparamcnf](c(\state)) \pll \viewdistance$}
%%\end{subfigure}
%\end{minipage}
%\begin{minipage}{.5\textwidth}
%%	\begin{subfigure}
%	\hspace{10mm}
%	\centering \includegraphics[width=\linewidth]{./06/images/06_02_Var+Dist+Id.png}
%	\label{fig:0602Var+Dist+Id}
%%	\caption{Screenshot in current version of \pmcvis of \viewN $\viewNC \view[\pptyparamcnf](c(\state)) \pll \viewdistance \pll \viewident$}
%%\end{subfigure}

	
%\end{minipage}
%\label{fig:0602VarDistIdDouble}
%%\caption{Screenshot in current version of \pmcvis of \viewN $\view[\pptyparamcnf](c(\state)) \pll \viewdistance$ on the left and \viewN $\view[\pptyparamcnf](c(\state)) \pll \viewdistance \pll \viewident$}
%\end{figure}

\begin{figure}
	\includegraphics[width=\textwidth]{./06/images/06_02_Var+Dist.png}
	\caption{Screenshot in current version of \pmcvis of \viewN $\view[\pptyparamcnf](c(\state)) \pll \viewdistance$}
	\label{fig:0602Var+Dist}
\end{figure}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewident is defined by its \grpfctN \gfctident where $\gfctsubident : \smstates \to \imggrp$ with
	\[
	\gfctsubident(\state) = \state
	\]
	and $\imggrp = \states \cup \remset$.
\end{definition}

\sloppy
We will use partial application with $ \view[\pptyparamcnf](c(\state)) \compselect \viewident$ where $\compselectset = \{(\gfctdistance,1)\}$ to expand that state. The MDP-Graph then looks as in \ref{fig:0602Var+Dist+Id}. It is to see that the state only contains a single state namely with the id seven. In the current version of implementation it is not possible, to obtain the parameter values. With the database file we obtain that this is the state where $x=2$ and $y=1$. Because $x=2$ represents the system 1 one sending and system 2 waiting, we see that is possible for the second system to begin to send on the medium although it is already occupied by the first system!

\begin{figure}
	\centering \includegraphics[width=\textwidth]{./06/images/06_02_Var+Dist+Id.png}
	\caption{Screenshot in current version of \pmcvis of \viewN $\viewNC \view[\pptyparamcnf](c(\state)) \pll \viewdistance \compselect \viewident$ where $\compselectset = \{(\gfctdistance,1)\}$}
	\label{fig:0602Var+Dist+Id}
\end{figure}

When now looking at the prism file (Figure \ref{fig:0602prismbefore}) we can see why this is the case. In last line of the second module when $y=1$ there is a 50 percent chance to enter $y=2$. This line originally was intended for termination of the transmission. From $y=1$ it should not be possible to enter $y=2$ if $x=2$. After fixing this, the state no longer appears after the application of $\viewparamdnf(c(\state))$.

	
%\begin{itemize}
%	\item USE: two process switch 
%	\item illegal state has been reached?
%	\item given state 2,2 should not be reachable
%	\item is reachable
%	\item is only!
%	\item apply distance cluster
%	\item emulate not yet feature of expansion
%	\item use identityView (with Parameters)
%	\item see in Database
%	\item fix in File
%\end{itemize}


%\subsection{Find out how why we reach a certain state}
%%	\item two dies
%%	\item property cluster

\subsection{Understand and Debug \chgphN}

In this subsection we want to take a look at a more complex usecase how views might help us to understand and fix a given \mdpN. We refer to the \mdpN \redcomment{appendix}.

%\begin{figure}[!htb]
%	\centering \includegraphics[width=\textwidth, height=20cm,
%	keepaspectratio]{./06/prism/scc-loops.png}
%	\caption{Given MDP}
%	\label{fig:0603sccloopsbefore}
%\end{figure}


\begin{figure}
	\begin{lstlisting}[language=prism, caption={PRISM model file},label={lst:0603sccloopsbefore}]
mdp

const int c_max_time = 5;

label "end" = (time = c_max_time);

module reconfiguration
activity: [0..1] init 0;
config1: [0..4] init 0;
config2: [0..4] init 0;

[reconfigure] (activity=0) -> (activity'=1);

[configure1] (activity=1) -> (config1'=0);
[configure1] (activity=1) -> (config1'=1);
[configure1] (activity=1) -> (config1'=2);
[configure1] (activity=1) -> (config1'=3);
[configure1] (activity=1) -> (config1'=4);

[configure2] (activity=1) -> (config2'=0);
[configure2] (activity=1) -> (config2'=1);
[configure2] (activity=1) -> (config2'=2);
[configure2] (activity=1) -> (config2'=3);
[configure2] (activity=1) -> (config2'=4);

[end_reconfigure] (activity=1) -> (activity'=0);
endmodule

module phases
phases: [0..2] init 0;

[reconfigure] (phases=0) -> (phases'=1);
[end_reconfigure] (phases=1) -> (phases'=2);
[working] (phases=2) -> (phases'=0);

endmodule

module timer
time: [0..c_max_time] init 0;

[working] (time < c_max_time) -> (time'=time+1);
[reconfigure] (time < c_max_time) -> true;

[end] (time=c_max_time) -> true;
endmodule

rewards "Utility"
[working] true : config1*3 + config2*2;
endrewards	
\end{lstlisting}

\end{figure}
Firstly, we will gather some understanding of the model. We already saw in chapter ch that variables can help a lot with understanding an \chgphN. When applying $\viewparamvalident(\texttt{time})$ we see that the \chgphN has a limited timed behavior (Figure \ref{fig:0603timeandphases} left). When applying $\viewparamvalident(\texttt{phases})$ we observe that the system is operating in phases (Figure \ref{fig:0603timeandphases} right). If we consider $\viewparamvalident(\texttt{time}) \pll \viewparamvalident(\texttt{phases})$ we see that the phases are repeated for each iteration of time (Figure \ref{fig:0603time+phases} right). However, we still don not have any information about the behavior of the system in these phases. Since this model has actions we will consider the \viewN \viewweakoutactident (Figure \ref{fig:0603act}). We obtain that we have sets of states which only have transitions with the action \texttt{[reconfigure]} outgoing, the action \texttt{[working]} outgoing, the actions \texttt{[configure1]} outgoing, \texttt{[configure2]}, \texttt{[end\_reconfigure]}, the action \texttt{[working]} outgoing or the action \texttt{[end]} outgoing \redcomment{Figure}. By interpreting the name of the actions we see that this system seems to have a configuration phase a working phase a reconfiguring phase and an end phase. The grouping appears to be very similar to \viewparamvalident(\texttt{phases}). Hence, we consider $\viewweakoutactident \pll \viewparamvalident(\texttt{phases})$ (Figure \ref{fig:0603act+phases}). Indeed the enumeration coincides with the grouping of outgoing actions, with the exception of \texttt{[end]} and \texttt{[reconfigure]} \redcomment{timed behavior?}

\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\centering 
		\vfill
		\includegraphics[width=\textwidth]{./06/images/06_03_time.png}
		\vfill
%		\label{fig:0601time}
%		\caption{Screenshot in current version of \pmcvis of \viewN $\viewNC \view[\pptyparamcnf](c(\state)) \pll \viewdistance \compselect \viewident$ where $\compselectset = \{(\gfctdistance,1)\}$}
	\end{minipage}
	\hfill
	\begin{minipage}{.5\textwidth}
		\centering \includegraphics[width=\textwidth]{./06/images/06_03_phases.png}
%		\label{fig:0601phases}
%		\caption{Screenshot in current version of \pmcvis of \viewN $\viewNC \view[\pptyparamcnf](c(\state)) \pll \viewdistance \compselect \viewident$ where $\compselectset = \{(\gfctdistance,1)\}$}
	\end{minipage}
	\caption{Screenshot in current version of \pmcvis of \viewN $\viewparamvalident(\texttt{time})$ (left) and \viewN $\viewparamvalident(\texttt{phases})$ (right)}
	\label{fig:0603timeandphases}
\end{figure}

\begin{figure}[!htb]
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_time+phases.png}
	\caption{Screenshot in current version of \pmcvis of \viewN $\viewparamvalident(\texttt{time}) \pll \viewparamvalident(\texttt{phases})$}
	\label{fig:0603time+phases}
\end{figure}

\begin{figure}
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_act.png}
	\caption{Screenshot in current version of \pmcvis of \viewN \viewweakoutactident}
	\label{fig:0603act}
\end{figure}

\begin{figure}[!htb]
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_act+phases.png}
	\caption{Screenshot in current version of \pmcvis of \viewN $\viewparamvalident(\texttt{time}) \pll \viewparamvalident(\texttt{phases})$}
	\label{fig:0603act+phases}
\end{figure}

Hence we know that the system is working for $\texttt{phase}=0$, configuring for $\texttt{phase}=1$ and termination configuration in $\texttt{phase}=2$. This process is repeated six times until $\texttt{time}=5$.

\newcommand{\maxexpreward}{\redcomment{"MinUtility":R{"Utility"}min=?[ F "end" ]}
	}

\newcommand{\minexpreward}{\redcomment{"MaxUtility":R{"Utility"}max=?[ F "end" ]}}
In general we learned that this system runs several times with choosing certain configurations each time before it runs. Its reward function rewards states that work with a better configuration. A classic model checking \redcomment{value} is to determine \minexpreward and \maxexpreward. For \minexpreward we obtain \redcomment{x}, for \maxexpreward \redcomment{inf}. Since the system is modeled for a finite time and each time chooses from a finite set of configurations, it is unwanted behavior, that \maxexpreward is infinite. We will now show how views can help to find the cause.

Such behavior of infinite \maxexpreward is often caused by cycles. A feasible idea would be to use a view with cycles. As it will be discussed in Chapter \redcomment{Performance} these \viewsN very ressource intensive when there are larger strongly connected components. Moreover when finding strongly connected components the cycles are equally found since each cycle is a strongly connected component. The view \viewscc yields that there are quite large strongly connected components (Figure \ref{fig:0603scc}). To find out where these are locate we consider the parallely composed \viewN on \mdpN with $\viewscc \pll \viewweakoutactident$ (Figure \ref{fig:0603scc+act}). We see that the strongly connected components are in the configuring phase. When taking a look at the prism file, we see that we can arbitrarily often switch the configuration. Hence, it is not assured that a configuration can only be selected once. This causes infinite paths in the \mdpN, which in consequence cause infinite maximal expectations. This can be fixed by assuring that a configuration can only be selected once. An easy way of accomplishing this is to sequentialize the selection of the two configurations: Firstly \texttt{[configuration1]} is selected, afterwards \texttt{[configuration2]} and finally the configuration phase ends (\texttt{[end\_configuration]} is the only available action left to take) (Figure \ref{lst:0603sccloopsafter}).

\begin{figure}[!htb]
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_scc.png}
	\caption{Screenshot in current version of \pmcvis of \viewN \viewscc}
	\label{fig:0603scc}
\end{figure}

\begin{figure}[!htb]
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_scc+act.png}
	\caption{Screenshot in current version of \pmcvis of \viewN $\viewscc \pll \viewweakoutactident$}
	\label{fig:0603scc+act}
\end{figure}

%\begin{figure}[!htb]
%	\centering \includegraphics[width=\textwidth, height=20cm,
%	keepaspectratio]{./06/prism/scc-loops-after.png}
%	\caption{Fixed model file}
%	\label{fig:0603sccloopsafter}
%\end{figure}

\begin{figure}
	\begin{lstlisting}[language=prism, caption={Fixed model file},label={lst:0603sccloopsafter}]
mdp

const int c_max_time = 5;

label "end" = (time = c_max_time);

module reconfiguration
activity: [0..3] init 0;
config1: [0..4] init 0;
config2: [0..4] init 0;

[reconfigure] (activity=0) -> (activity'=1);

[configure1] (activity=1) -> (config1'=0) & (activity'=2);
[configure1] (activity=1) -> (config1'=1) & (activity'=2);
[configure1] (activity=1) -> (config1'=2) & (activity'=2);
[configure1] (activity=1) -> (config1'=3) & (activity'=2);
[configure1] (activity=1) -> (config1'=4) & (activity'=2);

[configure2] (activity=2) -> (config2'=0) & (activity'=3);
[configure2] (activity=2) -> (config2'=1) & (activity'=3);
[configure2] (activity=2) -> (config2'=2) & (activity'=3);
[configure2] (activity=2) -> (config2'=3) & (activity'=3);
[configure2] (activity=2) -> (config2'=4) & (activity'=3);

[end_reconfigure] (activity=3) -> (activity'=0);
endmodule

module phases
phases: [0..2] init 0;

[reconfigure] (phases=0) -> (phases'=1);
[end_reconfigure] (phases=1) -> (phases'=2);
[working] (phases=2) -> (phases'=0);

endmodule

module timer
time: [0..c_max_time] init 0;

[working] (time < c_max_time) -> (time'=time+1);
[reconfigure] (time < c_max_time) -> true;

[end] (time=c_max_time) -> true;
endmodule

rewards "Utility"
[working] true : config1*3 + config2*2;
endrewards
\end{lstlisting}

\end{figure}


%\begin{itemize}
%	\item USE: scc with loops
%	\item We already saw in chapter ch that variables can help a lot with understanding an \chgph
%	\item When applying it to time and phases we see that the system has limited timed behavior and that it operates in phases
%	\item considering time pll phases we see that these phases are repeated for each time
%	\item Still no idea what the model actually does
%	\item since this view has actions it may help to use the outactions view
%	\item see phases
%	\item when activating phases pll action see that in phase=0 ... and will eventually terminate in phase=0
%	\item \redcomment{time+scc+init}
%%	\item time apply strongly connected components -> structure of mdp very clear
%%	\item apply init to see where it start
%	\item maxReward is infinite -> not wanted
%	\item search for cycles or scc
%	\item are cycles $\to$ exact cycles \redcomment{maybe exact cycles}
%	\item fix mdp $\to$ no more cycles $\to$ show no more cycles
%	
%\end{itemize}

\subsection{Performance}

\viewsNC shall be used on \mdpsN that may have millions of states. For this reason in this section we will consider the time to create a new view. In addition we will take a look at the build time of internal graph structure (\texttt{mdpGraph}) that is based on the \jgrapht library, with respect to its built time and memory occupation. The tests have been performed on a Dell XPS 9370 (16 GB RAM, Intel Core i7-8550U) with Manjaro KDE. Only neccesary tools where opened when the test were running: Firefox and IntelliJ.

Time was measured with self written class \texttt{Timer} which utilizes the package \texttt{java.time.LocalTime}. Class implementation and sample usecase are provided in the appendix \redcomment{to be added in the appendix}. Memory occupation has been measured with with the tool Java Object Layout (JOL) provided by openJDK. The method used was \texttt{totalSize()} in \texttt{org.openjdk.jol.info.GraphLayout}. For the benchmark one single scalable \mdpN is used (prism model file in appendix). Sizes considered are 50, 100, 500,1 000, 5 000, 10 000, 50 000, 100 000, 500 000 and 1 000 000. Using one single scalable \mdpN means that execution times and memory occupied might vary with differing graph structure of the \mdpN. This is especially the case for \viewsN based on the graph structure. Hence in this section we will give more of an overview of the expected values for creation times and memory occupation rather than a detailed analysis.

Firstly we will consider the time required to create \viewsN. All \viewsN are created 100 times for each considered size of the \mdpN. Their execution times for each sizes then are averaged. As we know from Chapter \ref{ch:viewimpl} creating a view involves to instantiate the object and execute the build function. The instantiation only involves setting a hand full of private attributes. Since the amount of attributes of a view is fix and their size does not cohere with the size of the \mdpN, the is instantiation time is negligible. Building \texttt{mdpGraph} is also part of instantiating a \viewN in case it has not yet been built on the model, but will be considered separately. Hence, we will focus on the time occupied by the \texttt{buildView()} method. As we know from section \ref{ch:viewimpl} the build \texttt{buildView()} method splits into four parts: 1) checking prerequisites ("prechecks"), 2) creating a new column, 3) executing \grpfctN 4) write results to database. Firstly we will consider the computation time for the grouping function as the time actions performed in the steps 1) 2) and 4) are almost identical or identical.
	
In Figure \ref{fig:grpfcttimes} we see the averaged execution times (100 executions) of \texttt{groupingFunction} for the different \viewsN. It is to see that the execution times overall are very similar and behave linear to the amount of states of the \mdpN. For \mdpsN with up to 1 million states for no \viewN the execution time of its grouping function exceeds 1.5 seconds. Variation in the magnitude of microseconds with very small \mdpsN are to be expected. In general the performance results as shown indicates very good scalability with respect of views being usable on large models. This very good performance is to large portion attributed to the graphstructure provided by \jgrapht.

In Figure \ref{fig:compdbgraphgrpfct} we see the execution time of the grouping function compared to executing the generated SQL statements (writing results/mappings to database) and the creation of the \texttt{mdpGraph}. We see that apart from prechecks, the execution time of the grouping function is the least time consuming operation. Most time is taken by writing the results to the database, where even building the \texttt{mdpGraph} is faster. Times for writing to the database, refer to the at this time present implementation of the database of \pmcvis which might be subject to changes in the future.

As stated before the performance of computing grouping functions that quickly heavily rely on the implemented graph structure (\texttt{mdpGraph}). This graph structure is held in memory and become quite large for \mdpsN with about one million states. Figure \ref{fig:sizemdpgraph} displays the measured deep size (including referenced objects) of the \texttt{mdpGraph}. As one would expect the size of the \texttt{mdpGraph} is linear to the size of the \mdpN. Additionally, it can be seen that up to 1.3 GB of memory are occupied for the graph alone if, the \mdpN reaches about 1 million states. Depending on the operating system, the amount of memory built into the machine (PC) and the currently available memory, it is possible to utilize the \texttt{mdpGraph} even for large \mdpsN. Still it is to be kept in mind that this only is the size of the built graph object. When reading from the database in order to build the \texttt{mdpGraph} more memory is needed as objects containing the information from the database also temporarily stay in memory. \pmcvis itself will also require memory as other possibly unrelated process that run on the system. On the machine used for testing, building the \texttt{mdpGraph} for \mdpsN with about 1 million states and creating views on them was still reasonable, while at the same time also close to the memory limitation of the system.

In general we conclude that computation of grouping functions is rather quick and scalable. Building times of the \texttt{mdpGraph} are reasonable, but entails heavy memory utilization. Database accesses are the most time consuming fraction of the time needed to create a view. 

\begin{figure}
	\begin{tikzpicture}
	\begin{loglogaxis}
		[
		width=\textwidth,
		height=8cm,
		xlabel={State amount},
		ylabel={$\frac{time}{ms}$},
		legend pos=north west,
		ymin=0,
%		ymax=1000, % Adjust the y-axis range as needed
		]
		
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/InActIdentView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/OutActIdentView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/InActView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/OutActView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/OutActSetSizeView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/VariablesView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/VariablesViewDnf.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/VariablesViewCnf.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/ReachabilityView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/DistanceView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/SccView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/SccbView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/APView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/InitView.csv};
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/PropertyView.csv};


		
%		\legend{InActIdentView, 
%			OutActIdentView,
%			InActView,
%			OutActView,
%			OutActSetSizeView,
%			VariablesView,
%			VariablesViewDnf,
%			VariablesViewCnf, 
%			ReachabilityView, 
%			DistanceView,
%			SccView,
%			SccbView,
%			APView,
%			InitView,
%			PropertyView}

	\end{loglogaxis}
\end{tikzpicture}
	\caption{Average grouping function computation times}
	\label{fig:grpfcttimes}
\end{figure}


\begin{figure}
	\begin{tikzpicture}
	\begin{loglogaxis}
		[
		width=\textwidth,
		height=8cm,
		xlabel={State amount},
		ylabel={$\frac{time}{ms}$},
		legend pos=north west,
		ymin=0,
		%		ymax=1000, % Adjust the y-axis range as needed
		]
		
	
		\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/OutActIdentView.csv};
		\addplot table [x=StateCount, y=0AvgMdp, col sep=comma] {./06/PerformanceTests/MdpGraph/MdpGraph.csv};
		\addplot table [x=StateCount, y=0AvgE, col sep=comma] {./06/PerformanceTests/ExecuteBatch/ExecuteBatchInActIdentCSV2-all.csv};
		\addplot table [x=StateCount, y=1AvgP, col sep=comma] {./06/PerformanceTests/PreChecks/PreChecks.csv};
			
		
		
		\legend{Grouping Function, 
				Create MDP Graph,
				Write to Database,
				Prechecks
			}
		
	\end{loglogaxis}
	\end{tikzpicture}
	\caption{Average times for grouping function computation (1 representative from Figure \ref{fig:grpfcttimes}), writing to the database and building the \texttt{mdpGraph}}
	\label{fig:compdbgraphgrpfct}
\end{figure}


\begin{figure}
	\begin{tikzpicture}
		\begin{loglogaxis}
			[
			width=\textwidth,
			height=8cm,
			xlabel={State amount},
			ylabel={$\frac{time}{ms}$},
			legend pos=north west,
			ymin=0,
			%		ymax=1000, % Adjust the y-axis range as needed
			]
			
			
			\addplot table [x=StateCount, y=MdpSizeByte, col sep=comma] {./06/PerformanceTests/MdpGraph/MdpGraphSize.csv};
			
				
%			\legend{BuildTimeView, 
%				CreateMdpGraph,
%				ExecuteBatch
%			}
			
		\end{loglogaxis}
	\end{tikzpicture}
	\caption{Size of \texttt{mdpGraph} for different model sizes}
	\label{fig:sizemdpgraph}
\end{figure}

\end{document}