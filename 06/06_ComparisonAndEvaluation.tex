\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}

\begin{document}
\section{Comparison and Evaluation} \label{ch:eval}
In this chapter we want to show how \viewsN can be utilized in three different usecases. In subsection 6.4 we will consider performance aspects.
In the usecases we will see screenshots made in the to this time current version \pmcvis. (Grouped) States are represented by grey rectangles. The blue labels on them are the mapped values from the \grpfctN. These do not always exactly match the ones of the formalization. Especially it is to note that $\texttt{\_\_BLANK\_\_} = \remelem$. If parallel composition is used in some form, the values of the \grpfctsN in the label are separated with \texttt{|} and are in the same order as they have been composed with the operator \pll. If we formally have $\view[\viewppty_1]\pll\view[\viewppty_2] = \view[\viewppty_1\pll\viewppty_2]$ and for some grouped states \smstates it holds for all of them $\view[\viewppty_1\pll\viewppty_2](\smstate) = (a,b)$  where $\smstate \in \smstates$, then in the screenshot of \pmcvis the grouped state of the view receives the label {\color{RoyalBlue}\texttt{a|b}}.


\subsection{Explore Modules} \label{subsec:evalmodules}
\newcommand{\phil}[1]{\texttt{p#1}}


One Purpose of \viewsN is to simplify \mdpsN to make them better understandable. Due to the state explosion problem already rather simple systems can become very hard to oversee. As an example consider the concurrency problem Dining Philosophers, where n philosophers have to share n-1 forks and each of them needs two to eat. They are sitting on a round table with forks between them. Each of them only has access to fork to their left and right, if it is not already occupied. When representing the problem with an \mdpN the choice of which fork the philosopher tries to pick is made at random with an uniform distribution. The respective prism File is shown in the appendix (\ref{lst:0601diningphilosophersfull}).

Already for only three philosophers the \mdpN has 956 states. When looking at the graphical representation from \pmcvis in Figure \ref{fig:0601Pure} it appears to be little helpful for understanding and exploring the graph due to its sheer size. Although the graph is large, this \mdpN is still rather small. With already five philosophers the MDP has about 100 000 states and with 10 philosophers the resulting MDP has more than 8 billion states. The \viewN \viewparamvalident can help to only show the behavior of some Philosophers and hiding the behavior of the remaining ones. 

\begin{figure}
	\includegraphics[width=\textwidth]{./06/images/06_01_pure_zoomhalf.png}
	\caption{Screenshot in \pmcvis of approximately half the \mdpN \mdp}
	\label{fig:0601Pure}
\end{figure}

The \viewN $\viewparamvalident(\phil{1})$ groups all states that have the same value of (\phil{1}) ignoring the values of the remaining variables. That is, the values of \phil{2} and \phil{3} are hidden, which results in only showing the module of philosopher \phil{1} (Figure \ref{fig:0601var}). This may help immensely if only a specific module is of interest or the reaming modules have the same structure, as it is the case here with Dining Philosophers. 
%Further views could be \viewparamvalident(\phil{1}) applied to understand or explore the module.
%For example if in Dining Philosophers we were interested in the part of the module where \phil{1} picks their first fork we could use the \viewN \viewparamdnf with c(s) = \redcomment{missing}({Figure}).
%\redcomment{picking could be added}

\begin{figure}[!htb]
	\includegraphics[width=\textwidth]{./06/images/06_01_var.png}
	\caption{Screenshot in \pmcvis of \viewN $\viewparamvalident(\phil{1})$}
	\label{fig:0601var}
\end{figure}

It is also possible to use the view \viewparamvalident to see the interleaved behavior of two or more modules. To see the interleaved behavior of \phil{1} and \phil{2}, we use parallel composition $\viewparamvalident(\phil{1}) \pll \viewparamvalident(\phil{2})$. This results in states $\state_1, \state_2$ being grouped if $(\gfctparamvalident (\state_1 \cond \phil{1}), \gfctparamvalident(\state_1 \cond \phil{2})) = (\gfctparamvalident(\state_2 \cond \phil{1}), \gfctparamvalident(\state_2 \cond \phil{2}))$. Hence, only the value of \phil{3} is hidden which results exactly in the desired interleaved model (Figure \ref{fig:0601var+var}).

\begin{figure}
	\includegraphics[width=\textwidth]{./06/images/06_01_var+var.png}
	\caption{Screenshot in \pmcvis of \viewN $\viewparamvalident(\phil{1}) \pll \viewparamvalident(\phil{2})$}
	\label{fig:0601var+var}
\end{figure}

In general the views \viewparamdnf and \viewparamcnf are very powerful since they allow to perform every possible operation on variables, because the state space is finite, for \mdpsN in practice.

%\begin{itemize}
%	\item USE: dinging Philosopher
%	\item consider dining Philosophers with
%	\item current graphical Representation looks as follows
%	\item only has about 1000 states in case studies prism mdp with about ... states
%	\item in general seems simple
%	\item parameters cluster: allows looking at just one module
%	\item also interleaving of arbitrary modules
%	\item
%	\item hasAction or OutAction-Ident for specific MDP-that run through configuration phases
%	
%\end{itemize}

\subsection{Investigate why illegal states can be reached}
\newcommand{\critstate}{\mt{\varstyle{2}{2}}}

In this section we want to show how views can be used for debugging. In this specific case we assume that we observed unwanted behavior or model checking results. We know that some states - that is some assignment of variables - are not allowed. We will check if these states are in fact not reachable.

We will consider a small \mdpN, that we have been given the \prism file for. It represents two systems that intend to send information via a unshareable medium. With a probability of $0.8$ a system can establish a connection and with probability of $0.2$ establishing a connection will fail. After an established connection access to the medium shall only be granted, if it is not occupied by the other system. If the medium is not occupied the system starts sending, otherwise it waits until the medium is free. The termination of the transmission is modeled with probabilities. There is 50 percent chance of terminating the transmission and a 50 percent chances of continuing. The number 0 represents that a system is trying to establish a connection, the number 1 represents that a system established the connection, the number 2 represents that the system is sending.

The state \critstate should not be reachable, since it represents the situation of the two systems occupying the unshareable medium at the same time. We will check if this state in fact is not reachable by using the $\view[\pptyparamcnf](c(\state))$ where $c(\state) := (x=2) \land (y=2)$ (Figure \ref{fig:0602Var}). Note that we are not using \viewN \emph{not} in disregarding form.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=.7\textwidth]{./06/images/06_02_Var.png}
	\caption{Screenshot in \pmcvis of \viewN $\view[\pptyparamcnf](c(\state))$ where \texttt{\mytexttilde Var} refers to \notppty.}
	\label{fig:0602Var}
\end{figure}

We observe, that this state is reachable, because it is shown and only reachable states are shown at all in \pmcvis. The question is how and why. To get this information, it should be investigated by which state this critical state \critstate has been reached. One way of accomplishing that is to look into the database that stores states and transitions (Table \ref{tab:0602database}). For this very simple \mdpN, this already seems to be of little help.

%\begin{figure}
%	\includegraphics[width=\textwidth]{./06/prism/database-tpme.png}
%	\caption{Transitions table form database}
%	\label{fig:0602database}
%\end{figure}

\begin{table}[!htb]
	\vspace{1cm}
	\centering
	\resizebox{\columnwidth}{!}{
	\begin{tabular}{|l|r|l|r|l|r|l|r|}%{|c|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{transition\_id} & \textbf{state\_out} & \textbf{action} & \textbf{probabilityDistribution} & \textbf{property\_0} & \textbf{scheduler\_0} & \textbf{property\_1} & \textbf{scheduler\_1} \\
		\hline
		1 & 3 & M1 & 6:1.0 & 0.0 & 1.0 & 0.0 & 1.0 \\
		2 & 3 & M2 & 3:0.8;4:0.2 & 0.0 & 1.0 & 0.0 & 1.0 \\
		3 & 7 & M1 & 1:0.5;7:0.5 & 0.0 & 1.0 & 0.0 & 1.0 \\
		4 & 7 & M2 & 6:0.5;8:0.5 & 0.0 & 1.0 & 0.0 & 1.0 \\
		5 & 0 & M1 & 0:0.8;3:0.2 & 0.0 & 1.0 & 0.0 & 1.0 \\
		6 & 0 & M2 & 0:0.8;1:0.2 & 0.0 & 1.0 & 0.0 & 1.0 \\
		7 & 4 & M1 & 7:1.0 & 0.0 & 1.0 & 0.0 & 0.0 \\
		8 & 4 & M2 & 5:1.0 & 1.0 & 0.0 & 1.0 & 1.0 \\
		9 & 4 & M2 & 3:0.5;5:0.5 & 0.5 & 0.0 & 0.5 & 0.0 \\
		10 & 8 & M1 & 2:0.5;8:0.5 & 0.0 & 1.0 & 0.0 & 1.0 \\
		11 & 1 & M1 & 1:0.8;4:0.2 & 0.0 & 1.0 & 0.0 & 1.0 \\
		12 & 1 & M2 & 2:1.0 & 0.0 & 1.0 & 0.0 & 1.0 \\
		13 & 1 & M2 & 0:0.5;2:0.5 & 0.0 & 1.0 & 0.0 & 1.0 \\
		14 & 2 & M1 & 2:0.8;5:0.2 & 0.2 & 1.0 & 0.2 & 1.0 \\
		15 & 6 & M1 & 0:0.5;6:0.5 & 0.0 & 1.0 & 0.0 & 1.0 \\
		16 & 6 & M2 & 6:0.8;7:0.2 & 0.0 & 1.0 & 0.0 & 1.0 \\
		\hline
	\end{tabular}
}
	\caption{Transitions table form the database, where states are numerated with $\texttt{state\_out} = x\cdot3^1 + y\cdot3^0$ for a state $\langle x,y \rangle$}
	\label{tab:0602database}
	\vspace{2cm}
\end{table}

\begin{figure}[!htb]
	\begin{lstlisting}[language=prism, caption={PRISM model file, where modules define the two systems mentioned in the text},label={lst:0602prismbefore}]
		mdp
		
		module M1
		x : [0..2] init 0;
		
		[] x=0 -> 0.8:(x'=0) + 0.2:(x'=1);
		[] x=1 & y!=2 -> (x'=2);
		[] x=2 -> 0.5:(x'=2) + 0.5:(x'=0);
		endmodule
		
		module M2
		y : [0..2] init 0;
		
		[] y=0 -> 0.8:(y'=0) + 0.2:(y'=1);
		[] y=1 & x!=2 -> (y'=2);
		[] y=1 -> 0.5:(y'=2) + 0.5:(y'=0);
		endmodule		
	\end{lstlisting}
\end{figure}

A better approach might be to look at the \prism model file (figure \ref{lst:0602prismbefore}). People experienced in working with prism models may be able to find the problem quickly, especially since this is a rather small \mdpN. With less experienced people, and especially with larger and more complicated models, finding a problem becomes much more difficult. So let us see how views can help us.

First, we will use the view \viewdistancerev from this state (Figure \ref{fig:0602Var+Dist} (left)). This shows the structure of the \mdpN in terms of how this state is reached. That is, states are grouped that require the same number of transitions to reach the critical state \critstate. The natural number indicates the number of transitions needed to reach it. The state \texttt{\mytexttilde Var|1} represents a group of states that can reach \critstate with a single transition. We are interested in which states it contains, so that we know which state of the original \mdpN reaches \critstate. Since the current version of the project does not yet implement expanding grouped states to their contained states on a visual level, we will use a custom \viewN that emulates this feature.

%\begin{figure}
%	\begin{minipage}{.5\textwidth}
%%	\begin{subfigure}
%	\centering \includegraphics[width=.95\linewidth]{./06/images/06_02_Var+Dist.png}
%	\label{fig:0602Var+Dist}
%%	\caption{Screenshot in \pmcvis of \viewN $\view[\pptyparamcnf](c(\state)) \pll \viewdistance$}
%%\end{subfigure}
%\end{minipage}
%\begin{minipage}{.5\textwidth}
%%	\begin{subfigure}
%	\hspace{10mm}
%	\centering \includegraphics[width=\linewidth]{./06/images/06_02_Var+Dist+Id.png}
%	\label{fig:0602Var+Dist+Id}
%%	\caption{Screenshot in \pmcvis of \viewN $\viewNC \view[\pptyparamcnf](c(\state)) \pll \viewdistance \pll \viewident$}
%%\end{subfigure}

	
%\end{minipage}
%\label{fig:0602VarDistIdDouble}
%%\caption{Screenshot in \pmcvis of \viewN $\view[\pptyparamcnf](c(\state)) \pll \viewdistance$ on the left and \viewN $\view[\pptyparamcnf](c(\state)) \pll \viewdistance \pll \viewident$}
%\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=.8\textwidth]{./06/images/06_02_Var+Dist.png}
	\caption{Screenshot in \pmcvis of \viewN $\view[\pptyparamcnf](c(\state)) \pll \viewdistance$ where \texttt{\mytexttilde Var} refers to \notppty.}
	\label{fig:0602Var+Dist}
\end{figure}

\begin{definition}
	Let $\chgph = \chgphtuple$ be \achgphN, $\smstates \subseteq \states$ and $n \in \natnums$. The \viewN \viewident is defined by its \grpfctN \gfctident where $\gfctsubident : \smstates \to \imggrp$ with
	\[
	\gfctsubident(\state) = \state
	\]
	and $\imggrp = \states \cup \remset$.
\end{definition}

\sloppy
We will use partial application with $\view[\pptyparamcnf](c(\state)) \compselect \viewident$ where $\compselectset = \{(\gfctdistance,1)\}$ to expand this state. The MDP graph then looks like in \ref{fig:0602Var+Dist+Id}. It can be seen that the state contains only one state with the id seven. In the current version of the implementation it is not possible to get the parameter values. With the database file we obtain that this is the state where $x=2$ and $y=1$. Since $x=2$ means that system 1 is sending and system 2 is waiting, we see that it is possible for the second system to start sending on the medium although it is already occupied by the first system!

\begin{figure}[!htb]
	\centering \includegraphics[width=.8\textwidth]{./06/images/06_02_Var+Dist+Id.png}
	\caption{Screenshot in \pmcvis of \viewN $\view[\pptyparamcnf](c(\state)) \pll$ $\viewdistance \compselect \viewident$ where $\compselectset = \{(\gfctdistance,1)\}$ and \texttt{\mytexttilde Var} refers to \notppty.}
	\label{fig:0602Var+Dist+Id}
\end{figure}

If we look at the prism file (Listing \ref{lst:0602prismbefore}), we can see why this is the case. In the last line of the second module, when $y=1$, there is a 50\% chance that $y=2$ will be entered. This line was originally intended to terminate the transfer. From $y=1$ it should not be possible to enter $y=2$ if $x=2$. After fixing this, the state no longer appears when using $\viewparamdnf(c(\state))$.
	
%\begin{itemize}
%	\item USE: two process switch 
%	\item illegal state has been reached?
%	\item given state 2,2 should not be reachable
%	\item is reachable
%	\item is only!
%	\item apply distance cluster
%	\item emulate not yet feature of expansion
%	\item use identityView (with Parameters)
%	\item see in Database
%	\item fix in File
%\end{itemize}


%\subsection{Find out how why we reach a certain state}
%%	\item two dies
%%	\item property cluster

\subsection{Understand and Debug \chgphN}

In this subsection, we want to take a look at a more complex use case of how views can help us understand and fix a given \mdpN. We refer to the \mdpN with as described by the \prism file in Listing \ref{lst:0603sccloopsbefore}.

%\begin{figure}[!htb]
%	\centering \includegraphics[width=\textwidth, height=20cm,
%	keepaspectratio]{./06/prism/scc-loops.png}
%	\caption{Given MDP}
%	\label{fig:0603sccloopsbefore}
%\end{figure}


\begin{figure}
	\begin{lstlisting}[language=prism, caption={PRISM model file},label={lst:0603sccloopsbefore}]
mdp

const int c_max_time = 5;

label "end" = (time = c_max_time);

module reconfiguration
activity: [0..1] init 0;
config1: [0..4] init 0;
config2: [0..4] init 0;

[reconfigure] (activity=0) -> (activity'=1);

[configure1] (activity=1) -> (config1'=0);
[configure1] (activity=1) -> (config1'=1);
[configure1] (activity=1) -> (config1'=2);
[configure1] (activity=1) -> (config1'=3);
[configure1] (activity=1) -> (config1'=4);

[configure2] (activity=1) -> (config2'=0);
[configure2] (activity=1) -> (config2'=1);
[configure2] (activity=1) -> (config2'=2);
[configure2] (activity=1) -> (config2'=3);
[configure2] (activity=1) -> (config2'=4);

[end_reconfigure] (activity=1) -> (activity'=0);
endmodule

module phases
phases: [0..2] init 0;

[reconfigure] (phases=0) -> (phases'=1);
[end_reconfigure] (phases=1) -> (phases'=2);
[working] (phases=2) -> (phases'=0);

endmodule

module timer
time: [0..c_max_time] init 0;

[working] (time < c_max_time) -> (time'=time+1);
[reconfigure] (time < c_max_time) -> true;

[end] (time=c_max_time) -> true;
endmodule

rewards "Utility"
[working] true : config1*3 + config2*2;
endrewards	
\end{lstlisting}

\end{figure}
First, we will gain some understanding of the model. We already saw in Section 6.1 that variables can help a lot in understanding a \chgphN. Using $\viewparamvalident(\texttt{time})$ we see that the \chgphN has a limited time behavior (Figure \ref{fig:0603timeandphases} left). If we apply $\viewparamvalident(\texttt{phases})$ we see that the system works in phases (Figure \ref{fig:0603timeandphases} right). If we look at $\viewparamvalident(\texttt{time}) \pll \viewparamvalident(\texttt{phases})$, we see that the phases are repeated for each iteration of time (Figure \ref{fig:0603time+phases} right). However, we still have no information about the behavior of the system in these phases. Since this model has actions, we will consider the \viewN \viewweakoutactident (Figure \ref{fig:0603act}). We see that we have sets of states that only have transitions with the action \texttt{[reconfigure]} outgoing, the action \texttt{[working]} outgoing, the actions \texttt{[configure1]}, \texttt{[configure2]}, \texttt{[end\_reconfigure]} outgoing, the action \texttt{[working]} outgoing, or the action \texttt{[end]} outgoing. By interpreting the names of the actions, we see that this system seems to have a configuration phase, a working phase, a reconfigure phase, and an end phase. The grouping seems very similar to \viewparamvalident(\texttt{phases}). Therefore, we consider $\viewweakoutactident \pll \viewparamvalident(\texttt{phases})$ (Figure \ref{fig:0603act+phases}). In fact, the enumeration coincides with the grouping of outgoing actions, except for \texttt{[end]} and \texttt{[reconfigure]}. 
%\redcomment{timed behavior?}


\begin{figure}[!htb]
	\begin{minipage}{.5\textwidth}
		\centering 
		\vfill
		\includegraphics[width=\textwidth]{./06/images/06_03_time.png}
		\vfill
%		\label{fig:0601time}
%		\caption{Screenshot in \pmcvis of \viewN $\viewNC \view[\pptyparamcnf](c(\state)) \pll \viewdistance \compselect \viewident$ where $\compselectset = \{(\gfctdistance,1)\}$}
	\end{minipage}
	\hfill
	\begin{minipage}{.5\textwidth}
		\centering \includegraphics[width=\textwidth]{./06/images/06_03_phases.png}
%		\label{fig:0601phases}
%		\caption{Screenshot in \pmcvis of \viewN $\viewNC \view[\pptyparamcnf](c(\state)) \pll \viewdistance \compselect \viewident$ where $\compselectset = \{(\gfctdistance,1)\}$}
	\end{minipage}
	\caption{Screenshot in \pmcvis of \viewN $\viewparamvalident(\texttt{time})$ (left) and \viewN $\viewparamvalident(\texttt{phases})$ (right). Larger versions of these images in appendix (\ref{apx:0603timeandphases})}
	\label{fig:0603timeandphases}
\end{figure}

\begin{figure}[!htb]
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_time+phases.png}
	\caption{Screenshot in \pmcvis of \viewN $\viewparamvalident(\texttt{time}) \pll \viewparamvalident(\texttt{phases})$}
	\label{fig:0603time+phases}
\end{figure}

\begin{figure}
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_act.png}
	\caption{Screenshot in \pmcvis of \viewN \viewweakoutactident}
	\label{fig:0603act}
\end{figure}

\begin{figure}[!htb]
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_act+phases.png}
	\caption{Screenshot in \pmcvis of \viewN $\viewparamvalident(\texttt{time}) \pll \viewparamvalident(\texttt{phases})$}
	\label{fig:0603act+phases}
\end{figure}

So we know that the system works for $\texttt{phase}=0$, configures for $\texttt{phase}=1$, and stops configuring for $\texttt{phase}=2$. This process is repeated six times until $\texttt{time}=5$.

%\newcommand{\maxexpreward}{\texttt{"MinUtility":R{"Utility"}min=?[ F "end" ]}
\newcommand{\maxexpreward}{\mt{Exp_{utility}^{\max}(\lozenge \texttt{end})}
} 
\newcommand{\minexpreward}{\mt{Exp_{utility}^{\min}(\lozenge \texttt{end})}}

In general, we learned that this system runs several times, each time choosing certain configurations before it runs. Its reward function rewards states that work with a better configuration. A classic model checking value is to determine \minexpreward and \maxexpreward. For \minexpreward we obtain $0$, for \maxexpreward we obtain $\infty$. Since the system is modeled for a finite time and chooses from a finite set of configurations each time, it is undesirable behavior for \maxexpreward to be infinite. We will now show how views can help to find the cause.

Such behavior of infinite \maxexpreward is often caused by cycles. One feasible idea would be to use a view with cycles. A less resource-intensive way to find sets containing cycles is to find strongly connected components, since each cycle is a strongly connected component. The view \viewscc shows that there are quite large strongly connected components (Figure \ref{fig:0603scc}). To find out where these are, we look at the parallel composed \viewN on \mdpN with $\viewscc \pll \viewweakoutactident$ (Figure \ref{fig:0603scc+act}). We see that the strongly connected components are in the configuration phase. Looking at the Prism file, we see that we can change the configuration as often as we like. Thus, there is no guarantee that a configuration can only be selected once. This leads to infinite paths in the \mdpN, which in turn leads to infinite maximum expectations. This can be fixed by ensuring that a configuration can only be selected once. A simple way to do this is to sequentially select the two configurations: First \texttt{[configuration1]} is selected, then \texttt{[configuration2]}, and finally the configuration phase is ended (\texttt{[end\_configuration]} is the only available action left) (Figure \ref{lst:0603sccloopsafter}).

\begin{figure}[!htb]
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_scc.png}
	\caption{Screenshot in \pmcvis of \viewN \viewscc}
	\label{fig:0603scc}
\end{figure}

\begin{figure}[!htb]
	\centering \includegraphics[width=\textwidth]{./06/images/06_03_scc+act.png}
	\caption{Screenshot in \pmcvis of \viewN $\viewscc \pll \viewweakoutactident$}
	\label{fig:0603scc+act}
\end{figure}

%\begin{figure}[!htb]
%	\centering \includegraphics[width=\textwidth, height=20cm,
%	keepaspectratio]{./06/prism/scc-loops-after.png}
%	\caption{Fixed model file}
%	\label{fig:0603sccloopsafter}
%\end{figure}

\begin{figure}
	\begin{lstlisting}[language=prism, caption={Fixed model file},label={lst:0603sccloopsafter}]
mdp

const int c_max_time = 5;

label "end" = (time = c_max_time);

module reconfiguration
activity: [0..3] init 0;
config1: [0..4] init 0;
config2: [0..4] init 0;

[reconfigure] (activity=0) -> (activity'=1);

[configure1] (activity=1) -> (config1'=0) & (activity'=2);
[configure1] (activity=1) -> (config1'=1) & (activity'=2);
[configure1] (activity=1) -> (config1'=2) & (activity'=2);
[configure1] (activity=1) -> (config1'=3) & (activity'=2);
[configure1] (activity=1) -> (config1'=4) & (activity'=2);

[configure2] (activity=2) -> (config2'=0) & (activity'=3);
[configure2] (activity=2) -> (config2'=1) & (activity'=3);
[configure2] (activity=2) -> (config2'=2) & (activity'=3);
[configure2] (activity=2) -> (config2'=3) & (activity'=3);
[configure2] (activity=2) -> (config2'=4) & (activity'=3);

[end_reconfigure] (activity=3) -> (activity'=0);
endmodule

module phases
phases: [0..2] init 0;

[reconfigure] (phases=0) -> (phases'=1);
[end_reconfigure] (phases=1) -> (phases'=2);
[working] (phases=2) -> (phases'=0);

endmodule

module timer
time: [0..c_max_time] init 0;

[working] (time < c_max_time) -> (time'=time+1);
[reconfigure] (time < c_max_time) -> true;

[end] (time=c_max_time) -> true;
endmodule

rewards "Utility"
[working] true : config1*3 + config2*2;
endrewards
\end{lstlisting}

\end{figure}


%\begin{itemize}
%	\item USE: scc with loops
%	\item We already saw in chapter ch that variables can help a lot with understanding an \chgph
%	\item When applying it to time and phases we see that the system has limited timed behavior and that it operates in phases
%	\item considering time pll phases we see that these phases are repeated for each time
%	\item Still no idea what the model actually does
%	\item since this view has actions it may help to use the outactions view
%	\item see phases
%	\item when activating phases pll action see that in phase=0 ... and will eventually terminate in phase=0
%	\item \redcomment{time+scc+init}
%%	\item time apply strongly connected components -> structure of mdp very clear
%%	\item apply init to see where it start
%	\item maxReward is infinite -> not wanted
%	\item search for cycles or scc
%	\item are cycles $\to$ exact cycles \redcomment{maybe exact cycles}
%	\item fix mdp $\to$ no more cycles $\to$ show no more cycles
%	
%\end{itemize}

\subsection{Performance}

\viewsNC will be used on \mdpsN, that may have millions of states. For this reason, in this section we will consider the time to create a new view. In addition, we will take a look at the build time of the internal graph structure (\texttt{mdpGraph}), which is based on the \jgrapht library, in terms of its build time and memory usage. The tests were performed on a Dell XPS 9370 (16 GB RAM, Intel Core i7-8550U) with Manjaro KDE. Only necessary tools were open during the test: Firefox and IntelliJ.

Time was measured with self-written classes \texttt{Timer} and \texttt{TimeSaver} using the package \texttt{java.time.LocalTime}. The class implementation and an example use case are provided in the appendix (\ref{apx:timerandexmp}). Memory usage was measured using the Java Object Layout (JOL) tool provided by openJDK. The method used was \texttt{totalSize()} in \texttt{org.openjdk.jol.info.GraphLayout}. The benchmark uses a single scalable \mdpN (prism model file in the appendix). The sizes considered are 50, 100, 500, 1 000, 5 000, 10 000, 50 000, 100 000, 500 000, and 1 000 000. Using a single scalable \mdpN means that execution times and memory usage may vary with different graph structures of the \mdpN. This is especially true for \viewsN based on the graph structure. Therefore, in this section we will give an overview of the expected values for build times and memory usage rather than a detailed analysis.

First, we will look at the time required to create \viewsN. All \viewsN are created 100 times for each considered size of the \mdpN. Their execution times for each size are then averaged. As we know from the \ref{ch:viewimpl} chapter, creating a view involves instantiating the object and calling the build function. The instantiation only involves setting a handful of private attributes. Since the number of attributes of a view is fixed and their size is not related to the size of the \mdpN, the instantiation time is negligible. Building \texttt{mdpGraph} is also part of instantiating a \viewN if it has not yet been built on the model, but will be considered separately. Therefore, we will focus on the time taken by the \texttt{buildView()} method. As we know from the section \ref{ch:viewimpl}, the build \texttt{buildView()} method is divided into four parts: 1) prechecks, 2) creating a new column, 3) executing \grpfctN 4) writing the results to the database. First, we will consider the computation time of the grouping function, since the time for the actions performed in steps 1), 2) and 4) are almost identical or identical, with respect to the different sizes of \mdpN.
\begin{figure}[!htb]
	\begin{tikzpicture}
		\begin{loglogaxis}
			[
			width=\textwidth,
			height=8cm,
			xlabel={State amount},
			ylabel={$\frac{time}{ms}$},
			legend pos=north west,
			ymin=0,
			%		ymax=1000, % Adjust the y-axis range as needed
			]
			
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/InActIdentView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/OutActIdentView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/InActView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/OutActView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/OutActSetSizeView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/VariablesView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/VariablesViewDnf.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/VariablesViewCnf.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/ReachabilityView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/DistanceView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/SccView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/SccbView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/APView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/InitView.csv};
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/PropertyView.csv};
			
			
			
			%		\legend{InActIdentView, 
				%			OutActIdentView,
				%			InActView,
				%			OutActView,
				%			OutActSetSizeView,
				%			VariablesView,
				%			VariablesViewDnf,
				%			VariablesViewCnf, 
				%			ReachabilityView, 
				%			DistanceView,
				%			SccView,
				%			SccbView,
				%			APView,
				%			InitView,
				%			PropertyView}
			
		\end{loglogaxis}
	\end{tikzpicture}
	\caption{Average grouping function computation times}
	\label{fig:grpfcttimes}
\end{figure}

In Figure \ref{fig:grpfcttimes} we see the averaged execution times (100 executions) of \texttt{groupingFunction} for the different \viewsN. It can be seen that the execution times are very similar overall and behave linearly with the number of states of the \mdpN. For \mdpsN with up to 1 million states for no \viewN, the execution time of its grouping function exceeds 1.5 seconds. Variations in the microsecond range are to be expected for very small \mdpsN. In general, the performance results as shown indicate very good scalability in terms of views being usable on large models. This very good performance is largely due to the graph structure provided by \jgrapht.

\begin{figure}[!htb]
	\begin{tikzpicture}
		\begin{loglogaxis}
			[
			width=\textwidth,
			height=8cm,
			xlabel={State amount},
			ylabel={$\frac{time}{ms}$},
			legend pos=north west,
			ymin=0,
			%		ymax=1000, % Adjust the y-axis range as needed
			]
			
			
			\addplot table [x=StateCount, y=0AvgG, col sep=comma] {./06/PerformanceTests/GroupingFunction/OutActIdentView.csv};
			\addplot table [x=StateCount, y=0AvgMdp, col sep=comma] {./06/PerformanceTests/MdpGraph/MdpGraph.csv};
			\addplot table [x=StateCount, y=0AvgE, col sep=comma] {./06/PerformanceTests/ExecuteBatch/ExecuteBatchInActIdentCSV2-all.csv};
			\addplot table [x=StateCount, y=1AvgP, col sep=comma] {./06/PerformanceTests/PreChecks/PreChecks.csv};
			
			
			
			\legend{Grouping Function, 
				Create MDP Graph,
				Write to Database,
				Prechecks
			}
			
		\end{loglogaxis}
	\end{tikzpicture}
	\caption{Average times for grouping function computation (1 representative from Figure \ref{fig:grpfcttimes}), writing to the database and building the \texttt{mdpGraph}}
	\label{fig:compdbgraphgrpfct}
\end{figure}

In Figure \ref{fig:compdbgraphgrpfct} we see the execution time of the grouping function compared to executing the generated SQL statements (writing results/mappings to database) and the creation of the \texttt{mdpGraph}. We see that the execution time of the grouping function is the least time consuming operation, except for the prechecks. The most time is taken by writing the results to the database, where even building the \texttt{mdpGraph} is faster. The times for writing to the database refer to the current database implementation of \pmcvis, which may change in the future.

\begin{figure}[!htb]
	\begin{tikzpicture}
		\begin{loglogaxis}
			[
			width=\textwidth,
			height=8cm,
			xlabel={State amount},
			ylabel={$\frac{\texttt{mdpGraph} \text{ size}}{Byte}$},
			legend pos=north west,
			ymin=0,
			%		ymax=1000, % Adjust the y-axis range as needed
			]
			
			
			\addplot table [x=StateCount, y=MdpSizeByte, col sep=comma] {./06/PerformanceTests/MdpGraph/MdpGraphSize.csv};
			
			
			%			\legend{BuildTimeView, 
				%				CreateMdpGraph,
				%				ExecuteBatch
				%			}
			
		\end{loglogaxis}
	\end{tikzpicture}
	\caption{Size of \texttt{mdpGraph} for different model sizes}
	\label{fig:sizemdpgraph}
\end{figure}

As stated before, the performance of computing grouping functions depends heavily on the implemented graph structure (\texttt{mdpGraph}). This graph structure is held in memory and becomes quite large for \mdpsN with about a million states. Figure \ref{fig:sizemdpgraph} shows the measured depth size (including referenced objects) of the \texttt{mdpGraph}. As expected, the size of the \texttt{mdpGraph} is linear to the size of the \mdpN. Additionally, it can be seen that up to 1.3 GB of memory is used for the graph alone when the \mdpN reaches about 1 million states. Depending on the operating system, the amount of memory built into the machine (PC) and the currently available memory, it is possible to use the \texttt{mdpGraph} even for large \mdpsN. However, it should be noted that this is only the size of the built graph object. When reading from the database to build the \texttt{mdpGraph}, more memory is needed because the objects containing the information from the database also remain temporarily in memory. \pmcvis itself will also use memory, as will other possibly unrelated processes running on the system. On the machine used for testing, building the \texttt{mdpGraph} for \mdpsN with about 1 million states and creating views on them was still reasonable, but also close to the memory limit of the system. The \texttt{mdpGraph} could not be created with the test machine when the \mdpN used for testing was configured to five million states.

In general, we conclude that the computation of grouping functions is quite fast and scalable. The construction times of the \texttt{mdpGraph} are reasonable, but entail a high memory consumption. Database accesses are the most time consuming portion of the view creation time. 

\end{document}