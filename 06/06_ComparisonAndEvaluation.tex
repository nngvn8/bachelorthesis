\documentclass[preview]{standalone}
%\usepackage{prelude}
\input{prelude}


\begin{document}
\section{Comparison and Evaluation} \label{ch:eval}
Performance Cycles -> Selection of states and induced subgraph easily possible perform cycle search only on subset of graph 
-> in general generating views on subgraphs easily possible (only when needed for performance)
Clustering exact Cycles when clustering exact cycles


\subsection{Explore Modules} \label{subsec:evalmodules}

One Purpose of \viewsN is to simplify \mdpsN to make them better understandable. Due to the state explosion problem already rather simple systems can become very hard to oversee. As an example consider the concurrency problem Dining Philosophers, where n philosophers have to share n-1 forks and each of them needs two to eat. They are sitting on a round table with forks between them. Each of them only has access to fork to their left and right, if it is not already occupied. When representing the problem with an \mdpN the choice of which fork the philosopher tries to pick is made at random with an uniform distribution. The respective prism File is shown in \redcomment{add Screenshot appendix}.

Already for only three philosophers the \mdpN has 956 states. When looking at the graphical representation from \pmcvis \redcomment{Figure} it appears to be little helpful for understanding and exploring the graph due to its sheer size. Although large this \mdp is still rather small. With already five philosophers the MDP has about 100 000 states and with 10 philosophers the resulting MDP has more than 8 billion states. The \viewN \viewparamvalident can help to only show the behavior of some Philosophers and hiding the behavior of the remaining ones. 

The \viewN \viewparamvalident(p1) groups all states that have the same value of p1 ignoring the values of the remaining variables. That is, the values of p2 p3 are hidden, which results in only showing the module of philosopher p1 \redcomment{Figure}. This may help immensely if only a specific module is of interest or the reaming modules have the same structure, as it is the case here with Dining Philosophers. After applying further views could be \viewparamvalident(p1) applied to understand or explore the module. For example if in Dining Philosophers we were interested in the part of the module where p1 picks their first fork we could use the \viewN \viewparamdnf with c(s) = ({Figure}).

It is also possible to use the view \viewparamvalident to see the interleaved behavior of two or more modules. To see the interleaved behavior of p1 and p2, we use parallel composition $\viewparamvalident \pll \viewparamvalident$. This results in states being grouped where $(\gfctparamvalident, \gfctparamvalident) = (\gfctparamvalident, \gfctparamvalident)$. Hence only the value of s3 is hidden which results exactly in the desired \redcomment{interleaved model} (\redcomment{Figure}).

In general the views \viewparamdnf and \viewparamcnf are very powerful since they allow arbitrary operations on parameters.

\begin{itemize}
	\item USE: dinging Philosopher
	\item consider dining Philosophers with
	\item current graphical Representation looks as follows
	\item only has about 1000 states in case studies prism mdp with about ... states
	\item in general seems simple
	\item parameters cluster: allows looking at just one module
	\item also interleaving of arbitrary modules
	\item
	\item hasAction or OutAction-Ident for specific MDP-that run through configuration phases
	
\end{itemize}

\subsection{Find out why illegal states is reached}
In this chapter we want to show how views can be used for debugging. In this specific case we assume that we observed unwanted behavior or model checking results. We know that some states - that is some assignment of variables - are not allowed. We will check if these states are in fact not reachable.

We will consider the following small MDP the represents two systems that intend to send information via a unshareable medium. With a probability of $0.8$ a system can establish a connection and with probability of $0.2$ establishing a connection will fail. After an established connection access to the medium shall only be granted, if it is not occupied by the other system. If the medium is not occupied the system starts sending, otherwise it waits until the medium is free. The termination of the transmission is modeled with probabilities. There is 50 percent chance of terminating the transmission and a 50 percent chances of continuing.

The state <2,2> should not be reachable, since it represents the situation of the two systems occupying the unshareable medium at the same time. We will check if this state in fact is not reachable.

We observe, that this state is reachable. The questions occurs how and why. In order to obtain this information we should investigate by which state this critical state has been reached. One way of accomplishing that is to look into the database that stores states and transitions. They look as follows. 

An even better approach is to look in the model file, which looks as follows:

Persons with experience in working with prism models, might quickly spot the issue, especially because this is a rather small \mdp. With less experienced people or a lot larger models, finding an issue becomes much more difficult. Hence, let us see how views can help us.

Firstly we will use the view \viewdistance from that state on. Because in the current version of the project not expansion has not been implemented yet we will use a custom view that emulates this feature

\begin{definition}
	content...
\end{definition}

We will use partial application with \gfctdistance(s) = 1 to expand that state. The MDP-Graph then looks as in \redcomment{Figure}. It is to see that the state only contains a single state namely with the id seven. In the current version of implementation it is not possible, to obtain the parameter values. With the database file we obtain that this is the state where $x=2$ and $y=1$. Thus, we see that is possible for the second system to send on the medium although it is already occupied by the first system!

When now looking at the prism file we can see why this is the case. In line when y=1 there is a 50 percent chance to enter y=2. This line originally was intended for termination of the transmission. From y=1 it should not be possible to enter y=2 if x=2. After fixing this, the state no longer appears after the application of \viewparamdnf(....).

	
	\begin{itemize}
		\item USE: two process switch 
		\item illegal state has been reached?
		\item given state 2,2 should not be reachable
		\item is reachable
		\item is only!
		\item apply distance cluster
		\item emulate not yet feature of expansion
		\item use identityView (with Parameters)
		\item see in Database
		\item fix in File
	\end{itemize}


%\subsection{Find out how why we reach a certain state}
%%	\item two dies
%%	\item property cluster

\subsection{Understand and Exploring an MDP + SCC - Cycles?!}

In this subsection we want to take a look at a more complex usecase how views might help us to understand and fix a given \mdpN. We refer to the \mdp \redcomment{reference}.

Firstly, we will gather some understanding of the model. We have already seen in Chapter \ref{subsec:eval_modules} that the variables view can show modules. Firstly lets apply \viewparamvalident(phases) to understand the module phases \redcomment{Figure}. We see that system operates in three different phases. Since we utilize the view \viewstrongoutactident  Hence we know that the system is working for phase=0, configuring for phase=1 and termination configuration in phase=2. If instead we only apply the \viewN \viewparamvalident(phases) we see that the system has a timed behavior (\redcomment{Figure}). If we view the model with \viewparamvalident(phases) \pll \viewparamvalident(time), we can see how these phases are repeated over time {Figure}. The view \viewscc is intended to give an overview. If we combine it with \viewparamvalident(time) it yields an excellent overview over the system (\redcomment{Figure}), especially if we combine it with \viewinitstates (\redcomment{Figure}). 

In general we learned that this system runs several times with choosing certain configurations each time before it runs. Its rewards function rewards states that work with a better configuration. A classic model checking \redcomment{value} is to determine \redcomment{MIN EXP REWARD} and \redcomment{MAX EXP REWARD}. For \redcomment{MIN EXP REWARD} we obtain \redcomment{x}, for \redcomment{MAX EXP REWARD} \redcomment{inf}. Since the system is modeled for a finite time and each time chooses from a finite set of configurations, it is unwanted behavior, that \redcomment{MAX EXP REWARD} is infinite. We will now show how views can help to find the cause.

Such behavior of infinite \redcomment{MAX EXP REWARD} is often caused by cycles. A feasible idea would be to use a view with cycles. As it will be discussed in Chapter \redcomment{Performance} these \viewsN very ressource intensive when there are larger strongly connected components. Moreover when finding strongly connected components the cycles are equally found since each cycle is a strongly connected component. The view yields that there are quite large strongly connected components (\redcomment{Figure}). To find out where these are locate we compose view the \mdpN with \viewscc \pll \viewstrongoutactident. We see that the strongly connected components are in the configuring phase. Now we can take a look at the prism file, we see that we can arbitrarily often switch the configuration. Hence, it is to be assured that a configuration can only be selected once. An easy way of accomplishing this is to sequentialize the selection of the two configuration: Firstly configuration1 is selected, afterwards configuration2 and finally the configuration phase ends.


\begin{itemize}
	\item USE: scc with loops
	\item begin with variables: reason: give overview of certain modules
	\item time -> shows we have timed behavior. After a certain amount of time the evolvement terminates
	\item phases we can see that reapeated behavior
	\item interleave phases we can see that we iterate through all phases for number of times
	\item Still no idea what the model actually does
	\item since this view has actions it may help to use the outactions view
	\item see phases
	\item when interleaving this again with phases see that in phase=0 ... and will eventually terminate in phase=0
	\item config2 also configuration but seems suspicious
	\item time and phases <- both beautifully show structure
	\item time apply strongly connected components -> structure of mdp very clear
	\item apply init to see where it start
	\item maxReward is infinite -> not wanted
	\item search for cycles
	\item are cycles $\to$ exact cycles \redcomment{maybe exact cycles}
	\item fix mdp $\to$ no more cycles $\to$ show no more cycles
	
\end{itemize}

\subsection{Performance}

\subsection{Critical remarks}
init cluster obsolete
no found usage for quantity on of actions or exact identity

\end{document}